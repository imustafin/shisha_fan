.\" -*- mode: troff; coding: UTF-8 -*-
.\"	$OpenBSD: elf.5,v 1.12 2003/10/27 20:23:58 jmc Exp $
.\"Copyright (c) 1999 Jeroen Ruigrok van der Werven
.\"All rights reserved.
.\"
.\" %%%LICENSE_START(PERMISSIVE_MISC)
.\"Redistribution and use in source and binary forms, with or without
.\"modification, are permitted provided that the following conditions
.\"are met:
.\"1. Redistributions of source code must retain the above copyright
.\"   notice, this list of conditions and the following disclaimer.
.\"2. Redistributions in binary form must reproduce the above copyright
.\"   notice, this list of conditions and the following disclaimer in the
.\"   documentation and/or other materials provided with the distribution.
.\"
.\"THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
.\"ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\"IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\"ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
.\"FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\"DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\"OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\"HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\"LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\"OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\"SUCH DAMAGE.
.\" %%%LICENSE_END
.\"
.\"	$FreeBSD: src/share/man/man5/elf.5,v 1.21 2001/10/01 16:09:23 ru Exp $
.\"
.\" Slightly adapted - aeb, 2004-01-01
.\" 2005-07-15, Mike Frysinger <vapier@gentoo.org>, various fixes
.\" 2007-10-11, Mike Frysinger <vapier@gentoo.org>, various fixes
.\" 2007-12-08, mtk, Converted from mdoc to man macros
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH ELF 5 2019\-05\-09 Linux "Руководство программиста Linux"
.SH ИМЯ
elf \- формат исполняемых и компонуемых файлов (ELF)
.SH ОБЗОР
.nf
.\" .B #include <elf_abi.h>
\fB#include <elf.h>\fP
.fi
.SH ОПИСАНИЕ
В заголовочном файле \fI<elf.h>\fP определён формат ELF для исполняемых
двоичных файлов. К таким файлам относятся обычные исполняемые файлы,
перемещаемые объектные файлы, core\-файлы и общие объекты.
.PP
Исполняемый файл в формате ELF состоит из заголовка ELF, таблицы заголовков
программы или таблицы заголовков разделов (или обеих таблиц). Заголовок ELF
всегда расположен в начале файла. Расположение таблицы заголовков программы
и таблицы заголовков разделов задаётся в заголовке ELF. В этих двух таблицах
описывается всё остальное содержимое файла.
.PP
.\" Applications which wish to process ELF binary files for their native
.\" architecture only should include
.\" .I <elf_abi.h>
.\" in their source code.
.\" These applications should need to refer to
.\" all the types and structures by their generic names
.\" "Elf_xxx"
.\" and to the macros by
.\" ELF_xxx".
.\" Applications written this way can be compiled on any architecture,
.\" regardless of whether the host is 32-bit or 64-bit.
.\" .PP
.\" Should an application need to process ELF files of an unknown
.\" architecture, then the application needs to explicitly use either
.\" "Elf32_xxx"
.\" or
.\" "Elf64_xxx"
.\" type and structure names.
.\" Likewise, the macros need to be identified by
.\" "ELF32_xxx"
.\" or
.\" "ELF64_xxx".
.\" .PP
.\"
Данный заголовочный файл описывает вышеупомянутые заголовки в виде структур
C, а также включает описание структур динамических разделов, разделов
перемещений и таблиц символов.
.SS "Базовые типы"
Для каждой N\-битной архитектуры используются следующие типы (N=32,64;
\fIElfN\fP может быть \fIElf32\fP или \fIElf64\fP; \fIuintN_t\fP может быть \fIuint32_t\fP
или \fIuint64_t\fP):
.PP
.in +4n
.EX
.\" Elf32_Size  Unsigned object size
ElfN_Addr       Беззнаковый адрес программы, uintN_t
ElfN_Off        Беззнаковое смещение в файле, uintN_t
ElfN_Section    Беззнаковый индекс раздела, uint16_t
ElfN_Versym     Беззнаковые данные о версии символа, uint16_t
Elf_Byte        unsigned char
ElfN_Half       uint16_t
ElfN_Sword      int32_t
ElfN_Word       uint32_t
ElfN_Sxword     int64_t
ElfN_Xword      uint64_t
.EE
.in
.PP
(Замечание: В *BSD используется немного другая терминология. Так,
\fIElf64_Half\fP — удвоенный \fIElf32_Half\fP, а \fIElf64Quarter\fP —
\fIuint16_t\fP. Чтобы не путаться, далее эти типы заменены на их явные типы.)
.PP
.\"
Все структуры данных этого формата файлов следуют «естественному» размеру и
принципам выравнивания соответствующего класса. Если требуется, структуры
данных содержат явно указанные заполнители (padding) для выравнивания по 4\-м
байтам для 4\-байтовых объектов, для доведения размера структур до кратного
4\-м и т. д.
.SS "Заголовок ELF (Ehdr)"
Заголовок ELF описывается типом \fIElf32_Ehdr\fP или \fIElf64_Ehdr\fP:
.PP
.in +4n
.EX
#define EI_NIDENT 16

typedef struct {
    unsigned char e_ident[EI_NIDENT];
    uint16_t      e_type;
    uint16_t      e_machine;
    uint32_t      e_version;
    ElfN_Addr     e_entry;
    ElfN_Off      e_phoff;
    ElfN_Off      e_shoff;
    uint32_t      e_flags;
    uint16_t      e_ehsize;
    uint16_t      e_phentsize;
    uint16_t      e_phnum;
    uint16_t      e_shentsize;
    uint16_t      e_shnum;
    uint16_t      e_shstrndx;
} ElfN_Ehdr;
.EE
.in
.PP
.\"
Значения полей:
.nr l1_indent 10
.\"
.TP  \n[l1_indent]
\fIe_ident\fP
Массив байт, описывающий как воспринимать файл, не зависит от типа
процессора или остального содержимого файла. Всё в массиве описывается
макросами, начинающимися с префикса \fBEI_\fP, которые могут иметь значения,
начинающиеся с префикса \fBELF\fP. Определены следующие макросы:
.RS
.TP  9
\fBEI_MAG0\fP
Первый байт отличительного (magic) числа. Должен быть заполнен
\fBELFMAG0\fP. (0: 0x7f)
.TP 
\fBEI_MAG1\fP
Второй байт отличительного числа. Должен быть заполнен \fBELFMAG1\fP. (1:
\(aqE\(aq)
.TP 
\fBEI_MAG2\fP
Третий байт отличительного числа. Должен быть заполнен \fBELFMAG2\fP. (2:
\(aqL\(aq)
.TP 
\fBEI_MAG3\fP
Четвёртый байт отличительного числа. Должен быть заполнен \fBELFMAG3\fP. (3:
\(aqF\(aq)
.TP 
\fBEI_CLASS\fP
В пятом байте задаётся архитектура двоичного файла:
.RS
.TP  14
.PD 0
\fBELFCLASSNONE\fP
Неправильный класс.
.TP 
\fBELFCLASS32\fP
32\-битная архитектура. Поддерживаются машины с файлами и виртуальным
адресным пространством до 4 гигабайт.
.TP 
\fBELFCLASS64\fP
64\-битная архитектура.
.PD
.RE
.TP 
\fBEI_DATA\fP
В шестом байте задаётся порядок кодирования данных в файле, используемый в
процессоре. В настоящее время поддерживаются:
.RS 9
.TP  14
.PD 0
\fBELFDATANONE\fP
Неизвестный формат данных.
.TP 
\fBELFDATA2LSB\fP
Обратный порядок байт (little\-endian) в дополнительном коде.
.TP 
\fBELFDATA2MSB\fP
Прямой порядок байт (big\-endian) в дополнительном коде.
.PD
.RE
.TP 
\fBEI_VERSION\fP
В седьмом байте указывается номер версии спецификации ELF:
.IP
.PD 0
.RS
.TP  14
\fBEV_NONE\fP
Неправильный номер версии.
.TP 
\fBEV_CURRENT\fP
Текущая версия.
.PD
.RE
.\".El
.TP 
\fBEI_OSABI\fP
В восьмом байте указывается тип операционной системы и двоичного интерфейса
приложений (ABI), для которой предназначен объект. Некоторые поля в других
структурах ELF имеют флаги и значения, зависящие от платформы; интерпретация
таких полей определяется значением данного байта. Пример:
.RS
.TP  21
.PD 0
\fBELFOSABI_NONE\fP
.\" 0
Тоже что и ELFOSABI_SYSV.
.TP 
\fBELFOSABI_SYSV\fP
.\" 0
.\" synonym: ELFOSABI_NONE
UNIX System V ABI
.TP 
\fBELFOSABI_HPUX\fP
.\" 1
HP\-UX ABI
.TP 
\fBELFOSABI_NETBSD\fP
.\" 2
NetBSD ABI
.TP 
\fBELFOSABI_LINUX\fP
.\" 3
.\" .TP
.\" .BR ELFOSABI_HURD
.\" Hurd ABI
.\" 4
.\" .TP
.\" .BR ELFOSABI_86OPEN
.\" 86Open Common IA32 ABI
.\" 5
Linux ABI
.TP 
\fBELFOSABI_SOLARIS\fP
.\" 6
.\" .TP
.\" .BR ELFOSABI_MONTEREY
.\" Monterey project ABI
.\" Now replaced by
.\" ELFOSABI_AIX
.\" 7
Solaris ABI
.TP 
\fBELFOSABI_IRIX\fP
.\" 8
IRIX ABI
.TP 
\fBELFOSABI_FREEBSD\fP
.\" 9
FreeBSD ABI
.TP 
\fBELFOSABI_TRU64\fP
.\" 10
.\" ELFOSABI_MODESTO
.\" 11
.\" ELFOSABI_OPENBSD
.\" 12
TRU64 UNIX ABI
.TP 
\fBELFOSABI_ARM\fP
.\" 97
ABI архитектуры ARM
.TP 
\fBELFOSABI_STANDALONE\fP
.\" 255
Автономный (встраиваемый) ABI
.PD
.RE
.TP 
\fBEI_ABIVERSION\fP
В девятом байте указывается версия ABI, для которой предназначен объект. Это
поле используется для разграничения несовместимых версий ABI. Интерпретация
данного номера версии зависит от ABI, указанного в поле \fBEI_OSABI\fP. В
приложениях, удовлетворяющих данной спецификации, используется значение 0.
.TP 
\fBEI_PAD\fP
.\" As reported by Yuri Kozlov and confirmed by Mike Frysinger, EI_BRAND is
.\" not in GABI (http://www.sco.com/developers/gabi/latest/ch4.eheader.html)
.\" It looks to be a BSDism
.\" .TP
.\" .BR EI_BRAND
.\" Start of architecture identification.
Начало заполнителя. Эти байты зарезервированы и устанавливаются в
ноль. Программы, читающие заголовок, должны игнорировать их. Значение
\fBEI_PAD\fP будет изменено, если понадобится задействовать неиспользуемые в
данный момент байты.
.TP 
\fBEI_NIDENT\fP
Размер массива \fIe_ident\fP.
.RE
.TP 
\fIe_type\fP
В этом поле структуры содержится тип объектного файла:
.RS
.TP  16
.PD 0
\fBET_NONE\fP
Неизвестный тип.
.TP 
\fBET_REL\fP
Перемещаемый файл.
.TP 
\fBET_EXEC\fP
Исполняемый файл.
.TP 
\fBET_DYN\fP
Динамический объект.
.TP 
\fBET_CORE\fP
Файл типа core.
.PD
.RE
.TP 
\fIe_machine\fP
В этом поле содержится значение требуемой для файла архитектуры. Пример:
.RS \n[l1_indent]
.TP  16
.PD 0
\fBEM_NONE\fP
.\" 0
Неизвестная машинная архитектура
.TP 
\fBEM_M32\fP
.\" 1
AT&T WE 32100
.TP 
\fBEM_SPARC\fP
.\" 2
Sun Microsystems SPARC
.TP 
\fBEM_386\fP
.\" 3
Intel 80386
.TP 
\fBEM_68K\fP
.\" 4
Motorola 68000
.TP 
\fBEM_88K\fP
.\" 5
.\" .TP
.\" .BR EM_486
.\" Intel 80486
.\" 6
Motorola 88000
.TP 
\fBEM_860\fP
.\" 7
Intel 80860
.TP 
\fBEM_MIPS\fP
.\" 8
.\" EM_S370
.\" 9
.\" .TP
.\" .BR EM_MIPS_RS4_BE
.\" MIPS RS4000 (big-endian only). Deprecated
.\" 10
.\" EM_MIPS_RS3_LE (MIPS R3000 little-endian)
.\" 10
MIPS RS3000 (только с прямым порядком байт)
.TP 
\fBEM_PARISC\fP
.\" 15
HP/PA
.TP 
\fBEM_SPARC32PLUS\fP
.\" 18
SPARC с расширенным набором инструкций
.TP 
\fBEM_PPC\fP
.\" 20
PowerPC
.TP 
\fBEM_PPC64\fP
.\" 21
PowerPC, 64\-битная
.TP 
\fBEM_S390\fP
.\" 22
IBM S/390.
.TP 
\fBEM_ARM\fP
.\" 40
Advanced RISC Machines.
.TP 
\fBEM_SH\fP
.\" 42
Renesas SuperH.
.TP 
\fBEM_SPARCV9\fP
.\" 43
SPARC v9, 64\-битная
.TP 
\fBEM_IA_64\fP
.\" 50
Intel Itanium.
.TP 
\fBEM_X86_64\fP
.\" 62
AMD x86\-64.
.TP 
\fBEM_VAX\fP
.\" 75
.\" EM_CRIS
.\" 76
.\" .TP
.\" .BR EM_ALPHA
.\" Compaq [DEC] Alpha
.\" .TP
.\" .BR EM_ALPHA_EXP
.\" Compaq [DEC] Alpha with enhanced instruction set
DEC Vax
.PD
.RE
.TP 
\fIe_version\fP
В этом поле содержится версия файла:
.RS
.TP  16
.PD 0
\fBEV_NONE\fP
Неправильный номер версии
.TP 
\fBEV_CURRENT\fP
Текущая версия
.PD
.RE
.TP 
\fIe_entry\fP
В этом поле содержится виртуальный адрес, по которому система должна
передать управление для запуска процесса. Если в файле нет такой точки
входа, то значение поля равно 0.
.TP 
\fIe_phoff\fP
В этом поле содержится файловое смещение в байтах для таблицы заголовков
программы. Если в файле нет таблицы заголовков программы, то значение поля
равно 0.
.TP 
\fIe_shoff\fP
В этом поле содержится файловое смещение в байтах для таблицы заголовков
разделов. Если в файле нет таблицы заголовков разделов, то значение поля
равно 0.
.TP 
\fIe_flags\fP
В этом поле содержатся специфичные для процессора флаги, относящиеся к
файлу. Имена флагов имеют вид: EF_машинный_флаг. В настоящее время нет ни
одного предопределённого флага.
.TP 
\fIe_ehsize\fP
В этом поле содержится размер заголовка ELF в байтах.
.TP 
\fIe_phentsize\fP
В этом поле содержится размер в байтах одного элемента таблицы заголовков
программы в файле; все элементы имеют одинаковый размер.
.TP 
\fIe_phnum\fP
В этом поле содержится количество элементов в таблице заголовков
программы. Таким образом, произведение \fIe_phentsize\fP и \fIe_phnum\fP даёт
размер таблицы в байтах. Если в файле нет заголовков программы, то
\fIe_phnum\fP содержит 0.
.IP
.\" This is a Linux extension, added in Linux 2.6.34.
Если количество элементов в таблице заголовков программы больше или равно
\fBPN_XNUM\fP (0xffff), это поле  содержит значение \fBPN_XNUM\fP (0xffff) и
реальное количество элементов таблицы заголовков программы хранится в поле
\fIsh_info\fP начального элемента таблицы заголовков разделов. Иначе поле
\fIsh_info\fP начального элемента содержит ноль.
.RS \n[l1_indent]
.TP  9
\fBPN_XNUM\fP
Имеет значение 0xffff, самое большое количество, которое может иметь
\fIe_phnum\fP, показывает, где расположено реальное количество заголовков
программы.
.PD
.RE
.IP
.TP 
\fIe_shentsize\fP
В этом поле содержится размер в байтах одного элемента таблицы заголовков
разделов; все элементы имеют одинаковый размер.
.TP 
\fIe_shnum\fP
В этом поле содержится количество элементов в таблице заголовков
разделов. Таким образом, произведение \fIe_shentsize\fP и \fIe_shnum\fP даёт
размер таблицы разделов в байтах. Если в файле нет заголовков разделов, то
\fIe_shnum\fP содержит 0.
.IP
Если количество элементов в таблице заголовков разделов больше или равно
\fBSHN_LORESERVE\fP (0xff00), то значение \fIe_shnum\fP равно и реальное
количество элементов таблицы заголовков разделов хранится в поле \fIsh_size\fP
начального элемента таблицы заголовков разделов. Иначе поле \fIsh_size\fP
начального элемента таблицы заголовков разделов имеет значение ноль.
.TP 
\fIe_shstrndx\fP
В этом поле содержится индекс элемента в таблице заголовков разделов,
указывающий на строковую таблицу названий разделов. Если в файле нет
строковой таблицы названий разделов, то это поле содержит значение
\fBSHN_UNDEF\fP.
.IP
.\"
Если индекс строки имён разделов в таблице разделов больше или равен
\fBSHN_LORESERVE\fP (0xff00), то в этом поле содержится значение \fBSHN_XINDEX\fP
(0xffff) и реальный индекс строки имён разделов в таблице разделов хранится
в поле \fIsh_link\fP начального элемента таблицы заголовков разделов. Иначе
поле \fIsh_link\fP начального элемента таблицы заголовков разделов имеет
значение ноль.
.SS "Заголовок программы (Phdr)"
Таблица заголовков программы исполняемого или совместно используемого
объектного файла представляет собой массив структур, каждая из которых
описывает сегмент или содержит другую информацию, необходимую системе для
подготовки программы к выполнению. \fIСегмент\fP объектного файла содержит один
или более \fIразделов\fP. Заголовки программы нужны только для исполняемых и
совместно используемых объектных файлов. Размер заголовков программы
указывается в файле в заголовке ELF в полях \fIe_phentsize\fP и
\fIe_phnum\fP. Заголовок программы ELF описывается типом \fIElf32_Phdr\fP или
\fIElf64_Phdr\fP, в зависимости от архитектуры:
.PP
.in +4n
.EX
typedef struct {
    uint32_t   p_type;
    Elf32_Off  p_offset;
    Elf32_Addr p_vaddr;
    Elf32_Addr p_paddr;
    uint32_t   p_filesz;
    uint32_t   p_memsz;
    uint32_t   p_flags;
    uint32_t   p_align;
} Elf32_Phdr;
.EE
.in
.PP
.in +4n
.EX
typedef struct {
    uint32_t   p_type;
    uint32_t   p_flags;
    Elf64_Off  p_offset;
    Elf64_Addr p_vaddr;
    Elf64_Addr p_paddr;
    uint64_t   p_filesz;
    uint64_t   p_memsz;
    uint64_t   p_align;
} Elf64_Phdr;
.EE
.in
.PP
Основным отличием между 32\-битным и 64\-битным программным заголовком в
структуре является расположение поля \fIp_flags\fP.
.TP  10
\fIp_type\fP
Это поле структуры определяет, какой тип сегмента описывает этот элемент
массива или как воспринимать информацию данного элемента массива.
.RS 10
.TP  12
\fBPT_NULL\fP
Элемент массива не используется и значения других полей не определены. Это
позволяет иметь в заголовке программы игнорируемые элементы.
.TP 
\fBPT_LOAD\fP
Элемент массива определяет загружаемый сегмент, описываемый \fIp_filesz\fP и
\fIp_memsz\fP. Байты из файла проецируются в начало сегмента памяти. Если
размер сегмента памяти \fIp_memsz\fP больше чем размер файла \fIp_filesz\fP, то
определяются "дополнительные" байты, содержащие значение 0, и их располагают
за инициализированной областью сегмента. Размер файла не может быть больше
размера памяти. Элементы загружаемых сегментов в таблице заголовков
программы располагаются в порядке возрастания, их сортируют по полю
\fIp_vaddr\fP.
.TP 
\fBPT_DYNAMIC\fP
Элемент массива указывает на данные с информацией по динамической
компоновке.
.TP 
\fBPT_INTERP\fP
Элемент массива указывает на данные о расположении и размере пути
(завершается null) вызываемого интерпретатора. Этот тип сегмента имеет смысл
только для исполняемых файлов (хотя может быть и в динамических объектных
файлах). Однако, в файле он не может указываться более одного раза. Если он
задан, то должен находиться перед всеми элементами загружаемых сегментов.
.TP 
\fBPT_NOTE\fP
Элемент массива указывает на расположение заметок (ElfN_Nhdr).
.TP 
\fBPT_SHLIB\fP
Данный тип сегмента зарезервирован, но имеет неопределённую
семантику. Программы, в которых есть элемент массива такого типа, не
соответствуют ABI.
.TP 
\fBPT_PHDR\fP
Элемент массива, если есть, указывает на расположение и размер самой таблицы
заголовков программы, и в файле и в образе программы в памяти. Данный тип
сегмента не может встречаться в файле более одного раза. Кроме того, он
может задаваться только если таблица заголовков программы является частью
образа программы в памяти. Если он задан, то должен находиться до элементов
загружаемых сегментов.
.TP 
\fBPT_LOPROC\fP, \fBPT_HIPROC\fP
Значения из диапазона [\fBPT_LOPROC\fP, \fBPT_HIPROC\fP] (не включая)
зарезервированы для процессорно\-ориентированной семантики.
.TP 
\fBPT_GNU_STACK\fP
Расширение GNU, используемое ядром Linux для управления состоянием стека
через флаги, настраивается в поле \fIp_flags\fP.
.RE
.TP 
\fIp_offset\fP
Это поле содержит смещение от начала файла, по которому располагается первый
байт сегмента.
.TP 
\fIp_vaddr\fP
Это поле содержит виртуальный адрес, по которому располагается первый байт
сегмента в памяти.
.TP 
\fIp_paddr\fP
В системах, для которых важна физическая адресация, это поле зарезервировано
для физического адреса сегмента. В BSD это поле не используется и должно
быть равно нулю.
.TP 
\fIp_filesz\fP
В этом поле содержится число байт занимаемое сегментом в файле. Оно может
быть равно нулю.
.TP 
\fIp_memsz\fP
В этом поле содержится число байт занимаемое сегментом в памяти. Оно может
быть равно нулю.
.TP 
\fIp_flags\fP
В этом поле содержится битовая маска флагов соответствующего сегмента:
.RS \n[l1_indent]
.TP 
.PD 0
\fBPF_X\fP
Исполняемый сегмент.
.TP 
\fBPF_W\fP
Сегмент доступен для записи.
.TP 
\fBPF_R\fP
Сегмент доступен для чтения.
.PD
.RE
.IP
Сегмента кода (text segment) обычно имеет флаги \fBPF_X\fP и \fBPF_R\fP. Сегмент
данных обычно имеет флаги \fBPF_W\fP и \fBPF_R\fP.
.TP 
\fIp_align\fP
.\"
В этом поле содержится значение согласно которому сегменты выровнены в
памяти и в файле. У загружаемых сегментов процесса значения \fIp_vaddr\fP и
\fIp_offset\fP должны быть кратны размеру страницы. Величины ноль и один
означают, что выравнивание не требуется. В противном случае значение
\fIp_align\fP должно быть положительным числом кратным степени двойки, а
значение \fIp_vaddr\fP должно быть равно \fIp_offset\fP и кратным \fIp_align\fP.
.SS "Заголовок раздела (Shdr)"
По таблице заголовков разделов можно найти расположение всех разделов в
файле. Она представляет собой массив структур \fIElf32_Shdr\fP или
\fIElf64_Shdr\fP. На начало таблицы заголовков разделов в файле указывает поле
\fIe_shoff\fP заголовка ELF (в байтах). В \fIe_shnum\fP содержится количество
элементов таблицы заголовков разделов. В \fIe_shentsize\fP содержится размер
каждого элемента в байтах.
.PP
Индекс элемента в таблице заголовков разделов указывает в этот
массив. Некоторые индексы элемента в таблице заголовков разделов
зарезервированы: начальный элемент и индексы от \fBSHN_LORESERVE\fP и до
\fBSHN_HIRESERVE\fP. Начальный элемент используется в расширениях ELF для
\fIe_phnum\fP, \fIe_shnum\fP and \fIe_strndx\fP; в других случаях, каждое поле
начального элемента равно нулю. В объектном файле нет разделов с этими
специальными индексами:
.TP 
\fBSHN_UNDEF\fP
Этим значением помечается неопределённая, отсутствующая, неприменимая, или
другая нецелесообразная ссылка на раздел.
.TP 
\fBSHN_LORESERVE\fP
Это значение задаёт нижнюю границу диапазона зарезервированных индексов.
.TP 
\fBSHN_LOPROC\fP, \fBSHN_HIPROC\fP
Значения, больше диапазона [\fBPT_LOPROC\fP, \fBPT_HIPROC\fP] (включительно)
зарезервированы для процессорно\-ориентированной семантики.
.TP 
\fBSHN_ABS\fP
Это значение указывает на абсолютное значение соответствующей
ссылки. Например, символы, определённые относительно раздела с номером
\fBSHN_ABS\fP, имеют абсолютные значения и не подвержены перемещению.
.TP 
\fBSHN_COMMON\fP
Символы, определённые относительно такого раздела, являются общими
символами, такими как Fortran COMMON или нераспределённые внешние переменные
C.
.TP 
\fBSHN_HIRESERVE\fP
Этим значением определяется верхняя граница диапазона зарезервированных
индексов. В системе зарезервированы индексы между \fBSHN_LORESERVE\fP и
\fBSHN_HIRESERVE\fP включительно. В таблице заголовков разделов нет элементов с
зарезервированными индексами.
.PP
Заголовок раздела имеет следующую структуру:
.PP
.in +4n
.EX
typedef struct {
    uint32_t   sh_name;
    uint32_t   sh_type;
    uint32_t   sh_flags;
    Elf32_Addr sh_addr;
    Elf32_Off  sh_offset;
    uint32_t   sh_size;
    uint32_t   sh_link;
    uint32_t   sh_info;
    uint32_t   sh_addralign;
    uint32_t   sh_entsize;
} Elf32_Shdr;
.EE
.in
.PP
.in +4n
.EX
typedef struct {
    uint32_t   sh_name;
    uint32_t   sh_type;
    uint64_t   sh_flags;
    Elf64_Addr sh_addr;
    Elf64_Off  sh_offset;
    uint64_t   sh_size;
    uint32_t   sh_link;
    uint32_t   sh_info;
    uint64_t   sh_addralign;
    uint64_t   sh_entsize;
} Elf64_Shdr;
.EE
.in
.PP
Существенной разницы между 32\-битными и 64\-битными заголовками разделов нет.
.TP  \n[l1_indent]
\fIsh_name\fP
В этом поле указывается название раздела. Его значением является индекс в
строковой таблице заголовков разделов, дающий расположение строки,
заканчивающейся null.
.TP 
\fIsh_type\fP
В этом поле содержится тип содержимого раздела, определяющий смысл.
.RS \n[l1_indent]
.TP  15
\fBSHT_NULL\fP
Этим значением помечают неактивные разделы в заголовке. У такого элемента
нет привязанного раздела. Значения других полей заголовка раздела не
определены.
.TP 
\fBSHT_PROGBITS\fP
Этот раздел содержит информацию, задаваемую программой; её формат и смысл
полностью определяется программой.
.TP 
\fBSHT_SYMTAB\fP
В этом разделе содержится таблица символов. Обычно, раздел \fBSHT_SYMTAB\fP
предоставляет символы для редактирования связей, хотя также может
использоваться при динамической компоновке. Являясь полной таблицей символов
может содержать символы, не требуемые для динамической компоновки. Объектный
файл также может содержать раздел \fBSHT_DYNSYM\fP.
.TP 
\fBSHT_STRTAB\fP
В этом разделе содержится таблица строк. В объектном файле может быть
несколько разделов с таблицами строк.
.TP 
\fBSHT_RELA\fP
В этом разделе содержатся элементы перемещения с явными добавками, такими
как тип \fIElf32_Rela\fP для 32\-битного класса объектных файлов. Объектный файл
может иметь несколько разделов перемещений.
.TP 
\fBSHT_HASH\fP
В этом разделе содержится хэш\-таблица символов. Объект, участвующий в
динамической компоновке, должен иметь хэш\-таблицу символов. В объектном
файле должна быть только одна хэш\-таблица.
.TP 
\fBSHT_DYNAMIC\fP
В этом разделе содержится информация по динамической компоновке. В объектном
файле должен быть только один динамический раздел.
.TP 
\fBSHT_NOTE\fP
В этом разделе содержатся заметки (ElfN_Nhdr).
.TP 
\fBSHT_NOBITS\fP
Разделы этого типа не занимают пространства в файле, но слегка напоминают
\fBSHT_PROGBITS\fP. Несмотря на то, что байт в нём нет, поле \fIsh_offset\fP
содержит умозрительное файловое смещение.
.TP 
\fBSHT_REL\fP
В этом разделе содержатся элементы перемещения без явных добавок, таких как
тип \fIElf32_Rela\fP для 32\-битного класса объектных файлов. Объектный файл
может иметь несколько разделов перемещений.
.TP 
\fBSHT_SHLIB\fP
Данный тип сегмента зарезервирован, но имеет неопределённую семантику.
.TP 
\fBSHT_DYNSYM\fP
В этом разделе содержится минимальный набор символов для динамической
компоновки. В объектном файле также может быть раздел \fBSHT_SYMTAB\fP.
.TP 
\fBSHT_LOPROC\fP, \fBSHT_HIPROC\fP
Значения из диапазона \fBSHT_LOPROC\fP, \fBSHT_HIPROC\fP] (включительно)
зарезервированы для процессорно\-ориентированной семантики.
.TP 
\fBSHT_LOUSER\fP
Это значение указывает на нижнюю границу диапазона индексов,
зарезервированного для пользовательских программ.
.TP 
\fBSHT_HIUSER\fP
Это значение указывает на нижнюю границу диапазона индексов,
зарезервированного для пользовательских программ. Разделы с типами, имеющими
значение между \fBSHT_LOUSER\fP и \fBSHT_HIUSER\fP, могут использоваться
приложениями не конфликтуя с имеющимися или будущими типами разделов,
определяемых системой.
.RE
.TP 
\fIsh_flags\fP
В этом поле указываются различные атрибуты раздела, задаваемые в виде
однобитных флагов. Если бит флага установлен в \fIsh_flags\fP, то атрибут
"активен" для раздела. Иначе атрибут "выключен" или не применяется. Не
указанные атрибуты сбрасываются в ноль.
.RS \n[l1_indent]
.TP  15
\fBSHF_WRITE\fP
В разделе содержатся данные, к которым при работе процесса нужен доступ на
запись.
.TP 
\fBSHF_ALLOC\fP
Этот раздел занимает память при работе процесса. Некоторые управляющие
разделы не располагаются в образе памяти объектного файла. Этот атрибут
выключен у таких разделов.
.TP 
\fBSHF_EXECINSTR\fP
Этот раздел содержит исполняемые машинные инструкции.
.TP 
\fBSHF_MASKPROC\fP
Все биты этой маски зарезервированы для процессорно\-ориентированной
семантики.
.RE
.TP 
\fIsh_addr\fP
Если этот раздел появляется в образе памяти процесса, то это поле содержит
адрес, по которому должен располагаться первый байт раздела. Иначе поле
содержит ноль.
.TP 
\fIsh_offset\fP
В этом поле содержится смещение в байтах от начала файла до первого байта
раздела. Раздел типа \fBSHT_NOBITS\fP не занимает места в файле и его поле
\fIsh_offset\fP содержит умозрительное размещение в файле.
.TP 
\fIsh_size\fP
В этом поле содержится размер раздела в байтах. За исключением раздела с
типом \fBSHT_NOBITS\fP, все разделы занимают \fIsh_size\fP байт в файле. Раздел с
типом \fBSHT_NOBITS\fP может иметь ненулевой размер, но места в файле не
занимает.
.TP 
\fIsh_link\fP
В этом поле содержится ссылка\-индекс в таблицу заголовков раздела, а
интерпретация зависит от типа раздела.
.TP 
\fIsh_info\fP
В этом поле содержится дополнительная информация, чья интерпретация зависит
от типа раздела.
.TP 
\fIsh_addralign\fP
Некоторые разделы имеют требования по выравниванию адресов. Если раздел
содержит двойное слово, то система должна произвести выравнивание по
двойному слову всего раздела. То есть, значение \fIsh_addr\fP должно быть
таким, чтобы при делении по модулю \fIsh_addralign\fP получался ноль. Разрешены
только ноль и положительные степени двойки. Значение 0 или 1 означают, что
раздел не имеет требований по выравниванию.
.TP 
\fIsh_entsize\fP
В некоторых разделах содержатся таблицы с элементами одинакового размера,
например, таблица символов. Для таких разделов в данном поле указывается
размер в байтах каждого элемента. Если раздел содержит таблицу с элементами
разного размера, то это поле равно нулю.
.PP
Программа и управляющая информация содержится в различных разделах:
.TP  \n[l1_indent]
\&\fI.bss\fP
В этом разделе содержатся неинициализированные данные, которые вносятся в
образ программы в памяти. По определению, в начале выполнения программы
система инициализирует эти данные нулями. Этот раздел имеет тип
\fBSHT_NOBITS\fP и атрибуты \fBSHF_ALLOC\fP и \fBSHF_WRITE\fP.
.TP 
\&\fI.comment\fP
В этом разделе содержится управляющая информация о версии. Он имеет тип
\fBSHT_PROGBITS\fP и не имеет атрибутов.
.TP 
\&\fI.ctors\fP
В этом разделе содержатся инициализированные указатели функций\-конструкторов
C++. Он имеет тип \fBSHT_PROGBITS\fP и атрибуты \fBSHF_ALLOC\fP и \fBSHF_WRITE\fP.
.TP 
\&\fI.data\fP
В этом разделе содержатся инициализированные данные, которые вносятся в
образ программы в памяти. Он имеет тип \fBSHT_PROGBITS\fP и атрибуты
\fBSHF_ALLOC\fP и \fBSHF_WRITE\fP.
.TP 
\&\fI.data1\fP
В этом разделе содержатся инициализированные данные, которые вносятся в
образ программы в памяти. Он имеет тип \fBSHT_PROGBITS\fP и атрибуты
\fBSHF_ALLOC\fP и \fBSHF_WRITE\fP.
.TP 
\&\fI.debug\fP
В этом разделе содержится информация для символьной отладки. Формат
содержимого не определён. Этот раздел имеет тип \fBSHT_PROGBITS\fP и не имеет
атрибутов.
.TP 
\&\fI.dtors\fP
В этом разделе содержатся инициализированные указатели функций\-деструкторов
C++. Он имеет тип \fBSHT_PROGBITS\fP и атрибуты \fBSHF_ALLOC\fP и \fBSHF_WRITE\fP.
.TP 
\&\fI.dynamic\fP
В этом разделе содержится информация о динамической компоновке. К атрибутам
раздела будет добавлен бит \fBSHF_ALLOC\fP. В зависимости от процессора может
быть установлен бит \fBSHF_WRITE\fP. Этот раздел имеет тип \fBSHT_DYNAMIC\fP.
.TP 
\&\fI.dynstr\fP
В этом разделе содержатся строки, необходимые для динамической компоновки;
чаще всего это строки, представляющие имена, связанные с элементами таблицы
символов. Этот раздел имеет тип \fBSHT_STRTAB\fP и атрибут \fBSHF_ALLOC\fP.
.TP 
\&\fI.dynsym\fP
В этом разделе содержится таблица символов для динамической компоновки. Этот
раздел имеет тип \fBSHT_DYNSYM\fP и атрибут \fBSHF_ALLOC\fP.
.TP 
\&\fI.fini\fP
В этом разделе содержатся исполняемые инструкции, которые вносятся в код
завершения процесса. При нормальном завершении программы система передаёт
выполнение коду из этого раздела. Этот раздел имеет тип \fBSHT_PROGBITS\fP и
атрибуты \fBSHF_ALLOC\fP и \fBSHF_EXECINSTR\fP.
.TP 
\&\fI.gnu.version\fP
В этом разделе содержится таблица версий символов, массив элементов
\fIElfN_Half\fP. Данный раздел имеет тип \fBSHT_GNU_versym\fP и атрибут
\fBSHF_ALLOC\fP.
.TP 
\&\fI.gnu.version_d\fP
В этом разделе содержатся определения версий символов, таблица структур
\fIElfN_Verdef\fP. Данный раздел имеет тип \fBSHT_GNU_verdef\fP и атрибут
\fBSHF_ALLOC\fP.
.TP 
\&\fI.gnu.version_r\fP
В этом разделе содержатся версии символов необходимых элементов, таблица
структур \fIElfN_Verneed\fP. Данный раздел имеет тип \fBSHT_GNU_versym\fP и
атрибут \fBSHF_ALLOC\fP.
.TP 
\&\fI.got\fP
В этом разделе содержится таблица глобальных перемещений. Он имеет тип
\fBSHT_PROGBITS\fP. Набор используемых атрибутов зависит от процессора.
.TP 
\&\fI.hash\fP
В этом разделе содержится хэш\-таблица символов. Он имеет тип \fBSHT_HASH\fP и
атрибут \fBSHF_ALLOC\fP.
.TP 
\&\fI.init\fP
В этом разделе содержатся исполняемые инструкции, которые вносятся в код
инициализации процесса. Когда программа запускается, система передаёт
выполнение коду из этого раздела до вызова основной программы. Данный раздел
имеет тип \fBSHT_PROGBITS\fP и атрибуты \fBSHF_ALLOC\fP и \fBSHF_EXECINSTR\fP.
.TP 
\&\fI.interp\fP
В этом разделе содержится путь к интерпретатору программы. Если файл имеет
загружаемый сегмент, который включает раздел, то в атрибуты раздела будет
добавлен бит \fBSHF_ALLOC\fP. Иначе этот бит будет обнулён. Данный раздел имеет
тип \fBSHT_PROGBITS\fP.
.TP 
\&\fI.line\fP
В этом разделе содержатся информация о номерах строк для символьной отладки,
которая описывает соответствие между исходным кодом программы и машинным
кодом. Формат содержимого не определён. Данный раздел имеет тип
\fBSHT_PROGBITS\fP и не имеет атрибутов.
.TP 
\&\fI.note\fP
В этом разделе содержатся различные заметки. Он имеет тип \fBSHT_NOTE\fP. Типы
атрибутов атрибутов не используются.
.TP 
\&\fI.note.ABI\-tag\fP
Этот раздел используется для объявления ожидаемой образом ELF среды
выполнения (run\-time) ABI. Здесь может указываться имя операционной системы
и её версии среды выполнения. Данный раздел имеет тип
\fBSHT_NOTE\fP. Используется только атрибут \fBSHF_ALLOC\fP.
.TP 
\&\fI.note.gnu.build\-id\fP
Данный раздел используется для хранения ID, который уникально отождествляет
содержимое образа ELF. Разные файлы с одинаковым ID сборки должны содержать
одинаковое исполняемого содержимое. Подробней смотрите в описании параметра
\fB\-\-build\-id\fP компоновщика GNU (\fBld\fP (1)). Данный раздел имеет тип
\fBSHT_NOTE\fP. Используется только атрибут \fBSHF_ALLOC\fP.
.TP 
\&\fI.note.GNU\-stack\fP
Этот раздел используется в объектных файлах Linux для объявления атрибутов
стека. Данный раздел имеет тип \fBSHT_PROGBITS\fP и единственный атрибут
\fBSHF_EXECINSTR\fP. Он указывает компоновщику GNU на необходимость объектного
файла иметь исполняемый стек.
.TP 
\&\fI.note.openbsd.ident\fP
Обычно, этот раздел содержится а собственных исполняемых файлах OpenBSD для
их идентификации, что используется ядром для пропуска тестирования на
необходимость эмуляции двоичных файлов ELF при загрузке файла.
.TP 
\&\fI.plt\fP
В этом разделе содержится таблица компоновки процедур. Он имеет тип
\fBSHT_PROGBITS\fP. Набор используемых атрибутов зависит от процессора.
.TP 
\&\fI.relИМЯ\fP
В этом разделе содержится информация о перемещениях, описываемая далее. Если
файл имеет загружаемый сегмент, включающий перемещение, то в атрибуты
раздела добавится бит \fBSHF_ALLOC\fP. Иначе этот бит будет обнулён. По
соглашению, «ИМЯ» указывает на раздел, к которому применяются
перемещения. То есть раздел перемещений для \fB.text\fP обычно называется
\&\fB.rel.text\fP. Данный раздел имеет тип \fBSHT_REL\fP.
.TP 
\&\fI.relaNAME\fP
В этом разделе содержится информация о перемещениях, описываемая далее. Если
файл имеет загружаемый сегмент, включающий перемещение, то в атрибуты
раздела добавится бит \fBSHF_ALLOC\fP. Иначе этот бит будет обнулён. По
соглашению, «ИМЯ» указывает на раздел, к которому применяются
перемещения. То есть раздел перемещений для \fB.text\fP обычно называется
\&\fB.rela.text\fP. Данный раздел имеет тип \fBSHT_RELA\fP.
.TP 
\&\fI.rodata\fP
В этом разделе содержатся данные, доступные только для чтения, которые
обычно вносятся в недоступный для записи сегмент образа процесса. Этот
раздел имеет тип \fBSHT_PROGBITS\fP и атрибут \fBSHF_ALLOC\fP.
.TP 
\&\fI.rodata1\fP
В этом разделе содержатся данные, доступные только для чтения, которые
обычно вносятся в недоступный для записи сегмент образа процесса. Этот
раздел имеет тип \fBSHT_PROGBITS\fP и атрибут \fBSHF_ALLOC\fP.
.TP 
\&\fI.shstrtab\fP
В этом разделе содержатся имена разделов. Он имеет тип \fBSHT_STRTAB\fP и не
имеет атрибутов.
.TP 
\&\fI.strtab\fP
В этом разделе содержатся строки, чаще всего представляющие имена, связанные
с элементами таблицы символов. Если файл имеет загружаемый сегмент, который
включает таблицу строк символов, то к разделу атрибутов будет добавлен бит
\fBSHF_ALLOC\fP. Иначе этот бит будет обнулён. Данный раздел имеет тип
\fBSHT_STRTAB\fP.
.TP 
\&\fI.symtab\fP
В этом разделе содержится таблица символов. Если файл имеет загружаемый
сегмент, который включает таблицу символов, то к разделу атрибутов будет
добавлен бит \fBSHF_ALLOC\fP. Иначе этот бит будет обнулён. Данный раздел имеет
тип \fBSHT_SYMTAB\fP.
.TP 
\&\fI.text\fP
.\"
В этом разделе содержится "код (text)", то есть исполняемые инструкции
программы. Он имеет тип \fBSHT_PROGBITS\fP и атрибуты \fBSHF_ALLOC\fP и
\fBSHF_EXECINSTR\fP.
.SS "Таблицы строк и символов"
В разделах с таблицами строк содержатся символьные последовательности,
завершающиеся null, которые обычно называются строками. Объектный файл
использует эти строки для имён символов и разделов. Он ссылается на строку
посредством индекса в разделе таблицы строк. В первом байте с нулевым
индексом задаётся байт null (\(aq\e0\(aq). Подобно этому, для обеспечения
завершения null всех строк последний байт таблицы строк также содержит байт
null.
.PP
В таблице символов объектного файла содержится информация, необходимая для
обнаружения и перемещения определённых в программе символов и ссылок. Индекс
таблицы символов указывает на элемент из этого массива.
.PP
.in +4n
.EX
typedef struct {
    uint32_t      st_name;
    Elf32_Addr    st_value;
    uint32_t      st_size;
    unsigned char st_info;
    unsigned char st_other;
    uint16_t      st_shndx;
} Elf32_Sym;
.EE
.in
.PP
.in +4n
.EX
typedef struct {
    uint32_t      st_name;
    unsigned char st_info;
    unsigned char st_other;
    uint16_t      st_shndx;
    Elf64_Addr    st_value;
    uint64_t      st_size;
} Elf64_Sym;
.EE
.in
.PP
32\-битная и 64\-битная версии имеют одинаковые поля, различен только их
порядок.
.TP  \n[l1_indent]
\fIst_name\fP
В этом поле содержится индекс на элемент в таблице строк символов объектного
файла, которая содержит символьное представление имён символов. Если
значение не равно нулю, то это индекс таблицы строк, по которому
определяется имя символа. Иначе символ не имеет имени.
.TP 
\fIst_value\fP
В этом поле содержится значение соответствующего символа.
.TP 
\fIst_size\fP
Со многими символами связываются определённые размеры. Это поле имеет
значение ноль, если символ не имеет размера или его размер неизвестен.
.TP 
\fIst_info\fP
В этом поле задаётся тип символа и атрибуты привязки:
.RS \n[l1_indent]
.TP  12
\fBSTT_NOTYPE\fP
Тип символа не определён.
.TP 
\fBSTT_OBJECT\fP
Символу соответствует объект данных.
.TP 
\fBSTT_FUNC\fP
Символу соответствует функция или другой исполняемый код.
.TP 
\fBSTT_SECTION\fP
Символу соответствует раздел. Элементы таблицы символов этого типа
существуют, прежде всего, для перемещения и обычно имеют привязки
\fBSTB_LOCAL\fP.
.TP 
\fBSTT_FILE\fP
По соглашению, имя символа назначается согласно имени файла исходного кода
для соответствующего объектного файла. Файловый символ имеет привязки
\fBSTB_LOCAL\fP, его индекс раздела \fBSHN_ABS\fP, и он предваряется другим
символом \fBSTB_LOCAL\fP файла, если он есть.
.TP 
\fBSTT_LOPROC\fP, \fBSTT_HIPROC\fP
Значения из диапазона [\fBSTT_LOPROC\fP, \fBSTT_HIPROC\fP] (включительно)
зарезервированы для процессорно\-ориентированной семантики.
.TP 
\fBSTB_LOCAL\fP
Локальные символы невидимы вне объектного файла, содержащего их
определения. Локальные символы с теми же именами могут существовать в
нескольких файлах не мешая друг другу.
.TP 
\fBSTB_GLOBAL\fP
Глобальные символы видимы во всех объектных файлах после
объединения. Определение глобального символа в одном файле будет разрешать
неопределённую ссылку в другом файле для того же символа.
.TP 
\fBSTB_WEAK\fP
Слабые символы (weak symbols) похожи на глобальные символы, но их
определения имеют меньший приоритет.
.TP 
\fBSTB_LOPROC\fP, \fBSTB_HIPROC\fP
Значения из диапазона [\fBSTB_LOPROC\fP, \fBSTB_HIPROC\fP] (включительно)
зарезервированы для процессорно\-ориентированной семантики.
.RE
.IP
Макросы для упаковки и распаковки полей привязки и типа:
.RS \n[l1_indent]
.TP 
\fBELF32_ST_BIND(\fP\fIinfo\fP\fB)\fP, \fBELF64_ST_BIND(\fP\fIinfo\fP\fB)\fP
Извлекают привязку из значения \fIst_info\fP.
.TP 
\fBELF32_ST_TYPE(\fP\fIinfo\fP\fB)\fP, \fBELF64_ST_TYPE(\fP\fIinfo\fP\fB)\fP
Извлекают тип из значения \fIst_info\fP.
.TP 
\fBELF32_ST_INFO(\fP\fIbind\fP\fB, \fP\fItype\fP\fB)\fP, \fBELF64_ST_INFO(\fP\fIbind\fP\fB, \fP\fItype\fP\fB)\fP
Преобразуют привязку и тип в значение \fIst_info\fP.
.RE
.TP 
\fIst_other\fP
Этим полем определяется видимость символа.
.RS \n[l1_indent]
.TP  16
.PD 0
\fBSTV_DEFAULT\fP
Правила видимости символов по умолчанию. Глобальные и слабые символы
доступны в других модулях; ссылки в локальном модуле могут помещаться
определениями в других модулях.
.TP 
\fBSTV_INTERNAL\fP
Скрытый класс, зависящий от процессора.
.TP 
\fBSTV_HIDDEN\fP
Символ недоступен в других модулях; ссылки в локальном модуле всегда
указывают на локальный символ (то есть, символ не может помещаться
определениями в других модулях).
.TP 
\fBSTV_PROTECTED\fP
Символ доступен в других модулях, то ссылки в локальном модуле всегда
указывают на локальный символ.
.PD
.PP
Эти макросы служат для извлечения типа видимости:
.PP
\fBELF32_ST_VISIBILITY\fP(other) или \fBELF64_ST_VISIBILITY\fP(other)
.RE
.TP 
\fIst_shndx\fP
.\"
Каждый элемент таблицы символов «определён» в отношении к некоторому
разделу. Это поле содержит соответствующий индекс таблицы заголовков
разделов.
.SS "Элементы перемещений (Rel & Rela)"
Перемещение \(em это процесс соединения символьных ссылок с символьными
определениями. Перемещаемые файлы должны иметь информацию, которая описывает
как нужно изменить их содержимое разделов, чтобы позволить исполняемым и
динамическим объектным файлам содержать корректную информацию для образа
процесса программы. Для этого существуют перемещения.
.PP
Перемещаемые структуры, которым не нужна добавка:
.PP
.in +4n
.EX
typedef struct {
    Elf32_Addr r_offset;
    uint32_t   r_info;
} Elf32_Rel;
.EE
.in
.PP
.in +4n
.EX
typedef struct {
    Elf64_Addr r_offset;
    uint64_t   r_info;
} Elf64_Rel;
.EE
.in
.PP
Перемещаемые структуры, которым нужна добавка:
.PP
.in +4n
.EX
typedef struct {
    Elf32_Addr r_offset;
    uint32_t   r_info;
    int32_t    r_addend;
} Elf32_Rela;
.EE
.in
.PP
.in +4n
.EX
typedef struct {
    Elf64_Addr r_offset;
    uint64_t   r_info;
    int64_t    r_addend;
} Elf64_Rela;
.EE
.in
.TP  \n[l1_indent]
\fIr_offset\fP
В этом поле задаётся расположение, по которому применяется действие по
перемещению. Для файла, допускающего перемещения, значением является
байтовое смещение от начала раздела до хранимого элемента, подвергаемого
перемещению. Для исполняемого файла или динамического объекта значением
является виртуальный адрес хранимого элемента, подвергаемого перемещению.
.TP 
\fIr_info\fP
В этом поле указывается индекс таблицы символов с соблюдением того, что
нужно выполнить перемещение и тип применяемого перемещения. Типы перемещений
зависят от архитектуры процессора. Когда в коде есть ссылка на тип
перемещения элемента перемещения или индекс таблицы символов, то имеется в
виду результат применения \fBELF[32|64]_R_TYPE\fP или \fBELF[32|64]_R_SYM\fP,
соответственно, к полю \fIr_info\fP.
.TP 
\fIr_addend\fP
.\"
В этом поле указывается константа\-добавка, используемая для вычисления
значения, хранимого в поле перемещения.
.SS "Динамические метки (Dyn)"
В разделе \fI.dynamic\fP содержится несколько структур, в которых содержится
информация по динамической компоновке. Полем \fId_tag\fP контролируется
интерпретация \fId_un\fP.
.PP
.in +4n
.EX
typedef struct {
    Elf32_Sword    d_tag;
    union {
        Elf32_Word d_val;
        Elf32_Addr d_ptr;
    } d_un;
} Elf32_Dyn;
extern Elf32_Dyn _DYNAMIC[];
.EE
.in
.PP
.in +4n
.EX
typedef struct {
    Elf64_Sxword    d_tag;
    union {
        Elf64_Xword d_val;
        Elf64_Addr  d_ptr;
    } d_un;
} Elf64_Dyn;
extern Elf64_Dyn _DYNAMIC[];
.EE
.in
.TP  \n[l1_indent]
\fId_tag\fP
В этом поле могут содержаться следующие значения:
.RS \n[l1_indent]
.TP  12
\fBDT_NULL\fP
Этим значением помечается конец динамического раздела
.TP 
\fBDT_NEEDED\fP
Смещение в таблице строк на имя необходимой библиотеки
.TP 
\fBDT_PLTRELSZ\fP
Размер в байтах элементов перемещений PLT
.TP 
\fBDT_PLTGOT\fP
Адрес PLT и/или GOT
.TP 
\fBDT_HASH\fP
Адрес хэш\-таблицы символов
.TP 
\fBDT_STRTAB\fP
Адрес таблицы строк
.TP 
\fBDT_SYMTAB\fP
Адрес таблицы символов
.TP 
\fBDT_RELA\fP
Адрес таблицы перемещений Rela
.TP 
\fBDT_RELASZ\fP
Размер в байтах таблицы перемещений Rela
.TP 
\fBDT_RELAENT\fP
Размер в байтах элемента таблицы перемещений Rela
.TP 
\fBDT_STRSZ\fP
Размер в байтах таблицы строк
.TP 
\fBDT_SYMENT\fP
Размер в байтах элемента таблицы строк
.TP 
\fBDT_INIT\fP
Адрес функции инициализации
.TP 
\fBDT_FINI\fP
Адрес функции окончания
.TP 
\fBDT_SONAME\fP
Смещение в таблице строк для имени динамического объекта
.TP 
\fBDT_RPATH\fP
Смещение в таблице строк для пути поиска (устарело)
.TP 
\fBDT_SYMBOLIC\fP
Уведомление для компоновщика, что нужно искать этот динамический объект до
поиска символов в исполняемом файле
.TP 
\fBDT_REL\fP
Адрес таблицы перемещений Rel
.TP 
\fBDT_RELSZ\fP
Размер в байтах таблицы перемещений Rel
.TP 
\fBDT_RELENT\fP
Размер в байтах элемента таблицы Rel
.TP 
\fBDT_PLTREL\fP
Тип элемента перемещения, на который ссылается PLT (Rela или Rel)
.TP 
\fBDT_DEBUG\fP
Не определено, используется для отладки
.TP 
\fBDT_TEXTREL\fP
Отсутствие этого элемента указывает, что перемещения не должны применяться к
сегменту, недоступному на запись
.TP 
\fBDT_JMPREL\fP
Адрес элементов перемещений, связанных исключительно с PLT
.TP 
\fBDT_BIND_NOW\fP
Указать динамическому компоновщику, что нужно обработать все перемещения до
передачи управления исполняемому файлу
.TP 
\fBDT_RUNPATH\fP
Смещение в таблице строк для пути поиска библиотек
.TP 
\fBDT_LOPROC\fP, \fBDT_HIPROC\fP
Значения из диапазона [\fBDT_LOPROC\fP, \fBDT_HIPROC\fP] (включительно)
зарезервированы для процессорно\-ориентированной семантики
.RE
.TP 
\fId_val\fP
В этом поле указываются целые (integer) значения различного смысла.
.TP 
\fId_ptr\fP
В этом поле указываются программные виртуальные адреса. При интерпретации
данных адресов, реальные адреса должны вычисляться на основе оригинального
значения из файла и базового адреса памяти. Файлы не содержат перемещаемых
элементов для местоположения этих адресов.
.TP 
\fI_DYNAMIC\fP
.\" GABI ELF Reference for Note Sections:
.\" http://www.sco.com/developers/gabi/latest/ch5.pheader.html#note_section
.\"
.\" Note that it implies the sizes and alignments of notes depend on the ELF
.\" size (e.g. 32-bit ELFs have three 4-byte words and use 4-byte alignment
.\" while 64-bit ELFs use 8-byte words & alignment), but that is not the case
.\" in the real world.  Notes always have three 4-byte words as can be seen
.\" in the source links below (remember that Elf64_Word is a 32-bit quantity).
.\" glibc:    https://sourceware.org/git/?p=glibc.git;a=blob;f=elf/elf.h;h=9e59b3275917549af0cebe1f2de9ded3b7b10bf2#l1173
.\" binutils: https://sourceware.org/git/?p=binutils-gdb.git;a=blob;f=binutils/readelf.c;h=274ddd17266aef6e4ad1f67af8a13a21500ff2af#l15943
.\" Linux:    https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/elf.h?h=v4.8#n422
.\" Solaris:  https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-18048.html
.\" FreeBSD:  https://svnweb.freebsd.org/base/head/sys/sys/elf_common.h?revision=303677&view=markup#l33
.\" NetBSD:   https://www.netbsd.org/docs/kernel/elf-notes.html
.\" OpenBSD:  https://github.com/openbsd/src/blob/master/sys/sys/exec_elf.h#L533
.\"
Массив, содержащий все динамические структуры в разделе
\&\fI.dynamic\fP. Автоматически заполняется компоновщиком.
.SS "Заметки (Nhdr)"
В заметки ELF можно добавлять произвольную информацию для использования в
системе. В основном, это используется в файлах core (\fIe_type\fP равно
\fBET_CORE\fP), но многие проекты определяют свои собственные наборы
расширений. Например, набор инструментов GNU использует заметки ELF для
передачи информации компоновщика в библиотеку C.
.PP
В разделах заметок содержатся последовательности заметки (смотрите
определение \fIstruct\fP далее). Каждая заметка сопровождается полем имени
(длина определяется в  \fIn_namesz\fP) и полем дескриптора (длина задаётся в
\fIn_descsz\fP) и начинается с адреса, кратного 4 байтам. Оба поля не
определены в структуре из\-за их произвольной длины.
.PP
Пример разбора двух последовательных заметок должен разъяснить их
расположение в памяти:
.PP
.in +4n
.EX
void *memory, *name, *desc;
Elf64_Nhdr *note, *next_note;

/* буфер, указывающий на начало раздела/сегмента */
note = memory;

/* если имя определено, то после него идёт заметка */
name = note\->n_namesz == 0 ? NULL : memory + sizeof(*note);

/* если дескриптор определён, то за ним идёт имя
   (выровненное) */

desc = note\->n_descsz == 0 ? NULL :
       memory + sizeof(*note) + ALIGN_UP(note\->n_namesz, 4);

/* следующая заметка с обоими полями (с выравниванием) */
next_note = memory + sizeof(*note) +
                     ALIGN_UP(note\->n_namesz, 4) +
                     ALIGN_UP(note\->n_descsz, 4);
.EE
.in
.PP
Следует иметь в виду, что интерпретация \fIn_type\fP зависит от пространства
имён, определённого в поле \fIn_namesz\fP field. Если поле \fIn_namesz\fP не
задано (например, равно 0), то есть два набора заметок: один для файлов core
files и другой для всех остальных типов ELF. Если пространство имён
неизвестно, то инструменты, обычно, по умолчанию также используют эти наборы
заметок.
.PP
.in +4n
.EX
typedef struct {
    Elf32_Word n_namesz;
    Elf32_Word n_descsz;
    Elf32_Word n_type;
} Elf32_Nhdr;
.EE
.in
.PP
.in +4n
.EX
typedef struct {
    Elf64_Word n_namesz;
    Elf64_Word n_descsz;
    Elf64_Word n_type;
} Elf64_Nhdr;
.EE
.in
.TP  \n[l1_indent]
\fIn_namesz\fP
Длина имени поля в байтах. Содержимое идёт в памяти сразу за заметкой. Имя
заканчивается null. Например, если имя «GNU», то \fIn_namesz\fP будет равно 4.
.TP 
\fIn_descsz\fP
Длина дескриптора поля в байтах. Содержимое идёт в памяти сразу за именем
поля.
.TP 
\fIn_type\fP
В зависимости от значения имени поля, этот член может содержать следующие
значения:
.RS \n[l1_indent]
.TP  5
\fBФайлы core (e_type = ET_CORE)\fP
Заметки используются всеми файлами core. Их формат определяется ОС или
архитектурой и часто требует плотного взаимодействия ядра, библиотек C и
отладчиков. Они используются при умолчательном пространстве имён (т. е.,
\fIn_namesz\fP равно 0) или когда пространство имён неизвестно.
.RS
.TP  21
.PD 0
\fBNT_PRSTATUS\fP
структура prstatus
.TP 
\fBNT_FPREGSET\fP
структура fpregset
.TP 
\fBNT_PRPSINFO\fP
структура prpsinfo
.TP 
\fBNT_PRXREG\fP
структура prxregset
.TP 
\fBNT_TASKSTRUCT\fP
структура задачи
.TP 
\fBNT_PLATFORM\fP
Строка из sysinfo(SI_PLATFORM)
.TP 
\fBNT_AUXV\fP
массив auxv
.TP 
\fBNT_GWINDOWS\fP
структура gwindows
.TP 
\fBNT_ASRS\fP
структура asrset
.TP 
\fBNT_PSTATUS\fP
структура pstatus
.TP 
\fBNT_PSINFO\fP
структура psinfo
.TP 
\fBNT_PRCRED\fP
структура prcred
.TP 
\fBNT_UTSNAME\fP
структура utsname
.TP 
\fBNT_LWPSTATUS\fP
структура lwpstatus
.TP 
\fBNT_LWPSINFO\fP
структура lwpinfo
.TP 
\fBNT_PRFPXREG\fP
структура fprxregset
.TP 
\fBNT_SIGINFO\fP
siginfo_t (в дальнейшем, размер может увеличиться)
.TP 
\fBNT_FILE\fP
Содержит информацию об отображённых файлах
.TP 
\fBNT_PRXFPREG\fP
user_fxsr_struct
.TP 
\fBNT_PPC_VMX\fP
Регистры PowerPC Altivec/VMX
.TP 
\fBNT_PPC_SPE\fP
Регистры PowerPC SPE/EVR
.TP 
\fBNT_PPC_VSX\fP
Регистры PowerPC VSX
.TP 
\fBNT_386_TLS\fP
слоты TLS в i386  (struct user_desc)
.TP 
\fBNT_386_IOPERM\fP
битовая карта ввода\-вывода в x86 (1=запрещено)
.TP 
\fBNT_X86_XSTATE\fP
расширенное состояние x86, использующее xsave
.TP 
\fBNT_S390_HIGH_GPRS\fP
верхние половинки регистров s390
.TP 
\fBNT_S390_TIMER\fP
регистр таймера s390
.TP 
\fBNT_S390_TODCMP\fP
регистр сравнивателя часов time\-of\-day (TOD) s390
.TP 
\fBNT_S390_TODPREG\fP
программируемый регистр time\-of\-day (TOD) s390
.TP 
\fBNT_S390_CTRS\fP
управляющие регистры s390
.TP 
\fBNT_S390_PREFIX\fP
регистр префикса s390
.TP 
\fBNT_S390_LAST_BREAK\fP
адрес прерывающего события s390
.TP 
\fBNT_S390_SYSTEM_CALL\fP
данные системного вызова перезапуска s390
.TP 
\fBNT_S390_TDB\fP
блок диагностики транзакции s390
.TP 
\fBNT_ARM_VFP\fP
регистры VFP/NEON в ARM
.TP 
\fBNT_ARM_TLS\fP
регистр TLS в ARM
.TP 
\fBNT_ARM_HW_BREAK\fP
регистры аппаратного прерывания в ARM
.TP 
\fBNT_ARM_HW_WATCH\fP
регистры аппаратного слежения в ARM
.TP 
\fBNT_ARM_SYSTEM_CALL\fP
Номер системного вызова ARM
.PD
.RE
.TP 
\fBn_name = GNU\fP
Расширения, используемый инструментами GNU.
.RS
.TP 
\fBNT_GNU_ABI_TAG\fP
Информация ABI операционной системы (OS). Поле дескриптора содержит 4 слова:
.IP
.PD 0
.RS
.IP \(bu 2
слово 0: дескриптор ОС (\fBELF_NOTE_OS_LINUX\fP, \fBELF_NOTE_OS_GNU\fP и так
далее)`
.IP \(bu
слово 1: основной номер версии ABI
.IP \(bu
слово 2: вспомогательный номер версии ABI
.IP \(bu
слово 3: дополнение к вспомогательному номеру версии ABI
.RE
.PD
.TP 
\fBNT_GNU_HWCAP\fP
Синтетическая информация hwcap. Поле дескриптора начинается 2 словами:
.IP
.PD 0
.RS
.IP \(bu 2
слово 0: количество элементов
.IP \(bu
слово 1: битовая маска включённых элементов
.RE
.PD
.IP
Далее следуют элементы произвольной длины и один байт после строки имени
hwcap, заканчивающейся null. В байте определён номер бита, который нужно
тестировать для проверки включённости, (1U << бит) & битовая маска.
.TP 
\fBNT_GNU_BUILD_ID\fP
Уникальный идентификатор сборки, генерируемый GNU \fBld\fP(1), запущенной с
параметром \fB\-\-build\-id\fP. Дескриптор содержит произвольное ненулевое
количество байт.
.TP 
\fBNT_GNU_GOLD_VERSION\fP
В поле дескриптора записывается использованная версия компоновщика GNU Gold.
.RE
.TP 
\fBУмолчательное/неизвестное пространство имён (e_type != ET_CORE)\fP
Они используются при умолчательном пространстве имён (т. е., \fIn_namesz\fP
равно 0) или когда пространство имён неизвестно.
.RS
.TP  21
.PD 0
\fBNT_VERSION\fP
Строка версии неопределённого вида
.TP 
\fBNT_ARCH\fP
Информация об архитектуре
.PD
.RE
.PP
.RE
.SH ЗАМЕЧАНИЯ
.\" OpenBSD
.\" ELF support first appeared in
.\" OpenBSD 1.2,
.\" although not all supported platforms use it as the native
.\" binary file format.
Впервые ELF появился в System V. Формат ELF является утверждённым
стандартом.
.PP
.\" .SH AUTHORS
.\" The original version of this manual page was written by
.\" .An Jeroen Ruigrok van der Werven
.\" .Aq asmodai@FreeBSD.org
.\" with inspiration from BSDi's
.\" .Bsx
.\" .Nm elf
.\" man page.
Расширения для \fIe_phnum\fP, \fIe_shnum\fP и \fIe_strndx\fP соответствующих
расширений Linux. Также они поддерживаются в Sun, BSD и AMD64;
дополнительную информацию смотрите в разделе "СМОТРИТЕ ТАКЖЕ".
.SH "СМОТРИТЕ ТАКЖЕ"
\fBas\fP(1), \fBelfedit\fP(1), \fBgdb\fP(1), \fBld\fP(1), \fBnm\fP(1), \fBobjdump\fP(1),
\fBpatchelf\fP(1), \fBreadelf\fP(1), \fBsize\fP(1), \fBstrings\fP(1), \fBstrip\fP(1),
\fBexecve\fP(2), \fBdl_iterate_phdr\fP(3), \fBcore\fP(5), \fBld.so\fP(8)
.PP
Hewlett\-Packard, \fIФормат объектных файлов Elf\-64\fP.
.PP
Santa Cruz Operation, \fIДвоичный интерфейс приложений System V\fP.
.PP
UNIX System Laboratories, «Объектные файлы», \fIФормат исполняемых и
компонуемых файлов (ELF)\fP.
.PP
Sun Microsystems, \fIРуководстве по компоновщику и библиотекам\fP (\fILinker and
Libraries Guide\fP).
.PP
черновик ABI AMD64, \fIДополнение к двоичному интерфейсу приложений System V
процессорной архитектуры AMD64\fP (\fISystem V Application Binary Interface
AMD64 Architecture Processor Supplement\fP).
.PP
