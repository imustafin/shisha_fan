.\" -*- mode: troff; coding: UTF-8 -*-
.\" Copyright (C) 1995, Thomas K. Dyas <tdyas@eden.rutgers.edu>
.\" and Copyright (C) 2013, 2019, Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"
.\" Created   1995-08-06 Thomas K. Dyas <tdyas@eden.rutgers.edu>
.\" Modified  2000-07-01 aeb
.\" Modified  2002-07-23 aeb
.\" Modified, 27 May 2004, Michael Kerrisk <mtk.manpages@gmail.com>
.\"     Added notes on capability requirements
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH SETFSUID 2 2019\-05\-09 Linux "Руководство программиста Linux"
.SH ИМЯ
setfsuid \- устанавливает идентификатор пользователя для доступа к файловой
системе
.SH ОБЗОР
\fB#include <sys/fsuid.h>\fP
.PP
\fBint setfsuid(uid_t \fP\fIfsuid\fP\fB);\fP
.SH ОПИСАНИЕ
В Linux у процесса есть идентификатор пользователя файловой системы и
эффективный (effective) идентификатор пользователя. Идентификатор
пользователя файловой системы (есть только в Linux) используется при
проверки прав доступа к объектам файловой системы, а эффективный
идентификатор пользователя используется для проверки прав доступа к другим
различным объектам (смотрите \fBcredentials\fP(7)).
.PP
Обычно, значение идентификатора пользователя файловой системы процесса
совпадает со значением эффективного идентификатора пользователя. Более того,
при изменении идентификатора эффективного идентификатора пользователя ядро
также изменяет и идентификатор пользователя файловой системы на новое
значение идентификатора эффективного идентификатора пользователя.Процесс
может изменить значение своего идентификатора пользователя файловой системы
на отличное от эффективного идентификатора пользователя с помощью
\fBsetfsuid\fP() указав его в параметре \fIfsuid\fP.
.PP
Вызовы \fBsetfsuid\fP() и \fBsetfsgid\fP(2) в явном виде, обычно (теперь),
используются только в программах Linux типа NFS\-сервера, которым требуется
изменить идентификатор пользователя и группы для доступа к файлам без
изменения действительного и эффективного идентификаторов пользователя и
группы. Изменение обычного идентификатора пользователя для программы типа
NFS\-сервера — это нарушение безопасности (раньше), приводящее к возможному
получению нежелательных сигналов от других групп (однако это было в прошлом,
читайте далее).
.PP
Вызов \fBsetfsuid\fP() выполняется корректно, только если он был вызван
суперпользователем или, если \fIfsuid\fP совпадает с действительным,
эффективным и сохранённым идентификатором пользователя или равен текущему
значению идентификатора пользователя файловой системы вызывающего.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
При успешном выполнении или при ошибке данный вызов возвращает предыдущий
идентификатор пользователя файловой системы вызвавшего.
.SH ВЕРСИИ
.\" This system call is present since Linux 1.1.44
.\" and in libc since libc 4.7.6.
Данный системный вызов доступен в Linux начиная с версии 1.2.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
Вызов \fBsetfsuid\fP() есть только в Linux и не должен использоваться в
переносимых программах.
.SH ЗАМЕЧАНИЯ
На момент появления данного системного вызова один процесс мог послать
сигнал другому процессу с тем же эффективным идентификатором
пользователя. Это означает, что если привилегированный процесс изменит свой
эффективный идентификатор пользователя с целью проверки доступа к файлу, то
он сможет стать уязвимым к приёму сигналов, посланных (непривилегированным)
процессом с тем же идентификатором пользователя. Атрибут идентификатора
пользователя файловой системы был добавлен как раз для того, чтобы позволить
процессу изменить свой идентификатор пользователя для проверки доступа к
файлу не боясь стать уязвимым к приёму нежелаемых сигналов. Начиная с Linux
2.0, обработка прав на сигналы была изменена (смотрите \fBkill\fP(2)), что
позволило процессу изменять свой эффективный идентификатор пользователя без
боязни стать уязвимым к приёму нежелаемых сигналов от других процессов.Таким
образом, сейчас системный вызов \fBsetfsuid\fP() уже не нужен и не должен
использоваться в новых приложениях (как и \fBsetfsgid\fP(2)).
.PP
Первоначальная версия системного вызова \fBsetfsuid\fP() в Linux поддерживала
только 16\-битные идентификаторы пользователя. Позднее в Linux 2.4 был
добавлен вызов \fBsetfsuid32\fP(), поддерживающий 32\-битные идентификаторы. В
glibc обёрточная функция \fBsetfsuid\fP() работает одинаково вне зависимости от
версий ядра.
.SS "Отличия между библиотекой C и ядром"
В glibc 2.15 и старее, если обёрточная функция этого системного вызова
определяет, что аргумент невозможно передать ядру без обрезания целого (так
как ядро старое и не поддерживает 32\-битные ID пользователя), то она
возвращает \-1 и присваивает \fIerrno\fP значение \fBEINVAL\fP не пытаясь выполнить
системный вызов.
.SH ДЕФЕКТЫ
Вызывающему не возвращается никаких ошибок, и факт того, что успешном или не
успешном выполнении возвращается одинаковое значение, делает невозможным
напрямую определить как завершился вызов. Вместо этого, вызывающий должен
получить значение из ещё одного вызова — \fIsetfsuid(\-1)\fP (который всегда
завершается с ошибкой), чтобы определить, изменил ли предыдущий вызов
\fBsetfsuid\fP() идентификатор пользователя файловой системы. По крайней мере,
должно быть получено значение \fBEPERM\fP, если вызов завершится с ошибкой (так
как у вызывающего нет мандата \fBCAP_SETUID\fP).
.SH "СМОТРИТЕ ТАКЖЕ"
\fBkill\fP(2), \fBsetfsgid\fP(2), \fBcapabilities\fP(7), \fBcredentials\fP(7)
