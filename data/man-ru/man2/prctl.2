.\" -*- mode: troff; coding: UTF-8 -*-
.\" Copyright (C) 1998 Andries Brouwer (aeb@cwi.nl)
.\" and Copyright (C) 2002, 2006, 2008, 2012, 2013 Michael Kerrisk <mtk.manpages@gmail.com>
.\" and Copyright Guillem Jover <guillem@hadrons.org>
.\" and Copyright (C) 2014 Dave Hansen / Intel
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"
.\" Modified Thu Nov 11 04:19:42 MET 1999, aeb: added PR_GET_PDEATHSIG
.\" Modified 27 Jun 02, Michael Kerrisk
.\" 	Added PR_SET_DUMPABLE, PR_GET_DUMPABLE,
.\"	PR_SET_KEEPCAPS, PR_GET_KEEPCAPS
.\" Modified 2006-08-30 Guillem Jover <guillem@hadrons.org>
.\"	Updated Linux versions where the options where introduced.
.\"	Added PR_SET_TIMING, PR_GET_TIMING, PR_SET_NAME, PR_GET_NAME,
.\"	PR_SET_UNALIGN, PR_GET_UNALIGN, PR_SET_FPEMU, PR_GET_FPEMU,
.\"	PR_SET_FPEXC, PR_GET_FPEXC
.\" 2008-04-29 Serge Hallyn, Document PR_CAPBSET_READ and PR_CAPBSET_DROP
.\" 2008-06-13 Erik Bosman, <ejbosman@cs.vu.nl>
.\"     Document PR_GET_TSC and PR_SET_TSC.
.\" 2008-06-15 mtk, Document PR_SET_SECCOMP, PR_GET_SECCOMP
.\" 2009-10-03 Andi Kleen, document PR_MCE_KILL
.\" 2012-04 Cyrill Gorcunov, Document PR_SET_MM
.\" 2012-04-25 Michael Kerrisk, Document PR_TASK_PERF_EVENTS_DISABLE and
.\"				PR_TASK_PERF_EVENTS_ENABLE
.\" 2012-09-20 Kees Cook, update PR_SET_SECCOMP for mode 2
.\" 2012-09-20 Kees Cook, document PR_SET_NO_NEW_PRIVS, PR_GET_NO_NEW_PRIVS
.\" 2012-10-25 Michael Kerrisk, Document PR_SET_TIMERSLACK and
.\"                             PR_GET_TIMERSLACK
.\" 2013-01-10 Kees Cook, document PR_SET_PTRACER
.\" 2012-02-04 Michael Kerrisk, document PR_{SET,GET}_CHILD_SUBREAPER
.\" 2014-11-10 Dave Hansen, document PR_MPX_{EN,DIS}ABLE_MANAGEMENT
.\"
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH PRCTL 2 2019\-08\-02 Linux "Руководство программиста Linux"
.SH ИМЯ
prctl \- операции над процессом
.SH ОБЗОР
.nf
\fB#include <sys/prctl.h>\fP
.PP
\fBint prctl(int \fP\fIoption\fP\fB, unsigned long \fP\fIarg2\fP\fB, unsigned long \fP\fIarg3\fP\fB,\fP
\fB          unsigned long \fP\fIarg4\fP\fB, unsigned long \fP\fIarg5\fP\fB);\fP
.fi
.SH ОПИСАНИЕ
.\"
Первый аргумент \fBprctl\fP() задаёт тип операции (типы определены в
\fI<linux/prctl.h>\fP, значения остальных аргументов зависят от
указываемого типа. Первый аргумент может принимать следующие значения:
.TP 
\fBPR_CAP_AMBIENT\fP (начиная с Linux 4.3)
.\" commit 58319057b7847667f0c9585b9de0e8932b0fdb08
Читает или изменяет наружный набор мандатов вызывающей нити согласно
значению \fIarg2\fP, которое должно быть одним из следующих:
.RS
.\"
.TP 
\fBPR_CAP_AMBIENT_RAISE\fP
Мандат, указанный в \fIarg3\fP, добавляется в наружный набор. Указанный мандат
уже должен присутствовать в разрешающем и наследуемом наборе. Эта операция
неприменима, если установлен бит безопасности
\fBSECBIT_NO_CAP_AMBIENT_RAISE\fP.
.TP 
\fBPR_CAP_AMBIENT_LOWER\fP
Мандат, указанный в \fIarg3\fP, удаляется из наружного набора.
.TP 
\fBPR_CAP_AMBIENT_IS_SET\fP
Вызов \fBprctl\fP() возвращает 1, если мандат в \fIarg3\fP присутствует в наружном
наборе и 0, если нет.
.TP 
\fBPR_CAP_AMBIENT_CLEAR_ALL\fP
Все мандаты будут удалены из наружного набора. Для этой операции требуется
указать в \fIarg3\fP значение 0.
.RE
.IP
Во всех перечисленных выше операциях значения \fIarg4\fP и \fIarg5\fP должны быть
равны 0.
.IP
Интерфейсы высокого уровня, построенные поверх описанных выше операций,
предоставляются в библиотеке \fBlibcap\fP(3) под именами \fBcap_get_ambient\fP(3),
\fBcap_set_ambient\fP(3) и \fBcap_reset_ambient\fP(3).
.TP 
\fBPR_CAPBSET_READ\fP (начиная с Linux 2.6.25)
Возвращает 1 (как результат функции), если мандат, указанный в \fIarg2\fP, есть
в списке мандатов вызывающей нити (capability bounding set), или 0, если
нет. Константы мандатов определены в
\fI<linux/capability.h>\fP. Значениями списка мандатов определяется,
может ли процесс получить мандат через установку набора файловых прав при
последующем вызове \fBexecve\fP(2).
.IP
Если мандат, указанный в \fIarg2\fP, некорректен, то вызов завершится с ошибкой
\fBEINVAL\fP.
.IP
Интерфейс высокого уровня, построенный поверх описанной выше операции,
предоставляется в библиотеке \fBlibcap\fP() под именем \fBcap_get_bound\fP(3).
.TP 
\fBPR_CAPBSET_DROP\fP (начиная с Linux 2.6.25)
Если вызывающая нить имеет мандат \fBCAP_SETPCAP\fP в своём пользовательском
пространстве имён, то мандат, указанный в \fIarg2\fP, удаляется из списка
мандатов вызывающей нити. Любой потомок вызывающей нити унаследует новый
сокращённый список мандатов.
.IP
Вызов завершается с ошибками: \fBEPERM\fP, если вызывающая нить не имеет
мандата \fBCAP_SETPCAP\fP; \fBEINVAL\fP, если в \fIarg2\fP указан недопустимый
мандат; \fBEINVAL\fP, если файловые мандаты не включены в ядре, в этом случае
списки мандатов не поддерживаются.
.IP
Интерфейс высокого уровня, построенный поверх описанной выше операции,
предоставляется в библиотеке \fBlibcap\fP() под именем \fBcap_drop_bound\fP(3).
.TP 
\fBPR_SET_CHILD_SUBREAPER\fP (начиная с Linux 3.4)
.\" commit ebec18a6d3aa1e7d84aab16225e87fd25170ec2b
Если значение \fIarg2\fP не равно 0, то в вызвавшем процессе устанавливается
атрибут «сборщика потомков» (child subreaper); если значение \fIarg2\fP равно
0, то атрибут удаляется.
.IP
Сборщик потомков выполняет функцию \fBinit\fP(1) для своих потомков. При
завершении осиротевшего процесса (т. е. прямой предок уже завершил
выполнение), его родителем станет ближайший действующий
сборщик\-предок. После этого вызов \fBgetppid\fP() в осиротевшем процессе будет
возвращать PID процесса\-сборщика, и когда осиротевший процесс завершит
работу, сборщик получит сигнал \fBSIGCHLD\fP и сможет запустить \fBwait\fP(2) для
получения состояния завершения потомка.
.IP
Установка атрибута «сборщика потомков» не наследуется потомками,
создаваемыми \fBfork\fP(2) и \fBclone\fP(2). Данное значение сохраняется после
\fBexecve\fP(2).
.IP
Назначение процесса\-сборщика полезно в инфраструктуре управления сеансами,
где иерархическая группа процессов управляется процессом\-сборщиком, которому
нужно сообщать, когда один из процессов — например, служба, выполнившая
двойное создание (fork) — завершается (возможно для того, чтобы её можно
было перезапустить). Некоторые инфраструктуры \fBinit\fP(1) (например,
\fBsystemd\fP(1)) используют a процесс\-сборщик для этих целей.
.TP 
\fBPR_GET_CHILD_SUBREAPER\fP (начиная с Linux 3.4)
Возвращает значение атрибута «сборщика потомков» вызывающего в расположение,
указанное \fI(int\ *) arg2\fP.
.TP 
\fBPR_SET_DUMPABLE\fP (начиная с Linux 2.3.20)
Установить состояние флага «дампа», определяющего создание файла core
вызывающего процесса после доставки сигнала, чьё поведение по умолчанию
вызывает создание файла core.
.IP
.\" commit abf75a5033d4da7b8a7e92321d74021d1fcfb502
.\" See http://marc.theaimsgroup.com/?l=linux-kernel&m=115270289030630&w=2
.\" Subject:    Fix prctl privilege escalation (CVE-2006-2451)
.\" From:       Marcel Holtmann <marcel () holtmann ! org>
.\" Date:       2006-07-12 11:12:00
В ядрах по 2.6.12 включительно, значение \fIarg2\fP должно быть равно 0
(\fBSUID_DUMP_DISABLE\fP, от процесса не остаётся дампа) или 1
(\fBSUID_DUMP_USER\fP, после процесса остаётся дамп). Между ядрами 2.6.13 и
2.6.17, также было разрешено значение 2, означающее что от любого
исполняемого файла, обычно дампа не остаётся, но суперпользователь может это
сделать; для улучшения безопасности эта возможность была удалена (смотрите
также описание \fI/proc/sys/fs/\:suid_dumpable\fP в \fBproc\fP(5)).
.IP
.\" See kernel/cred.c::commit_creds() (Linux 3.18 sources)
Обычно, значение этого флага равно 1. Однако, оно сбрасывается в текущее
значение, содержащееся в файле \fI/proc/sys/fs/\:suid_dumpable\fP (которое по
умолчанию равно 0), в следующих случаях:
.RS
.IP * 3
Изменён эффективный идентификатор пользователя или группы процесса.
.IP *
Изменён процессный идентификатор пользователя или группы файловой системы
(смотрите \fBcredentials\fP(7)).
.IP *
Процесс выполняет (\fBexecve\fP(2)) программу с установленным битом set\-user\-ID
или set\-group\-ID, что приводит к изменению идентификатора эффективного
пользователя или эффективной группы.
.IP *
.\" See kernel/cred.c::commit_creds()
.\" Also certain namespace operations;
Процесс выполняет (\fBexecve\fP(2)) программу, которая имеет файловые мандаты
(смотрите \fBcapabilities\fP(7)), но только если полученные разрешенные мандаты
превосходят уже разрешенные для процесса.
.RE
.IP
Процессы, для которых невозможен дамп, нельзя присоединить через операцию
\fBptrace\fP2() \fBPTRACE_ATTACH\fP; подробности смотрите в \fBptrace\fP(2).
.IP
Если для процесса невозможен дамп, то на владение файлами в каталоге
процесса \fI/proc/[pid]\fP действуют правила, описанные в \fBproc\fP(5).
.TP 
\fBPR_GET_DUMPABLE\fP (начиная с Linux 2.3.20)
.\" Since Linux 2.6.13, the dumpable flag can have the value 2,
.\" but in 2.6.13 PR_GET_DUMPABLE simply returns 1 if the dumpable
.\" flags has a nonzero value.  This was fixed in 2.6.14.
Возвращает (как результат функции) текущее состояние флага дампа вызывающего
процесса.
.TP 
\fBPR_SET_ENDIAN\fP (начиная с Linux 2.6.18, только для PowerPC)
.\" Respectively 0, 1, 2
Устанавливает порядок байт вызывающего процесса равным значению \fIarg2\fP,
которое может быть одним из: \fBPR_ENDIAN_BIG\fP, \fBPR_ENDIAN_LITTLE\fP или
\fBPR_ENDIAN_PPC_LITTLE\fP (для PowerPC псевдо обратный порядок (pseudo little
endian)).
.TP 
\fBPR_GET_ENDIAN\fP (начиная с Linux 2.6.18, только для PowerPC)
Записывает значение порядка байт вызывающего процесса по адресу, указанному
в \fI(int\ *) arg2\fP.
.TP 
\fBPR_SET_FP_MODE\fP (начиная с Linux 4.0, только на MIPS)
.\" commit 9791554b45a2acc28247f66a5fd5bbc212a6b8c8
На архитектуре MIPS код пользовательского пространства можно собирать
используя ABI, который позволяет компоновку с кодом, имеющем более
ограничительные требования для плавающей запятой (FP). Например, код
пользовательского пространства может собираться для цели O32 FPXX ABI и
компоноваться с кодом, собранным с одним из более ограничительных FP32 или
FP64 ABI. При этом требование всего процесса устанавливается в более
ограничительный режим плавающей запятой.
.IP
Так как ядро не знает в каком режиме должен запускаться процесс и
ограничения могут измениться во время работы процесса, создана операция
\fBPR_SET_FP_MODE\fP, позволяющая контролировать режим плавающей запятой из
пользовательского пространства.
.IP
.\" https://dmz-portal.mips.com/wiki/MIPS_O32_ABI_-_FR0_and_FR1_Interlinking
В аргументе \fI(unsigned int) arg2\fP указывается битовая маска, описывающая
используемый режим плавающей запятой:
.RS
.TP 
\fBPR_FP_MODE_FR\fP
Если это бит \fIсброшен\fP (так называемый режим \fBFR=0\fP или \fBFR0\fP), то ширина
32 регистров плавающей запятой равна 32, а 64\-битные регистры представляются
в виде пары регистров (с чётными и нечётными номерами; регистры с чётными
номерами содержат 32 младших бита, а с нечётными номерами 32 старших бита).
.IP
Если этот бит \fIустановлен\fP (есть поддержка в оборудовании), то ширина 32
регистров плавающей запятой равна 64 (так называемый режим \fBFR=1\fP или
\fBFR1\fP). Заметим, что современные реализации MIPS (MIPS R6 и новее)
поддерживают только режим \fBFR=1\fP.
.IP
.IP
Приложения, использующие O32 FP32 ABI, могут работать только когда этот бит
\fIсброшен\fP (\fBFR=0\fP; или они могут использоваться с включённым FRE, смотрите
ниже). Приложения, использующие O32 FP64 ABI (и O32 FP64A ABI, существующий
для предоставления возможности работы с существующим кодом FP32; смотрите
ниже), могут работать только когда этот бит \fIустановлен\fP
(\fBFR=1\fP). Приложения, использующие O32 FPXX ABI, могут работать и с \fBFR=0\fP
и с \fBFR=1\fP.
.TP 
\fBPR_FP_MODE_FRE\fP
Включает эмуляцию 32\-битного режима плавающей запятой. Когда этот режим
включён, эмуляция 32\-битных операций с плавающей запятой выполняется
генерацией исключения на каждую инструкцию, использующую 32\-битный формат, и
ядро обрабатывает инструкцию программно (проблема заключается в
несоответствии обработке регистров с нечётными номерами, которые содержатся
в 32 старших битах 64\-битных регистров с чётными номерами при режиме \fBFR=0\fP
и в 32 младших битах 64\-битах регистров с нечётными номерами при режиме
\fBFR=1\fP). При включении этого бита необходимо, чтобы код с O32 FP32 ABI
работал с кодом O32 FPXX или O32 FP64A ABI (для которого требуется режим
\fBFR=1\fP FPU) или когда он выполняется на новой аппаратуре (MIPS R6 и новее),
в которой нет поддержки режима \fBFR=0\fP, когда используется двоичный файл с
FP32 ABI.
.IP
Заметим, что этот режим приобретает смысл только, если FPU в 64\-битном
режиме (\fBFR=1\fP).
.IP
Также заметим, что использование эмуляции по определению уменьшает
производительность и её нужно, по возможности, избегать.
.RE
.IP
В N32/N64 ABI всегда используется 64\-битный режим плавающей запятой, поэтому
эмуляция FPU не требуется и FPU всегда работает в режиме \fBFR=1\fP.
.IP
Данный параметр, в основном, предназначен для динамического компоновщика
(\fBld.so\fP(8)).
.IP
Аргументы \fIarg3\fP, \fIarg4\fP и \fIarg5\fP игнорируются.
.TP 
\fBPR_GET_FP_MODE\fP (начиная с Linux 4.0, только на MIPS)
Возвращает текущий режим плавающей запятой (смотрите описание
\fBPR_SET_FP_MODE\fP).
.IP
При успешном выполнении возвращается битовая маска, представляющая текущий
режим плавающей запятой.
.IP
Аргументы \fIarg2\fP, \fIarg3\fP, \fIarg4\fP и \fIarg5\fP игнорируются.
.TP 
\fBPR_SET_FPEMU\fP (начиная с Linux 2.4.18, 2.5.9, только для ia64)
Устанавливает значение управляющих эмуляцией плавающей точки бит равным
значению \fIarg2\fP. Для негласной (silently) эмуляции операций с плавающей
точкой передайте \fBPR_FPEMU_NOPRINT\fP; при указании \fBPR_FPEMU_SIGFPE\fP
операции с плавающей точкой не эмулируются, а посылается сигнал \fBSIGFPE\fP.
.TP 
\fBPR_GET_FPEMU\fP (начиная с Linux 2.4.18, 2.5.9, только для ia64)
Записывает значение управляющих бит эмуляции плавающей точки по адресу,
указанному в \fI(int\ *) arg2\fP.
.TP 
\fBPR_SET_FPEXC\fP (начиная с Linux 2.4.21, 2.5.32, только для PowerPC)
Устанавливает режим исключений плавающей точки равным \fIarg2\fP. Значение
\fBPR_FP_EXC_SW_ENABLE\fP включает использование FPEXC для исключений плавающей
точки, \fBPR_FP_EXC_DIV\fP \(em исключение деления на ноль, \fBPR_FP_EXC_OVF\fP
\(em исключение переполнения, \fBPR_FP_EXC_UND\fP \(em исключение исчерпания,
\fBPR_FP_EXC_RES\fP \(em исключение неточного результата, \fBPR_FP_EXC_INV\fP \(em
исключение недопустимой операции, \fBPR_FP_EXC_DISABLED\fP отключает исключения
плавающей точки, \fBPR_FP_EXC_NONRECOV\fP включает режим асинхронного
невосстанавливаемого исключения, \fBPR_FP_EXC_ASYNC\fP включает режим
асинхронного восстанавливаемого исключения, \fBPR_FP_EXC_PRECISE\fP включает
режим исключения точности.
.TP 
\fBPR_GET_FPEXC\fP (начиная с Linux 2.4.21, 2.5.32, только для PowerPC)
Записывает значение режима исключений плавающей точки по адресу, указанному
в \fI(int\ *) arg2\fP.
.TP 
\fBPR_SET_KEEPCAPS\fP (начиная с Linux 2.2.18)
Устанавливает флаг вызывающей нити «оставить мандаты». Этот флаг описан в
\fBcapabilities\fP(7). Значение \fIarg2\fP должно быть или 0 (сбросить флаг) или 1
(установить флаг). Значение флага «оставить мандаты» будет сброшено в 0 при
последующих вызовах \fBexecve\fP(2).
.TP 
\fBPR_GET_KEEPCAPS\fP (начиная с Linux 2.2.18)
Возвращает (как результат функции) текущее состояние флага «оставить
мандаты» вызывающей нити. Описание флага смотрите в \fBcapabilities\fP(7).
.TP 
\fBPR_MCE_KILL\fP (начиная с Linux 2.6.32)
Устанавливает политику удаления (kill) при обнаружении повреждения памяти
машинной проверкой для вызывающей нити. Если значение \fIarg\fP равно
\fBPR_MCE_KILL_CLEAR\fP, то политика удаления (kill) сбрасывается и
используется системная установка по умолчанию. (Значение системной установки
по умолчанию определено в \fI/proc/sys/vm/memory_failure_early_kill\fP;
смотрите \fBproc\fP(5).) Значение \fIarg2\fP, равное \fBPR_MCE_KILL_SET\fP, указывает
использовать политику удаления, заданную в нити. В этом случае значение
\fIarg3\fP определяет политику: \fIраннее удаление\fP (\fBPR_MCE_KILL_EARLY\fP),
\fIпозднее удаление\fP (\fBPR_MCE_KILL_LATE\fP) или системная установка по
умолчанию (\fBPR_MCE_KILL_DEFAULT\fP). При раннем удалении нить получает сигнал
\fBSIGBUS\fP сразу же при аппаратном обнаружении повреждения памяти в её
адресном пространстве. В режиме позднего удаления процесс будет удалён
только когда обратится к повреждённой странице. Более подробную информацию о
сигнале \fBSIGBUS\fP смотрите в \fIsigaction(2)\fP. Политика наследуется
потомками. Значения остальных неиспользуемых аргументов \fBprctl\fP() должны
быть равны нулю для совместимости в будущем.
.TP 
\fBPR_MCE_KILL_GET\fP (начиная с Linux 2.6.32)
Возвращает значение политики удаления при машинной проверке для текущего
процесса. Значения всех неиспользуемых аргументов \fBprctl\fP() должны быть
равны нулю.
.TP 
\fBPR_SET_MM\fP (начиная с Linux 3.3)
.\" commit 028ee4be34a09a6d48bdf30ab991ae933a7bc036
Изменяет определённые поля дескриптора карты памяти ядра вызывающего
процесса. Обычно, значения этих полей задаются ядром или динамическим
загрузчиком (подробней смотрите \fBld.so\fP(8)), и обычные приложения не должны
использовать эту возможность. Однако, есть случаи (самоизменяющиеся
программы), где для программы может оказаться полезным изменение своей карты
памяти.
.IP
Вызывающий процесс должен иметь мандат \fBCAP_SYS_RESOURCE\fP. Значения
аргумента \fIarg2\fP описаны далее, а в \fIarg3\fP задаётся новое
значение.Аргументы, \fIarg4\fP и \fIarg5\fP, если не используются, должны быть
равно нулю.
.IP
.\" commit 52b3694157e3aa6df871e283115652ec6f2d31e0
До Linux 3.10 эта возможность доступна только, если ядро собрано с
параметром \fBCONFIG_CHECKPOINT_RESTORE\fP.
.RS
.TP 
\fBPR_SET_MM_START_CODE\fP
Устанавливает адрес памяти, выше которого располагается код программы,
который может выполняться. Соответствующая область памяти должна быть
доступна на чтение и выполнение, но не на запись или быть общедоступной
(подробности смотрите в \fBmprotect\fP(2) и \fBmmap\fP(2)).
.TP 
\fBPR_SET_MM_END_CODE\fP
Устанавливает адрес памяти, ниже которого располагается код программы,
который может выполняться. Соответствующая область памяти должна быть
доступна на чтение и выполнение, но не на запись или быть общедоступной.
.TP 
\fBPR_SET_MM_START_DATA\fP
Устанавливает адрес памяти, выше которого располагаются инициализированные и
не инициализированные (bss) данные. Соответствующая область памяти должна
быть доступна на чтение и запись, но не на выполнение или быть в общем
доступе.
.TP 
\fBPR_SET_MM_END_DATA\fP
Устанавливает адрес памяти, ниже которого располагаются инициализированные и
не инициализированные (bss) данные. Соответствующая область памяти должна
быть доступна на чтение и запись, но не на выполнение или быть в общем
доступе.
.TP 
\fBPR_SET_MM_START_STACK\fP
Устанавливает начальный адрес стека. Соответствующая область памяти должна
быть доступна на чтение и запись.
.TP 
\fBPR_SET_MM_START_BRK\fP
Устанавливает адрес памяти, выше которого можно расширять программную кучу с
помощью вызова \fBbrk\fP(2). Адрес должен быть больше конечного адреса текущего
программного сегмента данных. Также, суммарный размер полученной кучи и
сегмента данных не может превышать ограничитель ресурса \fBRLIMIT_DATA\fP
(смотрите \fBsetrlimit\fP(2)).
.TP 
\fBPR_SET_MM_BRK\fP
Устанавливает текущее значение \fBbrk\fP(2). Требования к адресу те же, что и в
параметре \fBPR_SET_MM_START_BRK\fP.
.PP
.\" commit fe8c7f5cbf91124987106faa3bdf0c8b955c4cf7
Начиная с Linux 3.5 доступны следующие параметры:
.TP 
\fBPR_SET_MM_ARG_START\fP
Задаёт адрес, выше которого размещена командная строка программы.
.TP 
\fBPR_SET_MM_ARG_END\fP
Задаёт адрес, ниже которого размещена командная строка программы.
.TP 
\fBPR_SET_MM_ENV_START\fP
Задаёт адрес, выше которого размещено окружение программы.
.TP 
\fBPR_SET_MM_ENV_END\fP
Задаёт адрес, ниже которого размещено окружение программы.
.IP
Адрес, передаваемый с \fBPR_SET_MM_ARG_START\fP, \fBPR_SET_MM_ARG_END\fP,
\fBPR_SET_MM_ENV_START\fP и \fBPR_SET_MM_ENV_END\fP, должен принадлежать области
стека процесса. То есть, соответствующая память должна быть доступна на
чтение, запись и (в зависимости от настройки ядра) у неё должен быть
установлен атрибут \fBMAP_GROWSDOWN\fP (смотрите \fBmmap\fP(2)).
.TP 
\fBPR_SET_MM_AUXV\fP
Задаёт новый вспомогательный вектор (auxiliary vector). В аргументе \fIarg3\fP
должен передаваться адрес вектора. В аргументе \fIarg4\fP — размер вектора.
.TP 
\fBPR_SET_MM_EXE_FILE\fP
.\" commit b32dfe377102ce668775f8b6b1461f7ad428f8b6
Заменяет символьную ссылку \fI/proc/pid/exe\fP новой, указывающей на новый
исполняемый файл, задаваемый файловым дескриптором в аргументе
\fIarg3\fP. Файловый дескриптор должен быть получен с помощью обычного вызова
\fBopen\fP(2).
.IP
Для изменения символьной ссылки необходимо отключить (unmap) все
существующие исполняемые области памяти, включая созданные самим ядром
(например, ядро, обычно, создаёт, как минимум, исполняемую область памяти
для раздела ELF \fI.text\fP).
.IP
.\" commit 3fb4afd9a504c2386b8435028d43283216bf588e
В Linux 4.9 и старее операцию \fBPR_SET_MM_EXE_FILE\fP можно выполнить только
один раз за время существования процесса; повторная попытка выполнения
приводит к ошибке \fBEPERM\fP. Это ограничение было введено по причинам
безопасности, которые впоследствии стали излишними, и ограничение было
удалено в Linux 4.10, так как некоторым приложениям пользовательского
пространства требуется выполнять эту операцию более одного раза.
.PP
.\" commit f606b77f1a9e362451aca8f81d8f36a3a112139e
Начиная с Linux 3.18 доступны следующие параметры:
.TP 
\fBPR_SET_MM_MAP\fP
Предоставляет однократный доступ ко всем адресам, переданным в \fIstruct
prctl_mm_map\fP (определена в \fI<linux/prctl.h>\fP). В аргументе \fIarg4\fP
должен указываться размер структуры.
.IP
Эта возможность доступна только, если ядро собрано с параметром
\fBCONFIG_CHECKPOINT_RESTORE\fP.
.TP 
\fBPR_SET_MM_MAP_SIZE\fP
Возвращает размер \fIstruct prctl_mm_map\fP, который ожидает ядро. Это
позволяет пользователю подобрать совместимую структуру. Аргумент \fIarg4\fP
должен быть указателем на unsigned int.
.IP
Эта возможность доступна только, если ядро собрано с параметром
\fBCONFIG_CHECKPOINT_RESTORE\fP.
.RE
.TP 
\fBPR_MPX_ENABLE_MANAGEMENT\fP, \fBPR_MPX_DISABLE_MANAGEMENT\fP (начиная с Linux 3.19)
.\" commit fe3d197f84319d3bce379a9c0dc17b1f48ad358c
.\" See also http://lwn.net/Articles/582712/
.\" See also https://gcc.gnu.org/wiki/Intel%20MPX%20support%20in%20the%20GCC%20compiler
.\" commit e9d1b4f3c60997fe197bf0243cb4a41a44387a88
Включает или выключает управление таблицами границ Memory Protection
eXtensions (MPX) из ядра. Аргументы \fIarg2\fP, \fIarg3\fP, \fIarg4\fP и \fIarg5\fP
должны быть равно 0.
.IP
MPX — полуаппаратный механизм проверки границ указателей. Он состоит из
набора регистров, хранящих информацию о границах и наборе специальных
префиксов инструкций, которые указывают ЦП, в каких инструкциях нужно
проверить границы. Число регистров ограничено и когда указателей становится
больше чем регистров, их содержимое нужно «засыпать» в набор таблиц. Эти
таблицы называются «таблицами границ» (bounds tables), а для управления их
заполнением и освобождением из ядра существуют операции MPX \fBprctl\fP().
.IP
Когда управление разрешено, ядро начинает следить за выделением и
освобождением таблиц границ. Это делается через ловлю исключений #BR,
которые возникают при первом использовании отсутствующей таблицы границ и в
результате доставляется исключение в пользовательское пространство,  там
выделяется таблица и заполняется каталог границ с расположением новой
таблицы. Для освобождения ядро проверяет есть ли таблицы границ для
нераспределённой памяти и освобождает их если есть.
.IP
Перед включением управления MPX с помощью \fBPR_MPX_ENABLE_MANAGEMENT\fP
приложение сначала должно выделить буфер в пользовательском пространстве для
каталог границ и поместить расположение этого каталоге в регистр \fIbndcfgu\fP.
.IP
Эти вызовы завершаются ошибкой, если ЦП или ядро не поддерживают
MPX. Поддержка MPX в ядре включается параметром настройки
\fBCONFIG_X86_INTEL_MPX\fP. Вы можете проверить наличие поддержки MPX в ЦП
прочитав бит «mpx» в CPUID следующей командой:
.IP
.in +4n
.EX
cat /proc/cpuinfo | grep ' mpx '
.EE
.in
.IP
Нить может не переключиться в «длинный» режим (64\-битный) при включённом
MPX.
.IP
Эти вызовы влияют на все нити процесса.
.IP
Потомок \fBfork\fP(2) наследует состояние управления MPX. Во время \fBexecve\fP(2)
управление MPX сбрасывается в состояние, как если бы выполнился вызов
\fBPR_MPX_DISABLE_MANAGEMENT\fP.
.IP
Дополнительную информацию по Intel MPX смотрите в файле исходного кода ядра
\fIDocumentation/x86/intel_mpx.txt\fP.
.TP 
\fBPR_SET_NAME\fP (начиная с Linux 2.6.9)
.\" TASK_COMM_LEN in include/linux/sched.h
Назначает имя вызывающей нити, используя значение памяти, переданное в
указателе \fI(char\ *) arg2\fP. Имя может быть не более 16, включая завершающий
байт null (если длина строки, включая завершающий null, превышает 16 байт,
то строка просто обрезается). Это то же атрибут, который можно установить
через \fBpthread_setname_np\fP(3) и получить с помощью
\fBpthread_getname_np\fP(3). Также этот атрибут доступен через
\fI/proc/self/task/[tid]/comm\fP, где \fItid\fP — имя вызывающей нити.
.TP 
\fBPR_GET_NAME\fP (начиная с Linux 2.6.11)
Записывает имя вызывающей нити в буфер, указанный в \fI(char\ *) arg2\fP. Буфер
должен быть не более 16 байт; полученная строка будет завершаться null.
.TP 
\fBPR_SET_NO_NEW_PRIVS\fP (начиная с Linux 3.5)
Устанавливает атрибут \fIno_new_privs\fP вызывающей нити равным \fIarg2\fP. Если
значение \fIno_new_privs\fP равно 1, то \fBexecve\fP(2) не выдаст прав никому, кто
бы не мог это сделать без вызова \fBexecve\fP(2) (например, без битов прав
режима set\-user\-ID и set\-group\-ID и файловых мандатов). После установки
атрибута \fIno_new_privs\fP его нельзя сбросить. Значение этого атрибута
наследуется потомками, созданными с помощью \fBfork\fP(2) и \fBclone\fP(2), и
сохраняется при \fBexecve\fP(2).
.IP
Начиная с Linux 4.10, значения атрибута \fIno_new_privs\fP нити отражено в поле
\fINoNewPrivs\fP файла \fI/proc/[pid]/status\fP.
.IP
.\" commit 40fde647ccb0ae8c11d256d271e24d385eed595b
Дополнительную информацию смотрите в файле исходного кода ядра
\fIDocumentation/userspace\-api/no_new_privs.rst\fP (или в
\fIDocumentation/prctl/no_new_privstxt\fP до Linux 4.13). Также смотрите
\fBseccomp\fP(2).
.TP 
\fBPR_GET_NO_NEW_PRIVS\fP (начиная с Linux 3.5)
Возвращает значение (как результат функции) атрибута \fIno_new_privs\fP в
вызывающей нити. Значение 0 соответствует обычному поведению
\fBexecve\fP(2). Значение 1 показывает, что \fBexecve\fP(2) будет работать в
ограничивающем права режиме, как описано ранее.
.TP 
\fBPR_SET_PDEATHSIG\fP (начиная с Linux 2.1.57)
Устанавливает значение сигнала, приходящего процессу при завершении работы
родительского процесса, равным \fIarg2\fP (значение может быть из диапазона
1..maxsig или 0 для снятия). Этот сигнал получит вызывающий процесс, когда
его родитель завершит работу.
.IP
.\" https://bugzilla.kernel.org/show_bug.cgi?id=43300
\fIПредупреждение\fP: «родителем» здесь считается \fIнить\fP, создавшая этот
процесс. Иначе говоря, сигнал будет послан при завершении нити (например, с
помощью \fBpthread_exit\fP(3)), а не всех нитей родительского процесса.
.IP
Сигнал отправляется после завершения родительской нити, а также после
завершения каждого процесса\-сборщика потомков (смотрите описание
\fBPR_SET_CHILD_SUBREAPER\fP выше), которыми вызывающий был последовательно
усыновлён. Если родительская нить и все предки сборщиков завершили работу на
момент операции \fBPR_SET_PDEATHSIG\fP, то сигнал о завершении вызывающему не
посылается.
.IP
Сигнал о завершении родителя направляется процессу (смотрите \fBsignal\fP(7))
и, если потомок установил обработчик использовав \fBsigaction\fP(2) с флагом
\fBSA_SIGINFO\fP, то поле \fIsi_pid\fP аргумента \fIsiginfo_t\fP обработчика содержит
PID завершающегося родительского процесса.
.IP
.\" commit d2d56c5f51028cb9f3d800882eb6f4cbd3f9099f
Значение сигнала о завершении родителя очищается для потомков, созданных
\fBfork\fP(2). Он также очищается (начиная с Linux 2.4.36 / 2.6.23) при
выполнении исполняемого файла с установленным битом set\-user\-ID или
set\-group\-ID, и исполняемого файла с соответствующими мандатами (смотрите
\fBcapabilities\fP(7)); иначе это значение сохраняется при \fBexecve\fP(2).
.TP 
\fBPR_GET_PDEATHSIG\fP (начиная с Linux 2.3.15)
Записывает текущее значение сигнала о завершении работы родительского
процесса по адресу, указанному в \fI(int\ *) arg2\fP.
.TP 
\fBPR_SET_PTRACER\fP (начиная с Linux 3.4)
.\" commit 2d514487faf188938a4ee4fb3464eeecfbdcf8eb
.\" commit bf06189e4d14641c0148bea16e9dd24943862215
Имеет смысл, только если включён Yama LSM и в режиме 1 («ограниченный
ptrace», значение доступно в \fI/proc/sys/kernel/yama/ptrace_scope\fP). Когда
«идентификатор процесса ptracer» передаётся в \fIarg2\fP, вызывающий объявляет,
что процесс ptracer может выполнить \fBptrace\fP(2), как если бы он был прямым
предком процесса. Каждая операция \fBPR_SET_PTRACER\fP заменяет предыдущий
«идентификатор процесса ptracer». Применение \fBPR_SET_PTRACER\fP с значением
\fIarg2\fP равным 0 очищает «идентификатор процесса ptracer» вызывающего. Если
\fIarg2\fP равно \fBPR_SET_PTRACER_ANY\fP, то ограничения ptrace, предоставленные
Yama отключаются для вызывающего процесса.
.IP
.\" commit 90bb766440f2147486a2acc3e793d7b8348b0c22
Дополнительную информацию смотрите в файле исходного кода ядра
\fIDocumentation/admin\-guide/LSM/Yama.rst\fP (или в
\fIDocumentation/security/Yama.txt\fP до Linux 4.13).
.TP 
\fBPR_SET_SECCOMP\fP (начиная с Linux 2.6.23)
.\" See http://thread.gmane.org/gmane.linux.kernel/542632
.\" [PATCH 0 of 2] seccomp updates
.\" andrea@cpushare.com
Устанавливает режим безопасных вычислений (seccomp) в вызывающей нити, в
котором ограничен список доступных системных вызовов. Новый системный вызов
\fBseccomp\fP(2) предоставляет большие возможности чем \fBPR_SET_SECCOMP\fP.
.IP
Режим seccomp выбирается из \fIarg2\fP (константы seccomp определены в
\fI<linux/seccomp.h>\fP).
.IP
Если значение \fIarg2\fP равно \fBSECCOMP_MODE_STRICT\fP, то в нити доступны
только системные вызовы \fBread\fP(2), \fBwrite\fP(2), \fB_exit\fP(2) (но не
\fBexit_group\fP(2)) и \fBsigreturn\fP(2). При запуске других системных вызовов
генерируется сигнал \fBSIGKILL\fP. Режим безопасных вычислений полезен для
вычислительных приложений, которым может потребоваться выполнить
недоверительный байт\-код, возможно полученный при чтении из канала или
сокета. Эта операция доступна только, если в ядре включён параметр
\fBCONFIG_SECCOMP\fP.
.IP
Если значение \fIarg2\fP равно \fBSECCOMP_MODE_FILTER\fP (начиная с Linux 3.5), то
список разрешённых системных вызовов определяется указателем (\fIarg3\fP) на
пакетный фильтр Berkeley. Аргумент указывает на \fIstruct sock_fprog\fP; в
структуре можно описать фильтр и произвольных системных вызовов и их
аргументов. Этот режим доступен только, если ядро собрано с параметром
\fBCONFIG_SECCOMP_FILTER\fP.
.IP
Если в фильтрах \fBSECCOMP_MODE_FILTER\fP разрешён \fBfork\fP(2), то режим seccomp
наследуется потомками, создаваемыми \fBfork\fP(2); если разрешён \fBexecve\fP(2),
то режим seccomp сохраняется при \fBexecve\fP(2). Если в фильтрах разрешены
\fBprctl\fP(), то могут быть добавлены дополнительные фильтры; они применяются
до тех пор пока не будет найдено запрещение.
.IP
.\" commit c061f33f35be0ccc80f4b8e0aea5dfd2ed7e01a3
Дополнительную информацию смотрите в файле исходного кода ядра
\fIDocumentation/userspace\-api/seccomp_filter.rst\fP (или в
\fIDocumentation/prctl/seccomp_filter.txt\fP до Linux 4.13).
.TP 
\fBPR_GET_SECCOMP\fP (начиная с Linux 2.6.23)
Возвращает значение (как результат функции) режима безопасных вычислений
вызвавшей нити. Если вызывающий не работает в режиме безопасных вычислений,
то возвращается 0; если вызывающий находится в режиме ограниченных
безопасных вычислений, то вызов \fBprctl\fP() приведёт к отправке процессу
сигнала \fBSIGKILL\fP. Если вызывающий работает в режиме фильтрации и данный
системный вызов разрешён в фильтрах seccomp, то возвращается 2; в противном
случае процесс завершается по сигналу \fBSIGKILL\fP. Эта операция доступна
только, если ядро собрано с параметром \fBCONFIG_SECCOMP\fP.
.IP
Начиная с Linux 3.8 в поле \fISeccomp\fP файла \fI/proc/[pid]/status\fP
предоставляется метод получения той же информации, без риска уничтожения
процесса; смотрите \fBproc\fP(5).
.TP 
\fBPR_SET_SECUREBITS\fP (начиная с Linux 2.6.26)
Устанавливает значение флагов «securebits» вызывающей нити равным значению
\fIarg2\fP. Смотрите \fBcapabilities\fP(7).
.TP 
\fBPR_GET_SECUREBITS\fP (начиная с Linux 2.6.26)
Возвращает (как результат функции) флаги «securebits» вызывающей
нити. Смотрите \fBcapabilities\fP(7).
.TP 
\fBPR_GET_SPECULATION_CTRL\fP (начиная с Linux 4.17)
Возвращает состояние нежелательной спекулятовности, указанной в \fIarg2\fP. В
настоящее время значением аргумента может быть только
\fBPR_SPEC_STORE_BYPASS\fP (в противном случае возвращается ошибка \fBENODEV\fP).
.IP
В значении результата используются биты 0\-3:
.RS
.TP 
\fBPR_SPEC_PRCTL\fP
Смягчение (mitigation) можно контролировать на уровне нити через
\fBPR_SET_SPECULATION_CTRL\fP
.TP 
\fBPR_SPEC_ENABLE\fP
Свойство спекулятивности включено, смягчение выключено.
.TP 
\fBPR_SPEC_DISABLE\fP
Свойство спекулятивности выключено, смягчение включено
.TP 
\fBPR_SPEC_FORCE_DISABLE\fP
Тоже, что и \fBPR_SPEC_DISABLE\fP, но нельзя отменить.
.RE
.IP
Если все биты равны 0, то на ЦП нежелательная спекулятовность не работает.
.IP
Если установлен \fBPR_SPEC_PRCTL\fP, то доступно управление смягчением на
уровне нити. Если не установлен, то вызов \fBprctl\fP() для нежелательной
спекулятовности завершится ошибкой.
.IP
Аргументы \fIarg3\fP, \fIarg4\fP и \fIarg5\fP должны быть равны 0; в противном случае
вызов завершается ошибкой \fBEINVAL\fP.
.TP 
\fBPR_SET_SPECULATION_CTRL\fP (начиная с Linux 4.17)
.\" commit b617cfc858161140d69cc0b5cc211996b557a1c7
.\" commit 356e4bfff2c5489e016fdb925adbf12a1e3950ee
Задаёт состояние нежелательной спекулятовности, согласно значению \fIarg2\fP. В
настоящее время значением аргумента может быть только
\fBPR_SPEC_STORE_BYPASS\fP (в противном случае возвращается ошибка
\fBENODEV\fP).Данная настройка является атрибутом нити. Аргумент \fIarg3\fP
используется как управляющее значение, которое может быть одним из
следующих:
.RS
.TP 
\fBPR_SPEC_ENABLE\fP
Свойство спекулятивности включено, смягчение выключено.
.TP 
\fBPR_SPEC_DISABLE\fP
Свойство спекулятивности выключено, смягчение включено
.TP 
\fBPR_SPEC_FORCE_DISABLE\fP
Тоже, что и \fBPR_SPEC_DISABLE\fP, но нельзя отменить. Последующий вызов
\fBprctl(..., PR_SPEC_ENABLE)\fP завершится ошибкой \fBEPERM\fP.
.RE
.IP
Любое другое значение в \fIarg3\fP приведёт к ошибке \fBERANGE\fP.
.IP
Аргументы \fIarg4\fP и \fIarg5\fP должны быть равны 0; в противном случае вызов
завершается ошибкой \fBEINVAL\fP.
.IP
Свойство спекулятивного выполнения также может контролироваться параметром
загрузки \fBspec_store_bypass_disable\fP. Это параметр может установить режим
только для чтения, при котором вызов \fBprctl\fP() будет завершаться ошибкой
\fBENXIO\fP. Дополнительную информацию смотрите в файле исходного кода ядра
\fIDocumentation/admin\-guide/kernel\-parameters.txt\fP.
.TP 
\fBPR_SET_THP_DISABLE\fP (начиная с Linux 3.15)
.\" commit a0715cc22601e8830ace98366c0c2bd8da52af52
.\"
Задать состояние флага «THP disable» вызывающей нити. Если \fIarg2\fP не равно
нулю, то флаг устанавливается, иначе очищается. Установка этого флага
предоставляет метод отключения прозрачных огромных страниц для заданий, код
которых нельзя изменить и использование обработчика malloc с \fBmadvise\fP(2)
невозможно (т. е., место под данные выделено статически). Значение флага
«THP disable» наследуется потомком, создаваемым \fBfork\fP(2) и сохраняется
после \fBexecve\fP(2).
.TP 
\fBPR_TASK_PERF_EVENTS_DISABLE\fP (начиная с Linux 2.6.31)
Отключает все счётчики производительности, прикреплённые к вызывающему
процессу, не учитывая, были ли они созданы этим процессом или каким\-то
другим. Счётчики производительности, созданные вызывающим процессом для
других процессов, не отключаются. Подробности о счётчиках производительности
приведены в файле ядра Linux \fItools/perf/design.txt\fP.
.IP
.\" commit 1d1c7ddbfab358445a542715551301b7fc363e28
.\"
Сначала назывался \fBPR_TASK_PERF_COUNTERS_DISABLE\fP; переименован (числовое
значение не изменилось) в Linux 2.6.32.
.TP 
\fBPR_TASK_PERF_EVENTS_ENABLE\fP (начиная с Linux 2.6.31)
Противоположное действие \fBPR_TASK_PERF_EVENTS_DISABLE\fP; включает счётчики
производительности, прикреплённые к вызывающему процессу.
.IP
.\" commit 1d1c7ddbfab358445a542715551301b7fc363e28
.\" commit cdd6c482c9ff9c55475ee7392ec8f672eddb7be6
.\"
Сначала назывался \fBPR_TASK_PERF_COUNTERS_ENABLE\fP; переименован в Linux
2.6.32.
.TP 
\fBPR_GET_THP_DISABLE\fP (начиная с Linux 3.15)
Возвращает текущее значение (как результат функции) флага «THP disable»
вызывающей нити: 1 — флаг установлен; 0 — нет.
.TP 
\fBPR_GET_TID_ADDRESS\fP (начиная с Linux 3.5)
.\" commit 300f786b2683f8bb1ec0afb6e1851183a479c86d
Возвращает адрес \fIclear_child_tid\fP, заданный \fBset_tid_address\fP(2) и
\fBclone\fP(2) с флагом \fBCLONE_CHILD_CLEARTID\fP, в расположение, указанное в
\fI(int\ **)\ arg2\fP. Эта возможность доступна только, если ядро собрано с
параметром \fBCONFIG_CHECKPOINT_RESTORE\fP. Заметим, что так как системный
вызов \fBprctl\fP() не содержит совместимой реализации для AMD64 x32 и MIPS n32
ABI и ядро записывает указатель размером с ядерный, то эта операция требует
пользовательский буфер в 8 (не 4) байт в этих ABI.
.TP 
\fBPR_SET_TIMERSLACK\fP (начиная с Linux 2.6.28)
.\" See https://lwn.net/Articles/369549/
.\" commit 6976675d94042fbd446231d1bd8b7de71a980ada
Каждая нити имеет два связанных с таймером значения допуска: значение «по
умолчанию» и «текущее» значение. Эта операция изменяет «текущее» значение
допуска таймера вызывающей нити. Значение \fIarg2\fP имеет тип длинного
беззнакового целого, то есть максимальное «текущее» значение равно
ULONG_MAX, а минимальное «текущее» значение равно 1. Если наносекундное
значение из \fIarg2\fP больше нуля, то оно присваивается «текущему»
значению. Если \fIarg2\fP равно 0, то «текущий» допуск таймера нити
сбрасывается в значение допуска таймера «по умолчанию».
.IP
«Текущий» допуск таймера используется ядром для группировки таймерных
окончаний при вызовах нити, которые происходят очень часто; как следствие,
таймерные окончания нити могут быть равны до указанной наносекундной
задержки (но никогда не будут истекать ранее). Группировка таймерных
окончаний может помочь сократить потребление энергии системой, в следствии
сокращения количества пробуждений ЦП.
.IP
.\" List obtained by grepping for futex usage in glibc source
Таймерные окончания, на которые влияет допуск таймера, устанавливаются
\fBselect\fP(2), \fBpselect\fP(2), \fBpoll\fP(2), \fBppoll\fP(2), \fBepoll_wait\fP(2),
\fBepoll_pwait\fP(2), \fBclock_nanosleep\fP(2), \fBnanosleep\fP(2) и \fBfutex\fP(2) (и,
следовательно, все библиотечными функциями, реализованными через futex:
\fBpthread_cond_timedwait\fP(3), \fBpthread_mutex_timedlock\fP(3),
\fBpthread_rwlock_timedrdlock\fP(3), \fBpthread_rwlock_timedwrlock\fP(3) и
\fBsem_timedwait\fP(3)).
.IP
Допуск таймера не применяется к нитям, которые планируются в соответствии с
политикой реального времени (смотрите \fBsched_setscheduler\fP(2)).
.IP
При создании новой нити этим двум значениям присваивается значение
«текущего» допуска создающей нити. После этого нить может подстроить
значение своего «текущего» допуска таймера с помощью \fBPR_SET_TIMERSLACK\fP
(значение по умолчанию не может быть изменено). Значения допуска таймера для
\fIinit\fP (PID 1), предка всех процессов, равно 50000 наносекунд (50
микросекунд). Значения допуска таймера наследуются потомком при \fBfork\fP(2) и
сохраняются при вызове \fBexecve\fP(2).
.IP
Начиная с Linux 4.6 значение «текущего» допуска таймера любого процесса
можно получить и изменить через файл \fI/proc/[pid]/timerslack_ns\fP. Смотрите
\fBproc\fP(5).
.TP 
\fBPR_GET_TIMERSLACK\fP (начиная с Linux 2.6.28)
Возвращает значение «текущего» допуска (как результат функции) таймера
вызывающей нити.
.TP 
\fBPR_SET_TIMING\fP (начиная с Linux 2.6.0)
.\" Precisely: Linux 2.6.0-test4
.\" 0
.\" 1
.\" PR_TIMING_TIMESTAMP doesn't do anything in 2.6.26-rc8,
.\" and looking at the patch history, it appears
.\" that it never did anything.
Включает использование обычного статистического временного режима выполнения
процесса (process timing) или точного режима на основе меток времени
(timestamp\-based process timing), при передаче \fBPR_TIMING_STATISTICAL\fP или
\fBPR_TIMING_TIMESTAMP\fP в \fIarg2\fP. Действия для \fBPR_TIMING_TIMESTAMP\fP пока
не реализованы (попытка установить этот режим приведёт к ошибке \fBEINVAL\fP).
.TP 
\fBPR_GET_TIMING\fP (начиная с Linux 2.6.0)
.\" Precisely: Linux 2.6.0-test4
Возвращает (как результат функции) тип используемого в данный момент
временного режима выполнения процесса.
.TP 
\fBPR_SET_TSC\fP (начиная с Linux 2.6.26, только для x86)
Устанавливает состояние флага, определяющего может ли процесс прочитать
счётчик метки времени (timestamp counter). Значение \fBPR_TSC_ENABLE\fP в
\fIarg2\fP разрешает чтение, \fBPR_TSC_SIGSEGV\fP включает генерацию \fBSIGSEGV\fP,
если процесс пытается прочитать счётчик метки времени.
.TP 
\fBPR_GET_TSC\fP (начиная с Linux 2.6.26, только для x86)
Записывает значение флага, определяющего может ли быть прочитан счётчик
метки времени (timestamp counter), по адресу, указанному в \fI(int\ *) arg2\fP.
.TP 
\fBPR_SET_UNALIGN\fP
.\" sh: 94ea5e449ae834af058ef005d16a8ad44fcf13d6
.\" tile: 2f9ac29eec71a696cb0dcc5fb82c0f8d4dac28c9
(только для: ia64, начиная с Linux 2.3.48; parisc, начиная с Linux 2.6.15;
PowerPC, начиная с Linux 2.6.18; Alpha, начиная с Linux 2.6.22; sh, начиная
с Linux 2.6.34; tile, начиная с Linux 3.12) Устанавливает значение битов
контроля доступа выравнивания равным значению \fIarg2\fP. При значении
\fBPR_UNALIGN_NOPRINT\fP пользовательский доступ без выравнивания без
уведомления исправляется, а при \fBPR_UNALIGN_SIGBUS\fP генерируется сигнал
\fBSIGBUS\fP. На Alpha также поддерживается дополнительный флаг со значением 4
(именованная константа отсутствует), который указывает ядру не исправлять
невыровненный доступ (аналогично флагу \fBUAC_NOFIX\fP в операции
\fBSSI_NVPAIRS\fP системного вызова \fBsetsysinfo\fP() на Tru64).
.TP 
\fBPR_GET_UNALIGN\fP
(информацию о версиях и архитектурах смотрите в \fBPR_SET_UNALIGN\fP)
Записывает значение битов контроля доступа выравнивания по адресу,
указанному в \fI(unsigned int\ *) arg2\fP.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
При успешном выполнении для операций \fBPR_GET_DUMPABLE\fP, \fBPR_GET_KEEPCAPS\fP,
\fBPR_GET_NO_NEW_PRIVS\fP, \fBPR_GET_THP_DISABLE\fP, \fBPR_CAPBSET_READ\fP,
\fBPR_GET_TIMING\fP, \fBPR_GET_TIMERSLACK\fP, \fBPR_GET_SECUREBITS\fP,
\fBPR_MCE_KILL_GET\fP, \fBPR_CAP_AMBIENT\fP+\fBPR_CAP_AMBIENT_IS_SET\fP, и (если
возвращается) \fBPR_GET_SECCOMP\fP возвращаются неотрицательные значения,
описанные ранее. При успешном выполнении для остальных значений \fIoption\fP
возвращается 0. При ошибке возвращается \-1, а \fIerrno\fP устанавливается в
соответствующее значение.
.SH ОШИБКИ
.TP 
\fBEACCES\fP
Значение \fIoption\fP равно \fBPR_SET_SECCOMP\fP и \fIarg2\fP равно
\fBSECCOMP_MODE_FILTER\fP, но процесс не имеет мандата \fBCAP_SYS_ADMIN\fP или
установленного атрибута \fIno_new_privs\fP (смотрите обсуждение
\fBPR_SET_NO_NEW_PRIVS\fP выше).
.TP 
\fBEACCES\fP
Значение \fIoption\fP равно \fBPR_SET_MM\fP, а \fIarg3\fP — \fBPR_SET_MM_EXE_FILE\fP,
файл не является исполняемым.
.TP 
\fBEBADF\fP
Значение \fIoption\fP равно \fBPR_SET_MM\fP, \fIarg3\fP — \fBPR_SET_MM_EXE_FILE\fP, и
файловый дескриптор, переданный в \fIarg4\fP, некорректен.
.TP 
\fBEBUSY\fP
Значение \fIoption\fP равно \fBPR_SET_MM\fP, \fIarg3\fP — \fBPR_SET_MM_EXE_FILE\fP, и
это вторая попытка изменить символьную ссылку \fI/proc/pid/exe\fP, что
запрещено.
.TP 
\fBEFAULT\fP
В \fIarg2\fP указан неправильный адрес.
.TP 
\fBEFAULT\fP
Значение \fIoption\fP равно \fBPR_SET_SECCOMP\fP, \fIarg2\fP равно
\fBSECCOMP_MODE_FILTER\fP, система была собрана с \fBCONFIG_SECCOMP_FILTER\fP и
\fIarg3\fP содержит некорректный адрес.
.TP 
\fBEINVAL\fP
Не распознано значение \fIoption\fP.
.TP 
\fBEINVAL\fP
Значение \fIoption\fP равно \fBPR_MCE_KILL\fP, \fBPR_MCE_KILL_GET\fP или
\fBPR_SET_MM\fP, и неиспользуемые аргументы \fBprctl\fP() не равны нулю.
.TP 
\fBEINVAL\fP
Неверное значение \fIarg2\fP для указанной в \fIoption\fP операции.
.TP 
\fBEINVAL\fP
Значение \fIoption\fP равно \fBPR_SET_SECCOMP\fP или \fBPR_GET_SECCOMP\fP, и ядро не
собрано с параметром \fBCONFIG_SECCOMP\fP.
.TP 
\fBEINVAL\fP
Значение \fIoption\fP равно \fBPR_SET_SECCOMP\fP, \fIarg2\fP равно
\fBSECCOMP_MODE_FILTER\fP и ядро было собрано без \fBCONFIG_SECCOMP_FILTER\fP.
.TP 
\fBEINVAL\fP
Значение \fIoption\fP равно \fBPR_SET_MM\fP и одно из следующего является истиной:
.RS
.IP * 3
Значение \fIarg4\fP или \fIarg5\fP не равно нулю;
.IP *
Значение \fIarg3\fP больше \fBTASK_SIZE\fP (ограничение на размер
пользовательского адресного пространства для этой архитектуры);
.IP *
Значение \fIarg2\fP равно \fBPR_SET_MM_START_CODE\fP, \fBPR_SET_MM_END_CODE\fP,
\fBPR_SET_MM_START_DATA\fP, \fBPR_SET_MM_END_DATA\fP или \fBPR_SET_MM_START_STACK\fP,
и права на соответствующую область памяти не удовлетворяют требованиям;
.IP *
Значение \fIarg2\fP равно \fBPR_SET_MM_START_BRK\fP или \fBPR_SET_MM_BRK\fP, и
значение \fIarg3\fP меньше или равно концу сегмента данных, или было бы
превышено ограничение ресурса \fBRLIMIT_DATA\fP.
.RE
.TP 
\fBEINVAL\fP
Значение \fIoption\fP равно \fBPR_SET_PTRACER\fP и значение \fIarg2\fP не равно 0,
\fBPR_SET_PTRACER_ANY\fP или PID существующего процесса.
.TP 
\fBEINVAL\fP
Значение \fIoption\fP равно \fBPR_SET_PDEATHSIG\fP и значение \fIarg2\fP не является
корректным номером сигнала.
.TP 
\fBEINVAL\fP
Значение \fIoption\fP равно \fBPR_SET_DUMPABLE\fP и значение \fIarg2\fP не равно
\fBSUID_DUMP_DISABLE\fP или \fBSUID_DUMP_USER\fP.
.TP 
\fBEINVAL\fP
Значение \fIoption\fP равно \fBPR_SET_TIMING\fP и значение \fIarg2\fP не равно
\fBPR_TIMING_STATISTICAL\fP.
.TP 
\fBEINVAL\fP
Значение \fIoption\fP равно \fBPR_SET_NO_NEW_PRIVS\fP и значение \fIarg2\fP не равно
1 или \fIarg3\fP, \fIarg4\fP или \fIarg5\fP не равны нулю.
.TP 
\fBEINVAL\fP
Значение \fIoption\fP равно \fBPR_GET_NO_NEW_PRIVS\fP и значения \fIarg2\fP, \fIarg3\fP,
\fIarg4\fP или \fIarg5\fP не равны нулю.
.TP 
\fBEINVAL\fP
Значение \fIoption\fP равно \fBPR_SET_THP_DISABLE\fP и \fIarg3\fP, \fIarg4\fP или
\fIarg5\fP не равны нулю.
.TP 
\fBEINVAL\fP
Значение \fIoption\fP равно \fBPR_GET_THP_DISABLE\fP и значения \fIarg2\fP, \fIarg3\fP,
\fIarg4\fP или \fIarg5\fP не равны нулю.
.TP 
\fBEINVAL\fP
Значение \fIoption\fP равно \fBPR_CAP_AMBIENT\fP и неиспользуемый аргумент
(\fIarg4\fP, \fIarg5\fP или, в случае \fBPR_CAP_AMBIENT_CLEAR_ALL\fP, \fIarg3\fP)  не
равен нулю; или \fIarg2\fP содержит некорректное значение; или \fIarg2\fP равно
\fBPR_CAP_AMBIENT_LOWER\fP, \fBPR_CAP_AMBIENT_RAISE\fP или
\fBPR_CAP_AMBIENT_IS_SET\fP и в \fIarg3\fP указан некорректный мандат.
.TP 
\fBEINVAL\fP
Значение \fIoption\fP равно \fBPR_GET_SPECULATION_CTRL\fP или
\fBPR_SET_SPECULATION_CTRL\fP, но неиспользуемые аргументы \fBprctl\fP() не равны
0.
.TP 
\fBENODEV\fP
Значение \fIoption\fP равно \fBPR_SET_SPECULATION_CTRL\fP, но ядро или ЦП не
поддерживает запрашиваемую нежелательную спекулятовность.
.TP 
\fBENXIO\fP
Значение \fIoption\fP было \fBPR_MPX_ENABLE_MANAGEMENT\fP или
\fBPR_MPX_DISABLE_MANAGEMENT\fP и ядро или ЦП не поддерживают управление
MPX. Проверьте, что ядро и процессор поддерживают MPX.
.TP 
\fBENXIO\fP
Значение \fIoption\fP, равное \fBPR_SET_SPECULATION_CTRL\fP, подразумевает, что
управление выбранной нежелательной спекулятовности невозможно. Доступные
значения смотрите в описании битовых полей \fBPR_GET_SPECULATION_CTRL\fP.
.TP 
\fBEOPNOTSUPP\fP
Значение \fIoption\fP равно \fBPR_SET_FP_MODE\fP и \fIarg2\fP содержит неправильное
или неподдерживаемое значение.
.TP 
\fBEPERM\fP
Значение \fIoption\fP равно \fBPR_SET_SECUREBITS\fP, и вызывающий не имеет мандата
\fBCAP_SETPCAP\fP, или пытается сбросить «заблокированный» флаг, или пытается
установить флаг, для которого установлен соответствующий заблокированный
флаг (смотрите \fBcapabilities\fP(7)).
.TP 
\fBEPERM\fP
Значение \fIoption\fP равно \fBPR_SET_SPECULATION_CTRL\fP, но спекулятивность была
отключена с помощью \fBPR_SPEC_FORCE_DISABLE\fP, а вызывающий пытается включить
её снова.
.TP 
\fBEPERM\fP
Значение \fIoption\fP равно \fBPR_SET_KEEPCAPS\fP, и у вызывающего установлен флаг
\fBSECBIT_KEEP_CAPS_LOCKED\fP (смотрите \fBcapabilities\fP(7)).
.TP 
\fBEPERM\fP
Значение \fIoption\fP равно \fBPR_CAPBSET_DROP\fP, и вызывающий не имеет мандата
\fBCAP_SETPCAP\fP.
.TP 
\fBEPERM\fP
Значение \fIoption\fP равно \fBPR_SET_MM\fP, и вызывающий не имеет мандата
\fBCAP_SYS_RESOURCE\fP.
.TP 
\fBEPERM\fP
Значение \fIoption\fP равно \fBPR_CAP_AMBIENT\fP и \fIarg2\fP равно
\fBPR_CAP_AMBIENT_RAISE\fP, но мандат, указанный в \fIarg3\fP, отсутствует в
разрешительном или унаследованном наборе мандатов, или был установлен бит
безопасности \fBPR_CAP_AMBIENT_LOWER\fP.
.TP 
\fBERANGE\fP
Значение \fIoption\fP равно \fBPR_SET_SPECULATION_CTRL\fP, но значение \fIarg3\fP не
равно \fBPR_SPEC_ENABLE\fP, \fBPR_SPEC_DISABLE\fP или \fBPR_SPEC_FORCE_DISABLE\fP.
.SH ВЕРСИИ
.\" The library interface was added in glibc 2.0.6
Системный вызов \fBprctl\fP() впервые появился в Linux 2.1.57.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
Данный вызов существует только в Linux. В IRIX есть системный вызов
\fBprctl\fP() (также представленный в Linux 2.1.44 как irix_prctl на
архитектуре MIPS) объявленный как
.PP
.in +4n
.EX
\fBptrdiff_t prctl(int \fP\fIoption\fP\fB, int \fP\fIarg2\fP\fB, int \fP\fIarg3\fP\fB);\fP
.EE
.in
.PP
а также операции, позволяющие получить максимальное количество процессов для
каждого пользователя, максимальное количество процессоров, которое может
использовать вызывающий процесс; определить, блокирован ли заданный процесс;
получить или установить максимальный размер стека и т. д.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBsignal\fP(2), \fBcore\fP(5)
