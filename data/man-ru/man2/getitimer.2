.\" -*- mode: troff; coding: UTF-8 -*-
.\" Copyright 7/93 by Darren Senn <sinster@scintilla.santa-clara.ca.us>
.\" and Copyright (C) 2016, Michael Kerrisk <mtk.manpages@gmail.com>
.\" Based on a similar page Copyright 1992 by Rick Faith
.\"
.\" %%%LICENSE_START(FREELY_REDISTRIBUTABLE)
.\" May be freely distributed and modified
.\" %%%LICENSE_END
.\"
.\" Modified Tue Oct 22 00:22:35 EDT 1996 by Eric S. Raymond <esr@thyrsus.com>
.\" 2005-04-06 mtk, Matthias Lang <matthias@corelatus.se>
.\" 	Noted MAX_SEC_IN_JIFFIES ceiling
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH GETITIMER 2 2017\-09\-15 Linux "Руководство программиста Linux"
.SH ИМЯ
getitimer, setitimer \- считывает или устанавливает значение таймера
интервалов
.SH ОБЗОР
.nf
\fB#include <sys/time.h>\fP
.PP
\fBint getitimer(int \fP\fIwhich\fP\fB, struct itimerval *\fP\fIcurr_value\fP\fB);\fP
\fBint setitimer(int \fP\fIwhich\fP\fB, const struct itimerval *\fP\fInew_value\fP\fB,\fP
\fB              struct itimerval *\fP\fIold_value\fP\fB);\fP
.fi
.SH ОПИСАНИЕ
Данные системные вызовы предоставляют доступ к интервальным таймерам, то
есть таймерам, у которых изначально истекает срок в будущем, и
(необязательно) с регулярными интервалами после. Когда у таймера истекает
срок, вызвавшему процессу отправляется сигнал и таймер перезапускается с
задаваемым интервалом (если интервал не равен нулю).
.PP
В аргументе \fIwhich\fP можно задать три типа таймеров, каждый выполняет отсчёт
по разным часам и генерирует разный сигнал по истечении срока:
.TP  1.5i
\fBITIMER_REAL\fP
Этот таймер отсчитывается по реальному времени (то есть обычному). По
каждому истечению выдаёт сигнал \fBSIGALRM\fP.
.TP 
\fBITIMER_VIRTUAL\fP
Этот таймер отсчитывается по времени ЦП в пользовательском режиме,
проведённым процессом (учёт включает время ЦП, потреблённое всеми нитями
процесса). По каждому истечению выдаёт сигнал \fBSIGVTALRM\fP.
.TP 
\fBITIMER_PROF\fP
Этот таймер отсчитывается по полному времени ЦП, потраченному процессом
(учёт включает время ЦП, потреблённое всеми нитями процесса). По каждому
истечению выдаёт сигнал \fBSIGPROF\fP.
.IP
Данный таймер вместе с \fBITIMER_VIRTUAL\fP можно использовать для
профилирования затрат процессом системного и пользовательского времени ЦП.
.PP
Процесс может иметь только по одному таймеру каждого типа.
.PP
Величина, на которую устанавливается таймер, определяется следующими
структурами:
.PP
.in +4n
.EX
struct itimerval {
    struct timeval it_interval; /* интервал для периодического таймера */
    struct timeval it_value;    /* время до следующего окончания */
};

struct timeval {
    time_t      tv_sec;     /* секунды */
    suseconds_t tv_usec;    /* микросекунды */
};
.EE
.in
.\"
.SS getitimer()
Функция \fBgetitimer\fP() помещает текущее значение таймера, указанного в
\fIwhich\fP, в буфер, указанный в \fIcurr_value\fP.
.PP
Вложенная структура \fIit_value\fP содержит количество оставшегося времени до
следующего истечения таймера. Это значение изменяется после начала отсчёта
таймера и будет сброшено в \fIit_interval\fP при истечении таймера. Если оба
поля \fIit_value\fP равны нулю, то это означает что таймер выключен
(неактивен).
.PP
Вложенная структура \fIit_interval\fP содержит интервал таймера. Если оба поля
\fIit_interval\fPравны нулю, то это указывает на одноразовый таймер (то
срабатывающий один раз).
.SS setitimer()
Функция \fBsetitimer\fP() настраивает таймер \fIwhich\fP значением
\fInew_value\fP. Если значение \fIold_value\fP не NULL, то оно указывает на буфер,
в который сохраняется предыдущее значение таймера (т. е., информация,
возвращаемая \fBgetitimer\fP()).
.PP
Если какое\-то из полей в \fInew_value.it_value\fP не равно нулю, то таймер
изначально включается как просроченный на указанное время. Если оба поля в
\fInew_value.it_value\fP равны нулю, то таймер отключён.
.PP
Поле \fInew_value.it_interval\fP задаёт новый интервал таймера;если оба поля
равны нулю, то таймер будет одноразовым.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
При успешном выполнении возвращается 0. В случае ошибки возвращается \-1, а
\fIerrno\fP устанавливается в соответствующее значение.
.SH ОШИБКИ
.TP 
\fBEFAULT\fP
Указатели \fInew_value\fP, \fIold_value\fP или \fIcurr_value\fP являются
некорректными.
.TP 
\fBEINVAL\fP
Значение \fIwhich\fP не равно \fBITIMER_REAL\fP, \fBITIMER_VIRTUAL\fP или
\fBITIMER_PROF\fP; или (начиная с Linux 2.6.22) одно из полей структуры
\fItv_usec\fP, указанной в \fInew_value\fP, содержит значение вне диапазона от 0
до 999999.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
POSIX.1\-2001, SVr4, 4.4BSD (впервые этот вызов появился в 4.2BSD). В
POSIX.1\-2008 вызовы \fBgetitimer\fP() и \fBsetitimer\fP() помечены как устаревшие,
и вместо них рекомендуется использовать программный интерфейс таймеров POSIX
(\fBtimer_gettime\fP(2), \fBtimer_settime\fP(2) и т.д.).
.SH ЗАМЕЧАНИЯ
Срок на таймерах никогда не заканчивается ранее указанного времени, но может
(чуть\-чуть) опоздать, что зависит от степени разрешения системного таймера и
загрузки системы; смотрите \fBtime\fP(7) (но смотрите ДЕФЕКТЫ далее). Если
время таймера истекает во время работы процесса (всегда, если используется
\fBITIMER_VIRTUAL\fP), то сигнал после создания будет доставлен немедленно.
.PP
Потомок, созданный через \fBfork\fP(2), не наследует таймеры интервалов
родителя. При вызове \fBexecve\fP(2) таймеры интервалов сохраняются.
.PP
В POSIX.1 не определено взаимодействие между \fBsetitimer\fP() и тремя
интерфейсами: \fBalarm\fP(2), \fBsleep\fP(3) и \fBusleep\fP(3).
.PP
В стандартах ничего не говорится о значении вызова:
.PP
    setitimer(which, NULL, &old_value);
.PP
В многих системах (Solaris, BSD и, возможно, другие) он считается
эквивалентом:
.PP
    getitimer(which, &old_value);
.PP
В Linux это эквивалентно вызову, в котором поля \fInew_value\fP равны 0, то
есть таймер выключен. \fIНе используйте это особенность Linux\fP: это
непереносимо и нецелесообразно.
.SH ДЕФЕКТЫ
Генерирование и доставка сигнала разделены, и только один экземпляр каждого
сигнала, которые описаны выше, может ожидать передачи в процесс. При очень
большой нагрузке, ожидание таймера \fBITIMER_REAL\fP может завершиться раньше
чем будет доставлен сигнал о предыдущем завершении. Второй сигнал об этом
событии будет потерян.
.PP
В ядрах Linux до версии 2.6.16, значения таймеров указывались в мигах. Если
запрашивалась установка таймера в значение, представление в мигах которого
превышало \fBMAX_SEC_IN_JIFFIES\fP (определено в \fIinclude/linux/jiffies.h\fP),
то значение таймера просто урезалось до этого максимального значения. На
Linux/i386 (где, начиная с Linux 2.6.13, по умолчанию миг равен 0.004
секунды), это означало, что максимальное значение таймера приблизительно
равнялось 99.42 дня. Начиная с Linux 2.6.16, в ядрах стали использовать
другое внутреннее представление времени, и этот предел был снят.
.PP
.\" 4 Jul 2005: It looks like this bug may remain in 2.4.x.
.\"	http://lkml.org/lkml/2005/7/1/165
В некоторых системах (включая i386), ядра Linux до версии 2.6.12 содержали
дефект, который при определённых условиях приводил к преждевременному
завершению за один миг (jiffy). Этот дефект исправлен в ядре 2.6.12.
.PP
.\" Bugzilla report 25 Apr 2006:
.\" http://bugzilla.kernel.org/show_bug.cgi?id=6443
.\" "setitimer() should reject noncanonical arguments"
В POSIX.1\-2001 сказано, что \fBsetitimer\fP() должен завершаться с ошибкой,
если значение \fItv_usec\fP лежит вне диапазона от 0 до 999999. Однако, в ядрах
до версии 2.6.21 включительно, в Linux ошибка не выдаётся, а вместо этого
значение таймера просто подгоняется под соответствующие секунды. Начиная с
ядра 2.6.22, это несоответствие убрано: некорректное значение \fItv_usec\fP
приводит к ошибке \fBEINVAL\fP.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBgettimeofday\fP(2), \fBsigaction\fP(2), \fBsignal\fP(2), \fBtimer_create\fP(2),
\fBtimerfd_create\fP(2), \fBtime\fP(7)
