.\" -*- mode: troff; coding: UTF-8 -*-
.\" Copyright (c) International Business Machines orp., 2006
.\"
.\" %%%LICENSE_START(GPLv2+_SW_3_PARA)
.\" This program is free software; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" This program is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
.\" the GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, see
.\" <http://www.gnu.org/licenses/>.
.\" %%%LICENSE_END
.\"
.\" HISTORY:
.\" 2006-04-27, created by Eduardo M. Fleury <efleury@br.ibm.com>
.\" with various additions by Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH IOPRIO_SET 2 2019\-03\-06 Linux "Руководство программиста Linux"
.SH ИМЯ
ioprio_get, ioprio_set \- получает/устанавливает класс и приоритет
планирования ввода\-вывода
.SH ОБЗОР
.nf
\fBint ioprio_get(int \fP\fIwhich\fP\fB, int \fP\fIwho\fP\fB);\fP
\fBint ioprio_set(int \fP\fIwhich\fP\fB, int \fP\fIwho\fP\fB, int \fP\fIioprio\fP\fB);\fP
.fi
.PP
\fIЗамечание\fP: В glibc нет обёрточных функций для этих системных вызовов;
смотрите ЗАМЕЧАНИЯ.
.SH ОПИСАНИЕ
Системные вызовы \fBioprio_get\fP() и \fBioprio_set\fP() получают и устанавливают
класс и приоритет планирования ввода\-вывода одной или более нитей.
.PP
В аргументах \fIwhich\fP и \fIwho\fP указывается нить(и), над которой выполняются
системные вызовы. В аргументе \fIwhich\fP указывается как будет рассматриваться
\fIwho\fP; он может иметь одно из следующих значений:
.TP 
\fBIOPRIO_WHO_PROCESS\fP
Значением \fIwho\fP является идентификатор процесса или нити, определяющий один
процесс или нить. Если \fIwho\fP равно 0, то операции выполняются над вызвавшей
нитью.
.TP 
\fBIOPRIO_WHO_PGRP\fP
Значением \fIwho\fP является идентификатор группы, определяющий всех членов
группы процесса. Если \fIwho\fP равно 0, то операции выполняются над группой
процессов, членом которой является вызвавший.
.TP 
\fBIOPRIO_WHO_USER\fP
.\" FIXME . Need to document the behavior when 'who" is specified as 0
.\" See http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=652443
Значением \fIwho\fP является идентификатор пользователя, определяющий все
процессы, которые имеют этот реальный идентификатор.
.PP
Если при вызове \fBioprio_get\fP() в \fIwhich\fP указано \fBIOPRIO_WHO_PGRP\fP или
\fBIOPRIO_WHO_USER\fP, и под шаблон \fIwho\fP подходит более одного процесса, то
возвращаемый приоритет будет равен самому высокому значению среди процессов
этой группы. Считается, что один приоритет больше другого, если он
принадлежит более высокому классу процессов (\fBIOPRIO_CLASS_RT\fP является
самым высоким классом приоритетов; \fBIOPRIO_CLASS_IDLE\fP \(em самым низким),
или если оба процесса принадлежат одному классу, то тогда самым высоким
будет приоритет с большим уровнем (меньший номер приоритета, означает более
высокий уровень).
.PP
Аргумент \fIioprio\fP, задаваемый в \fBioprio_set\fP(), является битовой маской, в
которой указываются класс планирования и приоритет, назначаемый заданному
процессу(ам). Для компоновки и разделения значений \fIioprio\fP используются
следующие макросы:
.TP 
\fBIOPRIO_PRIO_VALUE(\fP\fIclass\fP\fB, \fP\fIdata\fP\fB)\fP
Объединяет заданный класс планирования \fIclass\fP и приоритет (\fIdata\fP) в
значение \fIioprio\fP, которое возвращается как результат макроса.
.TP 
\fBIOPRIO_PRIO_CLASS(\fP\fImask\fP\fB)\fP
Из указанной маски \fImask\fP (значение \fIioprio\fP) возвращает значение класса
ввода\-вывода, то есть одно из значений: \fBIOPRIO_CLASS_RT\fP,
\fBIOPRIO_CLASS_BE\fP или \fBIOPRIO_CLASS_IDLE\fP.
.TP 
\fBIOPRIO_PRIO_DATA(\fP\fImask\fP\fB)\fP
Из указанной маски \fImask\fP (значение \fIioprio\fP) возвращает значение
приоритета (\fIdata\fP).
.PP
Подробней о классах планирования и приоритетах, а также о значении 0 в
\fIioprio\fP смотрите в разделе ЗАМЕЧАНИЯ.
.PP
Приоритеты ввода\-вывода поддерживаются при операциях чтения и синхронной
(\fBO_DIRECT\fP, \fBO_SYNC\fP) записи. Приоритеты ввода\-вывода не поддерживаются
при асинхронной записи, так как они вызываются вне контекста программы
засоряющей память, и поэтому приоритеты программы не применяются.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
При успешном выполнении \fBioprio_get\fP() возвращается значение \fIioprio\fP
процесса с самым высоким приоритетом ввода\-вывода из всех процессов,
подходящих под критерий, указанный в \fIwhich\fP и \fIwho\fP. При ошибке
возвращается \-1, а в \fIerrno\fP содержится код ошибки.
.PP
При успешном выполнении \fBioprio_set\fP() возвращается 0. При ошибке
возвращается \-1, а в \fIerrno\fP содержится код ошибки.
.SH ОШИБКИ
.TP 
\fBEINVAL\fP
Неправильное значение \fIwhich\fP или \fIioprio\fP. Обратитесь к разделу
ЗАМЕЧАНИЯ, в нём приведены доступные классы планировщика и уровни приоритета
\fIioprio\fP.
.TP 
\fBEPERM\fP
У вызывающего процесса нет прав, необходимых для назначения данного
\fIioprio\fP указанному процессу(ам). Более подробную информацию о необходимых
правах \fBioprio_set\fP() можно найти в разделе ЗАМЕЧАНИЯ.
.TP 
\fBESRCH\fP
Не найдено процессов, которые бы соответствовали заданным в \fIwhich\fP и
\fIwho\fP критериям.
.SH ВЕРСИИ
Данные системные вызовы появились в Linux начиная с ядра версии 2.6.13.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
Данные системные вызовы есть только в Linux.
.SH ЗАМЕЧАНИЯ
В glibc нет обёрточной функции для этих системных вызовов; вызывайте их с
помощью \fBsyscall\fP(2).
.PP
Два или более процесса или нити могут использовать общий контекст
ввода\-вывода. Это может происходить в случае, если вызывается \fBclone\fP(2) с
флагом \fBCLONE_IO\fP. Однако по умолчанию разные нити процесса \fBне\fP будут
использовать общий контекст ввода\-вывода. Это означает, что если вы хотите
изменить приоритет ввода\-вывода всех нитей процесса, то вам может
потребоваться вызвать \fBioprio_set\fP() для каждой нити. Идентификатор нити,
требуемый для этой операции, можно получить с помощью \fBgettid\fP(2) или
\fBclone\fP(2).
.PP
Данные системные вызовы действительно работают только, если используется
планировщик ввода\-вывода, поддерживающий приоритеты ввода\-вывода. В ядре
2.6.17 такой планировщик только один: Completely Fair Queuing (CFQ).
.PP
.\" commit 8ec680e4c3ec818efd1652f15199ed1c216ab550
Если для нити не был задан планировщик ввода\-вывода, то значением приоритета
ввода\-вывода будет значение уступчивости ЦП (\fBsetpriority\fP(2)). В ядрах
Linux до версии 2.6.24 после назначения приоритета ввода\-вывода с помощью
\fBioprio_set\fP() нет способа переустановить поведение планировщика
ввода\-вывода в значение по умолчанию. Начиная с Linux 2.6.24 для установки
поведения планировщика ввода\-вывода в значение по умолчанию можно указать
\fIioprio\fP значение 0.
.SS "Выбор планировщика ввода\-вывода"
Планировщики ввода\-вывода устанавливаются в каждом устройстве через
специальный файл \fI/sys/block/<устройство>/queue/scheduler\fP.
.PP
Используемый в данный момент планировщик ввода\-вывода можно посмотреть через
файловую систему \fI/sys\fP. Например, следующая команда покажет список всех
планировщиков, загруженных в ядро:
.PP
.in +4n
.EX
$\fB cat /sys/block/sda/queue/scheduler\fP
noop anticipatory deadline [cfq]
.EE
.in
.PP
Планировщик, работающий на устройстве (в примере \fIsda\fP), указан  в
скобках. Замена планировщика выполняется с помощью записи имени нового
планировщика в этот файл. Например, следующая команда установит планировщик
\fIcfq\fP для устройства \fIsda\fP:
.PP
.in +4n
.EX
$\fB su\fP
Password:
#\fB echo cfq > /sys/block/sda/queue/scheduler\fP
.EE
.in
.\"
.SS "Планировщик ввода\-вывода с полностью справедливой очерёдностью (CFQ)"
Начиная с версии 3 (т. н. CFQ Time Sliced) в CFQ реализованы уровни
уступчивости ввода\-вывода, подобно используемым в планировщике ЦП. Эти
уровни уступчивости сгруппированы в три класса планирования, в каждом
содержится один и более уровней приоритета:
.TP 
\fBIOPRIO_CLASS_RT\fP (1)
Класс ввода\-вывода реального времени. Данному классу планирования назначен
самый высокий приоритет по сравнению с другими: процессам с этим классом
всегда предоставляется первоочередной доступ к диску. Поэтому данный класс
следует использовать с осторожностью: одним процессом ввода\-вывода реального
времени можно затормозить все остальные. В классе реального времени есть 8
уровней данных класса (приоритетов), которые уточняют сколько времени нужно
процессу для работы с диском для каждого сервиса. Самый высокий уровень
приоритета реального времени имеет значение 0; самый низкий — 7. В будущем
это может измениться и можно будет непосредственно задавать желаемую
скорость обмена данными с диском.
.TP 
\fBIOPRIO_CLASS_BE\fP (2)
Класс лучшего из возможного (best\-effort) планирования, устанавливается по
умолчанию для всех процессов, которым не назначен определённый приоритет
ввода\-вывода. Данными класса (приоритет) определяется пропускная способность
ввода\-вывода процесса. Уровни приоритета данного класса аналогичны значениям
nice для ЦП (см. \fBgetpriority\fP(2)). Уровень приоритета определяет
первоочерёдность относительно других процессов с классом лучшего из
возможного планирования. Уровни приоритета находятся в диапазоне от 0 (самый
высший) до 7 (самый низший).
.TP 
\fBIOPRIO_CLASS_IDLE\fP (3)
Класс свободного (idle) планирования. Процессы, работающие с этим уровнем,
получат время для ввода\-вывода только когда нет обмена с диском процессов с
другими классами. Свободный класс не имеет данных класса. Обратите внимание,
что процесс с этим классом приоритета может испытывать нехватку ресурсов,
если процессы с более высокими приоритетами постоянно обращаются к диску.
.PP
Более подробную информацию о планировщике ввода\-вывода CFQ и пример
программы можно найти в файле исходного кода ядра
\fIDocumentation/block/ioprio.txt\fP.
.SS "Необходимые права для установки приоритетов ввода\-вывода"
Право на изменение приоритета процесса зависит от двух условий:
.TP 
\fBВладелец процесса\fP
Непривилегированный процесс может установить приоритет ввода\-вывода только
для процесса, чей реальный идентификатор совпадает с реальным или
эффективным идентификатором вызывающего процесса. Процесс с мандатом
\fBCAP_SYS_NICE\fP может изменять приоритет любого процесса.
.TP 
\fBТребуемый приоритет\fP
Попытка установить очень высокий приоритет (\fBIOPRIO_CLASS_RT\fP) требует
мандата \fBCAP_SYS_ADMIN\fP. Ядра версий до 2.6.24 также требуют мандата
\fBCAP_SYS_ADMIN\fP для установки очень низкого приоритета
(\fBIOPRIO_CLASS_IDLE\fP), но начиная с Linux 2.6.25 это отменено.
.PP
Вызов \fBioprio_set\fP() должен соблюдать оба правила, или он завершится с
ошибкой \fBEPERM\fP.
.SH ДЕФЕКТЫ
.\" 6 May 07: Bug report raised:
.\" http://sources.redhat.com/bugzilla/show_bug.cgi?id=4464
.\" Ulrich Drepper replied that he wasn't going to add these
.\" to glibc.
В glibc пока нет заголовочного файла, определяющего прототип и макросы,
описанные в этой странице. Нужные определения можно найти в
\fIlinux/ioprio.h\fP.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBionice\fP(1), \fBgetpriority\fP(2), \fBopen\fP(2), \fBcapabilities\fP(7),
\fBcgroups\fP(7)
.PP
Файл \fIDocumentation/block/ioprio.txt\fP в дереве исходного кода ядра Linux
