.\" -*- mode: troff; coding: UTF-8 -*-
.\" written by Andrew Morgan <morgan@kernel.org>
.\"
.\" %%%LICENSE_START(GPL_NOVERSION_ONELINE)
.\" may be distributed as per GPL
.\" %%%LICENSE_END
.\"
.\" Modified by David A. Wheeler <dwheeler@ida.org>
.\" Modified 2004-05-27, mtk
.\" Modified 2004-06-21, aeb
.\" Modified 2008-04-28, morgan of kernel.org
.\"     Update in line with addition of file capabilities and
.\"     64-bit capability sets in kernel 2.6.2[45].
.\" Modified 2009-01-26, andi kleen
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH CAPGET 2 2019\-03\-06 Linux "Руководство программиста Linux"
.SH ИМЯ
capget, capset \- установка/получение мандатов нити(ей)
.SH ОБЗОР
\fB#include <sys/capability.h>\fP
.PP
\fBint capget(cap_user_header_t \fP\fIhdrp\fP\fB, cap_user_data_t \fP\fIdatap\fP\fB);\fP
.PP
\fBint capset(cap_user_header_t \fP\fIhdrp\fP\fB, const cap_user_data_t
\fP\fIdatap\fP\fB);\fP
.SH ОПИСАНИЕ
Данные системные вызовы представляют собой низкоуровневый интерфейс ядра для
получения и установки мандатов нити. Кроме того, что эти системные вызовы
есть только в Linux, из\-за них, вероятно, изменится программный интерфейс
ядра; с каждой новой версией ядра эти вызовы используются всё чаще (в
частности, типы \fIcap_user_*_t\fP), но старые программы работают как и прежде.
.PP
.\"
Переносимыми интерфейсами являются \fBcap_set_proc\fP(3) и \fBcap_get_proc\fP(3);
если возможно, в приложениях используйте именно их.
.SS "Подробная информация"
На данный момент в ядре определены следующие структуры:
.PP
.in +4n
.EX
#define _LINUX_CAPABILITY_VERSION_1  0x19980330
#define _LINUX_CAPABILITY_U32S_1     1

.\" commit e338d263a76af78fe8f38a72131188b58fceb591
.\" Added 64 bit capability support
        /* V2 добавлена в Linux 2.6.25; устарело */
#define _LINUX_CAPABILITY_VERSION_2  0x20071026
#define _LINUX_CAPABILITY_U32S_2     2

.\" commit ca05a99a54db1db5bca72eccb5866d2a86f8517f
        /* V3 добавлена в Linux 2.6.26 */
#define _LINUX_CAPABILITY_VERSION_3  0x20080522
#define _LINUX_CAPABILITY_U32S_3     2

typedef struct __user_cap_header_struct {
   __u32 version;
   int pid;
} *cap_user_header_t;

typedef struct __user_cap_data_struct {
   __u32 effective;
   __u32 permitted;
   __u32 inheritable;
} *cap_user_data_t;
.EE
.in
.PP
Поля \fIeffective\fP, \fIpermitted\fP и \fIinheritable\fP — это битовые маски
мандатов, определённых в \fBcapabilities\fP(7). Заметим, что значения \fBCAP_*\fP
являются индексами битов и требуется сдвиг битов перед выполнением операции
ИЛИ над битовыми полями. Чтобы определить структуры для передачи в системный
вызов, используйте имена \fIstruct __user_cap_header_struct\fP и \fIstruct
__user_cap_data_struct\fP, так как посредством typedef описаны только
указатели.
.PP
Ядра до версии 2.6.25 предъявляют 32\-битные мандаты с версией
\fB_LINUX_CAPABILITY_VERSION_1\fP. В Linux 2.6.25+ добавлены 64\-битные наборы
мандатов с версией \fB_LINUX_CAPABILITY_VERSION_2\fP. Однако имеется
незначительная проблема в программном интерфейсе и в Linux 2.6.26 добавлена
\fB_LINUX_CAPABILITY_VERSION_3\fP для её исправления.
.PP
Заметим, что в 64\-битных мандатах используются \fIdatap\fP[0] и \fIdatap\fP[1], в
то время как в 32\-битных только \fIdatap\fP[0].
.PP
В ядрах, которые поддерживают файловые мандаты (поддержка мандатов VFS) эти
системные вызовы ведут себя немного по\-другому. Данная поддержка добавлена
как необязательная в Linux 2.6.24 и стала постоянной (не отключаемой) в
Linux 2.6.33.
.PP
С помощью вызова \fBcapget\fP() можно выполнить проверку мандатов любого
процесса, указав его ID в поле \fIhdrp\->pid\fP.
.PP
.\"
Подробную информацию о данных смотрите в \fBcapabilities\fP(7).
.SS "Ядро с поддержкой мандатов VFS"
.\"
Для мандатов VFS используется расширенный атрибут файла (смотрите
\fBxattr\fP(7)), позволяющий присоединять мандаты к исполняемым файлам. Данная
модель привилегий делает устаревшей ядерную поддержку асинхронного
назначения мандатов одного процесса другому. То есть в ядрах с мандатами VFS
при вызове \fBcapset\fP() разрешены только значения \fIhdrp\->pid\fP равные 0
или \fBgettid\fP(2), что приводит к тому же результату.
.SS "Ядро без поддержки мандатов VFS"
В старых ядрах без поддержки мандатов VFS вызов \fBcapset\fP(), если вызывающий
имеет мандат \fBCAP_SETPCAP\fP, можно использовать для изменения не только
собственными мандатами вызывающего, то и мандатами других нитей. Вызов
работает с мандатами нити, указанной в в поле \fIpid\fP из \fIhdrp\fP, если оно не
равно нулю, или мандатами вызывающей нити, когда \fIpid\fP равно 0. Если \fIpid\fP
указывает на процесс с одной нитью, то значением \fIpid\fP может быть обычным
идентификатором процесса; работа с нитью в многонитиевом процессе требует ID
нити такого же типа, что и возвращается \fBgettid\fP(2). У \fBcapset\fP() \fIpid\fP
также может быть: \-1 — выполнить изменение у всех нитей, за исключением
вызывающей и \fBinit\fP(1); меньше \-1 — выполнить изменение всех членов группы
процесса, чей ID равен \-\fIpid\fP.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
При успешном выполнении возвращается 0. В случае ошибки возвращается \-1, а
\fIerrno\fP устанавливается в соответствующее значение.
.PP
Вызовы завершаются с ошибкой \fBEINVAL\fP и изменяют поле \fIversion\fP в \fIhdrp\fP
на предпочитаемое ядром значение \fB_LINUX_CAPABILITY_VERSION_?\fP, если
указано неподдерживаемое значение \fIversion\fP. Таким способом можно проверить
какая версия мандатов является предпочтительной.
.SH ОШИБКИ
.TP 
\fBEFAULT\fP
Неправильный адрес памяти. Значение \fIhdrp\fP не должно быть равно
NULL. Значение \fIdatap\fP может быть NULL только, когда пользователь пытается
определить предпочтительную версию формата мандатов, поддерживаемую ядром.
.TP 
\fBEINVAL\fP
Один из аргументов неправилен.
.TP 
\fBEPERM\fP
Была сделана попытка добавить мандат к списку разрешённых, эффективных или
унаследованных мандатов, но это не разрешено согласно списку разрешённых.
.TP 
\fBEPERM\fP
Вызывающий процесс пытается использовать \fBcapset\fP() для изменения мандатов
не своей нити, но ему не хватает на это прав. Для ядер, поддерживающих
мандаты VFS, это всегда запрещено. Для ядер без поддержки VFS требуется
мандат \fBCAP_SETPCAP\fP. (Неправильная работа ядер до версии 2.6.11 приводила
к тому, что эта ошибка также возникала, если нить без данного мандата
пыталась изменить свои собственные мандаты, указывая в поле \fIpid\fP ненулевое
значение (т.е. значение, возвращаемое \fBgetpid\fP(2)), а не 0).
.TP 
\fBESRCH\fP
Такой нити нет.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
Данные системные вызовы есть только в Linux.
.SH ЗАМЕЧАНИЯ
Переносимый интерфейс для запроса и установки мандатов предоставляется
библиотекой \fIlibcap\fP, которая доступна по адресу:
.br
.UR http://git.kernel.org/cgit\:/linux\:/kernel\:/git\:/morgan\:\:/libcap.git
.UE
.SH "СМОТРИТЕ ТАКЖЕ"
\fBclone\fP(2), \fBgettid\fP(2), \fBcapabilities\fP(7)
