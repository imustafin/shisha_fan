.\" -*- mode: troff; coding: UTF-8 -*-
.\" This man page is Copyright (C) 1998 Pawel Krawczyk.
.\"
.\" %%%LICENSE_START(VERBATIM_ONE_PARA)
.\" Permission is granted to distribute possibly modified copies
.\" of this page provided the header is included verbatim,
.\" and in case of nontrivial modification author and date
.\" of the modification is added to the header.
.\" %%%LICENSE_END
.\"
.\" $Id: sendfile.2,v 1.5 1999/05/18 11:54:11 freitag Exp $
.\" 2000-11-19 bert hubert <ahu@ds9a.nl>: in_fd cannot be socket
.\"
.\" 2004-12-17, mtk
.\"	updated description of in_fd and out_fd for 2.6
.\"	Various wording and formatting changes
.\"
.\" 2005-03-31 Martin Pool <mbp@sourcefrog.net> mmap() improvements
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH SENDFILE 2 2017\-09\-15 Linux "Руководство программиста Linux"
.SH ИМЯ
sendfile \- производит обмен данными между дескрипторами файлов
.SH ОБЗОР
\fB#include <sys/sendfile.h>\fP
.PP
.\" The below is too ugly. Comments about glibc versions belong
.\" in the notes, not in the header.
.\"
.\" .B #include <features.h>
.\" .br
.\" .B #if (__GLIBC__==2 && __GLIBC_MINOR__>=1) || __GLIBC__>2
.\" .br
.\" .B #include <sys/sendfile.h>
.\" .br
.\" #else
.\" .br
.\" .B #include <sys/types.h>
.\" .br
.\" .B /* No system prototype before glibc 2.1. */
.\" .br
.\" .BI "ssize_t sendfile(int" " out_fd" ", int" " in_fd" ", off_t *" \
.\"                       offset ", size_t" " count" )
.\" .br
.\" .B #endif
.\"
\fBssize_t sendfile(int\fP\fI out_fd\fP\fB, int\fP\fI in_fd\fP\fB, off_t *\fP\fIoffset\fP\fB,
size_t\fP\fI count\fP\fB);\fP
.SH ОПИСАНИЕ
Вызов \fBsendfile\fP() копирует данные из одного файлового дескриптора в
другой. Так как копирование производится в ядре, использование \fBsendfile\fP()
более эффективно чем комбинация \fBread\fP(2) и \fBwrite\fP(2), в которой
требуется скопировать данные в и из пользовательского пространства.
.PP
В \fIin_fd\fP должен указываться файловый дескриптор, открытый для чтения, а в
\fIout_fd\fP должен указываться файловый дескриптор, открытый для записи.
.PP
Если значение \fIoffset\fP не равно NULL, то оно указывает на переменную,
содержащую файловое смещение с которого \fBsendfile\fP() начнёт чтение данных
из \fIin_fd\fP. При завершении \fBsendfile\fP() значение этой переменной будет
содержать смещение следующего байта после последнего прочитанного. Если
значение \fIoffset\fP не равно NULL, то \fBsendfile\fP() не изменяет файловое
смещение \fIin_fd\fP; иначе файловое смещение изменяется для отражения
количества прочитанных из \fIin_fd\fP байт.
.PP
Если значение \fIoffset\fP равно NULL, то данные будут прочитаны из \fIin_fd\fP
начиная с файлового смещения, и по окончании работы вызова файловое смещение
будет обновлено.
.PP
В \fIcount\fP содержится количество байт, копируемых между файловыми
дескрипторами.
.PP
Значение \fIin_fd\fP должно описывать файл, который поддерживает операции типа
\fBmmap\fP(2) (т.е., не сокет).
.PP
В ядрах Linux до версии 2.6.33, значение \fIout_fd\fP должно указывать на
сокет. Начиная с Linux 2.6.33 можно указывать любой файл. Если это обычный
файл, то \fBsendfile\fP() изменит файловое смещение соответствующим образом.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
Если пересылка прошла успешно, то возвращается количество записанных в
\fIout_fd\fP байт. Заметим, что при успешном выполнении вызов \fBsendfile\fP()
может записать меньше байт, чем запрашивалось; вызывающий должен быть готов
повторить вызов, если останутся не отправленные байты. Также смотрите
ЗАМЕЧАНИЯ.
.PP
В случае ошибки возвращается \-1 и значение \fIerrno\fP устанавливается
соответствующим образом.
.SH ОШИБКИ
.TP 
\fBEAGAIN\fP
Был выбран неблокирующий ввод\-вывод с помощью \fBO_NONBLOCK\fP, но запись
привела бы блокировке.
.TP 
\fBEBADF\fP
Входной файл не открыт для чтения или выходной файл не открыт для записи.
.TP 
\fBEFAULT\fP
Неправильный адрес.
.TP 
\fBEINVAL\fP
Неправильный или заблокированный дескриптор, или для \fIin_fd\fP недоступна
операция типа \fBmmap\fP(2) или значение \fIcount\fP отрицательно.
.TP 
\fBEINVAL\fP
У \fIout_fd\fP установлен флаг \fBO_APPEND\fP. Пока это не поддерживается в
\fBsendfile\fP().
.TP 
\fBEIO\fP
Неизвестная ошибка при чтении \fIin_fd\fP.
.TP 
\fBENOMEM\fP
Не хватает памяти для чтения \fIin_fd\fP.
.TP 
\fBEOVERFLOW\fP
Значение \fIcount\fP слишком велико, операция вернула бы результат, превышающий
максимальный размер входного или выходного файла.
.TP 
\fBESPIPE\fP
Значение \fIoffset\fP не равно NULL, но для входного файла не работает
\fBseek\fP(2).
.SH ВЕРСИИ
Вызов \fBsendfile\fP() впервые появился в Linux 2.2. Файл заголовков
\fI<sys/sendfile.h>\fP появился в glibc 2.1.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
Отсутствует в POSIX.1\-2001 и других стандартах.
.PP
В других системах UNIX вызов \fBsendfile\fP() реализован с другими семантиками
и прототипами. Не должен использоваться в переносимых программах.
.SH ЗАМЕЧАНИЯ
.\" commit e28cc71572da38a5a12c1cfe4d7032017adccf69
Вызов \fBsendfile\fP() передаст не больше 0x7ffff000 (2 147 479 552) байт,
возвращая число байт, переданных на самом деле (это утверждение справедливо
как к 32\-битным, так и к 64\-битным системам).
.PP
Если вы планируете использовать \fBsendfile\fP() для отправки файлов через
сокет TCP и вам нужно послать некоторые заголовочные данные перед содержимым
файла, то обратите внимание на параметр \fBTCP_CORK\fP, описанный в \fBtcp\fP(7),
он поможет минимизировать количество пакетов и оптимизировать
производительность.
.PP
В Linux 2.4 и более ранних, значение \fIout_fd\fP может также указывать на
обычный файл; эта возможность была удалена в ядрах Linux 2.6.x, но
возвращена в 2.6.33.
.PP
Первоначальная версия Linux \fBsendfile\fP() не была приспособлена для работы с
большими файловыми смещениями. В последствии в Linux 2.4 был добавлен вызов
\fBsendfile64\fP() с более широким диапазоном значений аргумента \fIoffset\fP. В
glibc \fBsendfile\fP() представляет собой обёрточную функцию, которая делает
незаметным разницу между версиями ядер.
.PP
Приложение может попытаться воспользоваться \fBread\fP(2)/\fBwrite\fP(2), если
вызов \fBsendfile\fP() завершится с ошибкой \fBEINVAL\fP или \fBENOSYS\fP.
.PP
Если \fIout_fd\fP ссылается на сокет или канал с поддержкой нулевого
копирования, то вызывающие должны гарантировать, что переданные части файла,
указываемого \fIin_fd\fP, останутся неизменёнными до тех пор, пока читающий на
другом конце \fIout_fd\fP не закончит обрабатывать переданные данные.
.PP
Специальный вызов Linux \fBsplice\fP(2) поддерживает пересылку данных между
произвольными файловыми дескрипторами, представляющими сокеты (один или
оба).
.SH "СМОТРИТЕ ТАКЖЕ"
\fBcopy_file_range\fP(2), \fBmmap\fP(2), \fBopen\fP(2), \fBsocket\fP(2), \fBsplice\fP(2)
