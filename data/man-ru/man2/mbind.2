.\" -*- mode: troff; coding: UTF-8 -*-
.\" Copyright 2003,2004 Andi Kleen, SuSE Labs.
.\" and Copyright 2007 Lee Schermerhorn, Hewlett Packard
.\"
.\" %%%LICENSE_START(VERBATIM_PROF)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"
.\" 2006-02-03, mtk, substantial wording changes and other improvements
.\" 2007-08-27, Lee Schermerhorn <Lee.Schermerhorn@hp.com>
.\"	more precise specification of behavior.
.\"
.\" FIXME
.\" Linux 3.8 added MPOL_MF_LAZY, which needs to be documented.
.\" Does it also apply for move_pages()?
.\"
.\"                commit b24f53a0bea38b266d219ee651b22dba727c44ae
.\"                Author: Lee Schermerhorn <lee.schermerhorn@hp.com>
.\"                Date:   Thu Oct 25 14:16:32 2012 +0200
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH MBIND 2 2017\-09\-15 Linux "Руководство программиста Linux"
.SH ИМЯ
mbind \- устанавливает политику на область памяти
.SH ОБЗОР
.nf
\fB#include <numaif.h>\fP
.PP
\fBlong mbind(void *\fP\fIaddr\fP\fB, unsigned long \fP\fIlen\fP\fB, int \fP\fImode\fP\fB,\fP
\fB           const unsigned long *\fP\fInodemask\fP\fB, unsigned long \fP\fImaxnode\fP\fB,\fP
\fB           unsigned \fP\fIflags\fP\fB);\fP
.PP
Компонуется при указании параметра \fI\-lnuma\fP.
.fi
.SH ОПИСАНИЕ
Вызов \fBmbind\fP() устанавливает политику памяти NUMA, состоящую из режима
политики и нуля или более узлов, на область памяти, начинающуюся с \fIaddr\fP и
длиной \fIlen\fP байт. Политикой памяти задаётся на каком узле будет выделяться
память.
.PP
Если область памяти, заданная аргументами \fIaddr\fP и \fIlen\fP, включает
«анонимную» область памяти — область памяти, созданную с помощью системного
вызова \fBmmap\fP(2) с аргументом \fBMAP_ANONYMOUS\fP — или файл, отображённый в
память с помощью вызова \fBmmap\fP(2) с флагом \fBMAP_PRIVATE\fP, то страницы
будут выделены в соответствии с указанной политикой только когда приложение
выполняет запись (сохранение) страницы. Для анонимных областей при
первоначальном доступе на чтение будет использоваться общая страница ядра,
содержащая только нули. Для отображённого файла с флагом \fBMAP_PRIVATE\fP, при
первоначальном доступе на чтение будут выделены страницы в соответствии с
политикой памяти нити, для которой происходит выделение страницы. Это может
быть не та нить, которая вызвала \fBmbind\fP().
.PP
Указанная политика в заданной области памяти будет игнорироваться для всех
отображений \fBMAP_SHARED\fP. Скорее всего, страницы будут выделены согласно
политике памяти нити, для которой происходит выделение страницы. Но опять
таки, это может быть не та нить, которая вызвала \fBmbind\fP().
.PP
Если заданная область памяти включает общую область памяти, созданную с
помощью системного вызова \fBshmget\fP(2) и подключённую с помощью системного
вызова \fBshmat\fP(2), то страницы, выделяемые для анонимной или общей области
памяти, будут выделены согласно указанной политике, независимо от того,
какой процесс подключил сегмент общей памяти, что вызвало выделение. Однако,
если общая область памяти была создана с флагом \fBSHM_HUGETLB\fP, то огромные
страницы будут выделяться согласно указанной политике, только если выделение
страницы происходит из\-за процесса, который вызвал \fBmbind\fP() для этой
области.
.PP
По умолчанию, \fBmbind\fP() учитывается только при новых выделениях; если
страницы внутри области уже были использованы до настройки политики, то
политика не применяется. Такое поведение можно изменить с помощью флагов
\fBMPOL_MF_MOVE\fP и \fBMPOL_MF_MOVE_ALL\fP, описанных далее.
.PP
В  аргументе \fImode\fP должно быть указано одно из следующих значений:
\fBMPOL_DEFAULT\fP, \fBMPOL_BIND\fP, \fBMPOL_INTERLEAVE\fP, \fBMPOL_PREFERRED\fP или
\fBMPOL_LOCAL\fP (описано далее). Для всех режимов политики, за исключением
\fBMPOL_DEFAULT\fP, требуется, чтобы вызывающий указывал в аргументе
\fInodemask\fP узел или узлы, для которых применяется режим.
.PP
Аргумент \fImode\fP также может содержать необязательный \fIфлаг
режима\fP. Поддерживаемые \fIфлаги режима\fP:
.TP 
\fBMPOL_F_STATIC_NODES\fP (начиная с Linux\-2.6.26)
В аргументе \fInodemask\fP указываются идентификаторы физических узлов. Linux
не пересоставляет \fInodemask\fP, если нить перемещается в другой контекст
набора процессоров или когда изменяется набор узлов, который доступен нити
согласно текущему контексту набора процессоров.
.TP 
\fBMPOL_F_RELATIVE_NODES\fP (начиная с Linux\-2.6.26)
В аргументе \fInodemask\fP указываются идентификаторы узлов из набора
идентификаторов узлов, разрешённых нити текущим контекстом набора
процессоров.
.PP
В \fInodemask\fP содержится битовая маска узлов, в которой содержится до
\fImaxnode\fP бит. Размер битовой маски округляется до следующего кратного
значения \fIsizeof(unsigned long)\fP, но ядром будет использовано только до
\fImaxnode\fP бит. Значением NULL в \fInodemask\fP или значением \fImaxnode\fP равным
0 задаётся пустой набор узлов. Если значение \fImaxnode\fP равно 0, то аргумент
\fInodemask\fP игнорируется. Там, где требуется \fInodemask\fP, его значение
должно содержать, как минимум, один работающий узел, который разрешён нити
текущим контекстом набора процессоров (если не указан флаг
\fBMPOL_F_STATIC_NODES\fP) и у которого имеется память.
.PP
Аргумент \fImode\fP должен включать одно из следующих значений:
.TP 
\fBMPOL_DEFAULT\fP
Этот режим запрашивает удаление любой политики не по умолчанию и
восстановление поведения по умолчанию. Если он применяется к области памяти
посредством \fBmbind\fP(), то это означает использование политики памяти нити,
которая могла быть установлена с помощью \fBset_mempolicy\fP(2). Если режим
политики памяти нити также равен \fBMPOL_DEFAULT\fP, то будет задействована
системная политика по умолчанию. При системной политике по умолчанию
выделяются страницы на том узле ЦП, на котором было запрошено выделение. Для
\fBMPOL_DEFAULT\fP в аргументах \fInodemask\fP и \fImaxnode\fP должен быть указан
пустой набор узлов.
.TP 
\fBMPOL_BIND\fP
.\" commit 19770b32609b6bf97a3dece2529089494cbfc549
Этот режим задаёт жёсткую политику, при которой выделение памяти ограничено
узлами, заданными в \fInodemask\fP. Если в \fInodemask\fP указано более одного
узла, то выделение страниц начнётся с узла с достаточным объёмом свободной
памяти, который наиболее близок к узлу, где запрошено выделение. Страницы не
выделяются на узлах, не указанных в IR nodemask(до Linux 2.6.26 выделение
страниц происходило начиная с узла с меньшим номером идентификатора, и
продолжится до тех пор, пока на нём не кончится свободная память. Затем
выделение продолжится на узле со следующим большим номером идентификатора,
указанного в \fInodemask\fP, и т.д. до тех пор, пока на всех заданных узлах не
закончится свободная память).
.TP 
\fBMPOL_INTERLEAVE\fP
Этот режим задаёт, что при выделении страниц нужно выполнять чередование
узлов, которые указаны в \fInodemask\fP. Это оптимизирует использование полосы
пропускания, но не задержку, вовлекая при доступ к страницам и памяти
множество узлов. Чтобы это дало эффект, область памяти должна быть
достаточно большой, не менее 1\ МБ или более, и характер доступа должен быть
достаточно равномерным. Доступ к одной странице области будет по прежнему
ограничен размером полосы пропускания одного узла.
.TP 
\fBMPOL_PREFERRED\fP
В этом режиме устанавливается предпочтительный узел для выделения. Ядро
сначала будет пытаться выделить страницы на этом узле и перейдёт на другие
узлы, если на предпочтительном узле недостаточно свободной памяти. Если в
\fInodemask\fP задано более одного идентификатора узла, то в качестве
предпочтительного будет выбран первый из маски. Если в аргументах
\fInodemask\fP и \fImaxnode\fP указан пустой набор, то память будет выделена на
узле ЦП, на котором запросили выделение.
.TP 
\fBMPOL_LOCAL\fP (начиная с Linux 3.8)
.\" commit 479e2802d09f1e18a97262c4c6f8f17ae5884bd8
.\" commit f2a07f40dbc603c15f8b06e6ec7f768af67b424f
Этот режим устанавливает «локальное выделение»; памяти выделяется на узле с
ЦП, на котором запросили выделение («локальный узел»). Аргументы \fInodemask\fP
и \fImaxnode\fP должны содержать пустой набор. Если на «локальном узле» не
хватает свободной памяти, то ядро попытается выделить память на других
узлах. Ядро выделит памяти на «локальном узле» сколько бы ни было на нём
памяти. Если «локальный узел» не разрешён для нити текущим контекстом набора
процессоров, то ядро попытается выделить память на других узлах. Ядро
выделит памяти на «локальном узле» независимо от того, станет ли он
разрешённым для нити текущим контекстом набора процессоров. В отличии от
этого , \fBMPOL_DEFAULT\fP восстанавливает политику памяти нити (которая может
быть задана с помощью \fBset_mempolicy\fP(2)); эта политика может быть другой,
не «локальным выделением».
.PP
.\" According to the kernel code, the following is not true
.\" --Lee Schermerhorn
.\" In 2.6.16 or later the kernel will also try to move pages
.\" to the requested node with this flag.
Если в \fIflags\fP указан \fBMPOL_MF_STRICT\fP и \fImode\fP не равно \fBMPOL_DEFAULT\fP,
то вызов завершается ошибкой \fBEIO\fP, если существующие страницы в области
памяти не следуют политике.
.PP
Если в \fIflags\fP указан \fBMPOL_MF_MOVE\fP, то ядро будет пытаться переместить
все существующие страницы в области памяти так, чтобы они следовали
политике. Страницы, используемые совместно с другими процессами,
перемещаться не будут. Если также указан \fBMPOL_MF_STRICT\fP, что вызов
завершается ошибкой \fBEIO\fP, если страницы не могут быть перемещены.
.PP
.\" ---------------------------------------------------------------
Если в \fIflags\fP указан \fBMPOL_MF_MOVE_ALL\fP, то ядро будет пытаться
переместить все существующие страницы в области памяти независимо от того,
используются ли они другими процессами. Для использования данного флага
вызывающая нить должна быть привилегированной (\fBCAP_SYS_NICE\fP). Если также
указан \fBMPOL_MF_STRICT\fP, то вызов завершается ошибкой \fBEIO\fP, если
некоторые страницы нельзя переместить.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
.\" ---------------------------------------------------------------
При успешном выполнении \fBmbind\fP() возвращается 0. При ошибке возвращается
\-1, а в \fIerrno\fP содержится код ошибки.
.SH ОШИБКИ
.\"  I think I got all of the error returns.  --Lee Schermerhorn
.TP 
\fBEFAULT\fP
Часть или вся область памяти, заданная в \fInodemask\fP и \fImaxnode\fP, указывает
за пределы доступного адресного пространства. Или в области памяти,
задаваемой \fIaddr\fP и \fIlen\fP, есть неотображаемая дыра (hole).
.TP 
\fBEINVAL\fP
.\" As at 2.6.23, this limit is "a page worth of bits", e.g.,
.\" 8 * 4096 bits, assuming a 4kB page size.
В \fIflags\fP или \fImode\fP указано неправильное значение; или \fIaddr + len\fP
меньше чем \fIaddr\fP; или \fIaddr\fP не кратен системному размеру страницы. Или
\fImode\fP равен \fBMPOL_DEFAULT\fP и в \fInodemask\fP задан непустой набор; или
\fImode\fP равен \fBMPOL_BIND\fP или \fBMPOL_INTERLEAVE\fP и значение \fInodemask\fP
пусто. Или значение \fImaxnode\fP превышает устанавливаемое ядром
ограничение. Или в \fInodemask\fP задан один или более идентификаторов узлов,
номер которого больше чем максимально поддерживаемый. Или в \fInodemask\fP не
задано ни одного идентификатора узла, включённого в данный момент и
разрешённого нити текущим контекстом набора процессоров, или ни один из
указанных узлов не содержит память. Или в аргументе \fImode\fP указаны сразу
\fBMPOL_F_STATIC_NODES\fP и \fBMPOL_F_RELATIVE_NODES\fP.
.TP 
\fBEIO\fP
Был указан \fBMPOL_MF_STRICT\fP и существующая страница была уже на узле, что
не следует политике; или был указан \fBMPOL_MF_MOVE\fP или \fBMPOL_MF_MOVE_ALL\fP
и ядро не смогло переместить все существующие страницы области.
.TP 
\fBENOMEM\fP
Недостаточное количество памяти ядра.
.TP 
\fBEPERM\fP
.\" ---------------------------------------------------------------
Аргумент \fIflags\fP содержит флаг \fBMPOL_MF_MOVE_ALL\fP и вызывающий не имеет
мандата \fBCAP_SYS_NICE\fP.
.SH ВЕРСИИ
Системный вызов \fBmbind\fP() был добавлен в ядро Linux версии 2.6.7.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
Данный вызов есть только в Linux.
.SH ЗАМЕЧАНИЯ
Информация о библиотеке доступна в \fBnuma\fP(7).
.PP
Политика NUMA не поддерживается для области памяти отображения файла,
который отображён с флагом \fBMAP_SHARED\fP.
.PP
Режим \fBMPOL_DEFAULT\fP может по разному влиять на \fBmbind\fP() и
\fBset_mempolicy\fP(2). Когда указан \fBMPOL_DEFAULT\fP для \fBset_mempolicy\fP(2),
политика памяти нити возвращается к политике по умолчанию или локальному
выделению. Когда \fBMPOL_DEFAULT\fP указан для области памяти, используемой
\fBmbind\fP(), все страницы, последовательно выделяемые для этой области, будут
использовать политику памяти нити, которая задана с помощью
\fBset_mempolicy\fP(2). Это эффективно удаляет явную политику из указанной
области, «откатываясь» к возможной политике не по умолчанию. Для выбора
явного «локального выделения» области памяти, укажите в \fImode\fP значение
\fBMPOL_LOCAL\fP или \fBMPOL_PREFERRED\fP с пустым набором узлов. Этот метод также
сработает и в вызове \fBset_mempolicy\fP(2).
.PP
Поддержка политики для огромных страниц была добавлена в версию 2.6.16. Для
эффективной работы политики чередования на огромных страничных отображениях,
контролируемая память должна измеряться десятками мегабайт или больше.
.PP
Режим \fBMPOL_MF_STRICT\fP игнорируется для огромных страничных отображений.
.PP
Режимы \fBMPOL_MF_MOVE\fP и \fBMPOL_MF_MOVE_ALL\fP доступны только в Linux 2.6.16
и новее.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBget_mempolicy\fP(2), \fBgetcpu\fP(2), \fBmmap\fP(2), \fBset_mempolicy\fP(2),
\fBshmat\fP(2), \fBshmget\fP(2), \fBnuma\fP(3), \fBcpuset\fP(7), \fBnuma\fP(7),
\fBnumactl\fP(8)
