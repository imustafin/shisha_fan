.\" -*- mode: troff; coding: UTF-8 -*-
.\" Copyright (c) 1992 Drew Eckhardt <drew@cs.colorado.edu>, March 28, 1992
.\" and Copyright (c) Michael Kerrisk, 2001, 2002, 2005, 2013
.\"
.\" %%%LICENSE_START(GPL_NOVERSION_ONELINE)
.\" May be distributed under the GNU General Public License.
.\" %%%LICENSE_END
.\"
.\" Modified by Michael Haardt <michael@moria.de>
.\" Modified 24 Jul 1993 by Rik Faith <faith@cs.unc.edu>
.\" Modified 21 Aug 1994 by Michael Chastain <mec@shell.portal.com>:
.\"   New man page (copied from 'fork.2').
.\" Modified 10 June 1995 by Andries Brouwer <aeb@cwi.nl>
.\" Modified 25 April 1998 by Xavier Leroy <Xavier.Leroy@inria.fr>
.\" Modified 26 Jun 2001 by Michael Kerrisk
.\"     Mostly upgraded to 2.4.x
.\"     Added prototype for sys_clone() plus description
.\"	Added CLONE_THREAD with a brief description of thread groups
.\"	Added CLONE_PARENT and revised entire page remove ambiguity
.\"		between "calling process" and "parent process"
.\"	Added CLONE_PTRACE and CLONE_VFORK
.\"	Added EPERM and EINVAL error codes
.\"	Renamed "__clone" to "clone" (which is the prototype in <sched.h>)
.\"	various other minor tidy ups and clarifications.
.\" Modified 26 Jun 2001 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"	Updated notes for 2.4.7+ behavior of CLONE_THREAD
.\" Modified 15 Oct 2002 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"	Added description for CLONE_NEWNS, which was added in 2.4.19
.\" Slightly rephrased, aeb.
.\" Modified 1 Feb 2003 - added CLONE_SIGHAND restriction, aeb.
.\" Modified 1 Jan 2004 - various updates, aeb
.\" Modified 2004-09-10 - added CLONE_PARENT_SETTID etc. - aeb.
.\" 2005-04-12, mtk, noted the PID caching behavior of NPTL's getpid()
.\"	wrapper under BUGS.
.\" 2005-05-10, mtk, added CLONE_SYSVSEM, CLONE_UNTRACED, CLONE_STOPPED.
.\" 2005-05-17, mtk, Substantially enhanced discussion of CLONE_THREAD.
.\" 2008-11-18, mtk, order CLONE_* flags alphabetically
.\" 2008-11-18, mtk, document CLONE_NEWPID
.\" 2008-11-19, mtk, document CLONE_NEWUTS
.\" 2008-11-19, mtk, document CLONE_NEWIPC
.\" 2008-11-19, Jens Axboe, mtk, document CLONE_IO
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH CLONE 2 2019\-08\-02 Linux "Руководство программиста Linux"
.SH ИМЯ
clone, __clone2 \- создать процесс\-потомок
.SH ОБЗОР
.nf
/* Прототип обёрточной функции glibc */
.PP
\fB#define _GNU_SOURCE\fP
\fB#include <sched.h>\fP
.PP
\fBint clone(int (*\fP\fIfn\fP\fB)(void *), void *\fP\fIchild_stack\fP\fB,\fP
\fB          int \fP\fIflags\fP\fB, void *\fP\fIarg\fP\fB, ... \fP
\fB          /* pid_t *\fP\fIptid\fP\fB, void *\fP\fInewtls\fP\fB, pid_t *\fP\fIctid\fP\fB */ );\fP
.PP
/* для прототипа неструктурированного системного вызова, смотрите ЗАМЕЧАНИЯ */
.fi
.SH ОПИСАНИЕ
Вызов \fBclone\fP() создаёт новый процесс подобно \fBfork\fP(2).
.PP
Здесь описана обёрточная функция glibc \fBclone\fP() и используемый ею
системный вызов. В основном, описывается обёрточная функция;отличия от
системного вызова приводятся в конце данной справочной страницы.
.PP
В отличие от \fBfork\fP(2), \fBclone\fP() позволяет процессу\-потомку использовать
некоторые части контекста выполнения совместно с вызывающим процессом,
например: виртуальное адресное пространство, таблица файловых дескрипторов и
таблица обработчиков сигналов. Заметим, что в данной справочной странице
«вызывающий процесс» обычно соответствует «родительскому процессу». Но
смотрите ниже описание \fBCLONE_PARENT\fP.
.PP
Одним из вариантов использования вызова \fBclone\fP() является реализация
нитей: несколько потоков управления в программе, выполняющиеся одновременно
в общем адресном пространстве.
.PP
Когда процесс\-потомок создаётся с помощью \fBclone\fP(), он начинает выполнение
с вызова функции, на которую указывает \fIfn\fP (это отличается от \fBfork\fP(2),
где выполнение продолжается в потомке от точки вызова \fBfork\fP(2)). Аргумент
\fIarg\fP передаётся в функцию \fIfn\fP.
.PP
Когда происходит возврат из функции \fIfn\fP(\fIarg\fP) процесс\-потомок
завершается. Целое значение, возвращаемое \fIfn\fP, является состоянием выхода
процесса\-потомка. Процесс\-потомок может также быть завершён явным образом с
помощью вызова \fBexit\fP(2) или после получения завершающего сигнала.
.PP
Аргумент \fIchild_stack\fP задаёт положение стека, используемого
процессом\-потомком. Так как процесс\-потомок и вызывающий процесс могут
использовать общую память, процесс\-потомок не может выполняться в том же
стеке, что и вызывающий процесс. Поэтому вызывающий процесс должен
установить пространство памяти для стека процесса\-потомка и передать
указатель на это пространство в вызове \fBclone\fP(). Стеки растут вниз для
всех процессоров, на которых работает Linux (за исключением процессоров HP
PA), так что \fIchild_stack\fP, обычно, указывает на наибольший адрес в
пространстве памяти, которое устанавливается для стека процесса\-потомка.
.PP
Младший байт \fIflags\fP содержит номер \fIсигнала завершения\fP, который
посылается родителю, когда работа потомка завершается. Если этот сигнал
задаётся как нечто отличное от \fBSIGCHLD\fP, то родительский процесс должен
задать параметр \fB__WALL\fP или \fB__WCLONE\fP при ожидании завершения работы
потомка с помощью вызова \fBwait\fP(2). Если никакой сигнал не задан, то
родительский процесс не извещается сигналом, когда потомок завершается.
.PP
Аргумент \fIflags\fP состоит из одной или более данных ниже констант, которые
складываются по правилам битового сложения (OR). Флагами задаёт что будет
общим между вызывающим процессом и процессом\-потомком:
.TP 
\fBCLONE_CHILD_CLEARTID\fP (начиная с Linux 2.5.49)
Очистить (обнулить) идентификатор (ID) нити потомка, расположенный в \fIctid\fP
в памяти потомка, если потомок существует, и активизировать futex по этому
адресу. Соответствующий адрес может быть изменён системным вызовом
\fBset_tid_address\fP(2). Используется в библиотеках работы с нитями.
.TP 
\fBCLONE_CHILD_SETTID\fP (начиная с Linux 2.5.49)
Сохранить ID нити потомка в указанном \fIctid\fP месте в памяти
потомка. Операция сохранения завершается до возврата управления из
\fBclone\fP() в пользовательское пространство процесса потомка (заметим, что
операция сохранения может не завершиться до возврата \fBclone\fP() в
родительском процессе, что произойдёт даже с указанным флагом \fBCLONE_VM\fP).
.TP 
\fBCLONE_FILES\fP (начиная с Linux 2.0)
Если задан флаг \fBCLONE_FILES\fP, то вызывающий процесс и процесс\-потомок
используют одну и ту же таблицу файловых дескрипторов. Любые файловые
дескрипторы, создаваемые вызывающим процессом или процессом\-потомком, также
доступны и в другом процессе. Аналогично, если один из процессов закрывает
файловый дескриптор или изменяет ассоциированные с ним флаги (с помощью
\fBfcntl\fP(2) операцией \fBF_SETFD\fP), то это оказывает влияние и на другой
процесс. Если процесс использующий общую таблицу файловых дескрипторов
вызывает \fBexecve\fP(2), то таблица файловых дескрипторов копируется в
отдельную (не общую).
.IP
Если флаг \fBCLONE_FILES\fP не задан, то процесс\-потомок наследует копии всех
файловых дескрипторов, открытых в вызывающем процессе на момент вызова
\fBclone\fP(). Последующие операции над файловыми дескрипторами по открытию и
закрытию файлов или изменению флагов файловых дескрипторов, выполняемые
вызывающим процессом или процессом\-потомком, не оказывают эффекта на другой
процесс. Заметим, что дублируемые файловые дескрипторы в потомке указывают
на те же открытые файловые дескрипторы что и файловые дескрипторы
вызывающего процесса и, таким образом, файловые смещения и флаги состояния
файла используются совместно (смотрите \fBopen\fP(2)).
.TP 
\fBCLONE_FS\fP (начиная с Linux 2.0)
Если задан флаг \fBCLONE_FS\fP, то вызывающий процесс и процесс\-потомок
используют одну и ту же информацию о файловой системе. К ней относится
корневой каталог файловой системы, текущий рабочий каталог и значение
umask. Любой вызов, \fBchroot\fP(2), \fBchdir\fP(2) или \fBumask\fP(2), выполняемый
одним процессом, оказывает влияние и на другой.
.IP
Если флаг \fBCLONE_FS\fP не задан, то процесс\-потомок работает с копией
информации о файловой системе вызывающего процесса, снятой на момент вызова
\fBclone\fP(). Вызовы \fBchroot\fP(2), \fBchdir\fP(2) или \fBumask\fP(2), выполняемые
позже одним из процессов, не оказывают эффект на другой процесс.
.TP 
\fBCLONE_IO\fP (начиная Linux 2.6.25)
Если задан флаг \fBCLONE_IO\fP, то новый процесс использует общий контекст
ввода\-вывода с вызывающим процессом. Если этот флаг не установлен, то (как и
в \fBfork\fP(2)) новый процесс будет иметь свой отдельный контекст
ввода\-вывода.
.IP
.\" The following based on text from Jens Axboe
.\" the anticipatory and CFQ scheduler
.\" with CFQ and AS.
Контекст ввода\-вывода — это область ввода\-вывода в дисковом планировщике
(т. е. то, что планировщик ввода\-вывода использует при планировании
ввода\-вывода процесса). Если процессы используют общий контекст
ввода\-вывода, то они рассматриваются планировщиком ввода\-вывода как
один. Следовательно, они совместно делят время доступа к диску. У некоторых
планировщиков ввода\-вывода, если два процесса используют общий контекст
ввода\-вывода, то им будет разрешено чередовать доступ к диску. Если
несколько нитей выполняют ввод\-вывод из одного процесса (например,
\fBaio_read\fP(3)), то для них нужно указать \fBCLONE_IO\fP для получения большей
производительности ввода\-вывода.
.IP
Если в ядре не указан параметр сборки \fBCONFIG_BLOCK\fP, то этот флаг ни на
что не влияет.
.TP 
\fBCLONE_NEWCGROUP\fP (начиная с Linux 4.6)
Процесс создаётся в новом пространстве имён cgroup. Если флаг не установлен,
то (как и в \fBfork\fP(2)), процесс создаётся в том же пространстве имён
cgroup, что и вызывающий процесс. Этот флаг предназначен для реализации
контейнеров.
.IP
Дополнительную информацию о пространствах имён cgroup смотрите в
\fBcgroup_namespaces\fP(7).
.IP
.\"
Только привилегированный процесс (\fBCAP_SYS_ADMIN\fP) может использовать
\fBCLONE_NEWCGROUP\fP.
.TP 
\fBCLONE_NEWIPC\fP (начиная с Linux 2.6.19)
Если задан флаг \fBCLONE_NEWIPC\fP, то процесс создаётся в новом пространстве
имён IPC. Если этот флаг не установлен, то (как и в \fBfork\fP(2)) процесс
создаётся в том же пространстве имён IPC что и вызывающий процесс. Этот флаг
предназначен для реализации контейнеров.
.IP
.\" commit 7eafd7c74c3f2e67c27621b987b28397110d643f
.\" https://lwn.net/Articles/312232/
Пространство имён IPC предоставляет изолированную выборку объектов System\ V
IPC (смотрите \fBsysvipc\fP(7)) и (начиная с Linux 2.6.30) очередей сообщений
POSIX (смотрите \fBmq_overview\fP(7)). Общие характеристики этих механизмов IPC
в том, что объекты IPC определяются механизмами, а не путями в файловой
системе.
.IP
Объекты, созданные в пространстве имён IPC, видимы всем другим процессам,
которые являются членами этого пространства имён, и невидимы процессам из
других пространств имён IPC.
.IP
При уничтожении пространства имён IPC (т.е., когда завершается последний
процесс из этого пространства имён), все объекты IPC из пространства имён
автоматически уничтожаются.
.IP
Только привилегированный процесс (\fBCAP_SYS_ADMIN\fP) может использовать
\fBCLONE_NEWIPC\fP. Этот флаг нельзя указывать вместе с \fBCLONE_SYSVSEM\fP.
.IP
Дополнительную информацию о пространствах имён IPC смотрите в
\fBnamespaces\fP(7).
.TP 
\fBCLONE_NEWNET\fP (начиная с Linux 2.6.24)
(Реализация этого флага завершена только в Linux 2.6.29.)
.IP
Если задан флаг \fBCLONE_NEWNET\fP, то процесс создаётся в новом сетевом
пространстве имён. Если флаг не установлен, то (как и в \fBfork\fP(2)), процесс
создаётся в том же сетевом пространстве имён что и вызывающий процесс. Этот
флаг предназначен для реализации контейнеров.
.IP
Сетевое пространство имён предоставляет изолированное представление сетевого
стека (интерфейсы сетевых устройств, стеки протоколов IPv4 и IPv6, таблицы
маршрутизации IP, правила межсетевого экрана, дерево каталогов \fI/proc/net\fP
и \fI/sys/class/net\fP, сокеты и т. д.). Физическое сетевое устройство может
находиться только в одном сетевом пространстве имён. Пара виртуальных
сетевых устройств (\fBveth\fP(4)) предоставляет похожую на канал абстракцию,
которую можно использовать для создания туннелей между сетевыми
пространствами имён и создания моста к физическому сетевому устройству из
другого пространства имён.
.IP
Когда сетевое пространство имён высвобождается (т. е., когда завершается
последний процесс в пространстве имён), его физические сетевые устройства
перемещаются обратно в первоначальное сетевое пространство имён (не
родительского процесса). Дополнительную информацию о сетевых пространствах
имён смотрите в \fBnamespaces\fP(7).
.IP
Только привилегированный процесс (\fBCAP_SYS_ADMIN\fP) может использовать
\fBCLONE_NEWNET\fP.
.TP 
\fBCLONE_NEWNS\fP (начиная с Linux 2.4.19)
Если указан флаг \fBCLONE_NEWNS\fP, то клонированный потомок запускается в
новом пространстве имён монтирования, инициализированном копией пространства
имён родителя. Если \fBCLONE_NEWNS\fP не указан, то потомок остаётся в том же
пространстве имён монтирования что и родитель.
.IP
.\" See https://lwn.net/Articles/543273/
Только привилегированный процесс (имеющий мандат \fBCAP_SYS_ADMIN\fP) может
использовать \fBCLONE_NEWNS\fP. Не допускается совместное использование флагов
\fBCLONE_NEWNS\fP и \fBCLONE_FS\fP в одном вызове \fBclone\fP().
.IP
Дополнительную информацию о пространствах имён монтирования смотрите в
\fBnamespaces\fP(7) и \fBmount_namespaces\fP(7).
.TP 
\fBCLONE_NEWPID\fP (начиная с Linux 2.6.24)
.\" This explanation draws a lot of details from
.\" http://lwn.net/Articles/259217/
.\" Authors: Pavel Emelyanov <xemul@openvz.org>
.\" and Kir Kolyshkin <kir@openvz.org>
.\"
.\" The primary kernel commit is 30e49c263e36341b60b735cbef5ca37912549264
.\" Author: Pavel Emelyanov <xemul@openvz.org>
Если задан флаг \fBCLONE_NEWPID\fP, то процесс создаётся в новом пространстве
имён PID. Если флаг не установлен, то (как и в \fBfork\fP(2)), процесс
создаётся в том же пространстве имён PID, что и вызывающий процесс. Этот
флаг предназначен для реализации контейнеров.
.IP
Дополнительную информацию о пространствах имён PID смотрите в
\fBnamespaces\fP(7) и \fBpid_namespaces\fP(7).
.IP
Только привилегированный процесс (\fBCAP_SYS_ADMIN\fP) может использовать
\fBCLONE_NEWPID\fP. Этот флаг нельзя указывать вместе с \fBCLONE_THREAD\fP или
\fBCLONE_PARENT\fP.
.TP 
\fBCLONE_NEWUSER\fP
(Впервые этот флаг приобрёл значение для \fBclone\fP() в Linux 2.6.23, текущая
семантика \fBclone\fP() появилась в Linux 3.5, а оставшиеся части, делающие
пространства имён пользователя полностью работоспособными, включены в Linux
3.8.)
.IP
Если задан флаг \fBCLONE_NEWUSER\fP, то процесс создаётся в новом пространстве
имён пользователя. Если флаг не установлен, то (как и в \fBfork\fP(2)), процесс
создаётся в том же пространстве имён пользователя, что и вызывающий процесс.
.IP
.\" Before Linux 2.6.29, it appears that only CAP_SYS_ADMIN was needed
До Linux 3.8, для использования \fBCLONE_NEWUSER\fP у вызывающего требовалось
три мандата: \fBCAP_SYS_ADMIN\fP, \fBCAP_SETUID\fP и \fBCAP_SETGID\fP. Начиная с
Linux 3.8, для создания пространства имён пользователя никаких привилегий не
требуется.
.IP
.\" commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
.\" https://lwn.net/Articles/543273/
.\" The fix actually went into 3.9 and into 3.8.3. However, user namespaces
.\" were, for practical purposes, unusable in earlier 3.8.x because of the
.\" various filesystems that didn't support userns.
Этот флаг нельзя указывать вместе с \fBCLONE_THREAD\fP или \fBCLONE_PARENT\fP. По
соображениям безопасности, \fBCLONE_NEWUSER\fP нельзя указывать вместе с
\fBCLONE_FS\fP.
.IP
Дополнительную информацию о пространствах имён пользователя смотрите в
\fBnamespaces\fP(7) и \fBuser_namespaces\fP(7).
.TP 
\fBCLONE_NEWUTS\fP (начиная с Linux 2.6.19)
Если задан флаг \fBCLONE_NEWUTS\fP, то процесс создаётся в новом пространстве
имён UTS, чьи идентификаторы инициализируются копией идентификаторов из
пространства имён UTS вызывающего процесса. Если флаг не указан, то (как и в
\fBfork\fP(2)), процесс создаётся в том же пространстве имён UTS что и
вызывающий процесс. Этот флаг предназначен для реализации контейнеров.
.IP
Пространство имён UTS — это набор идентификаторов, возвращаемых \fBuname\fP(2);
помимо остальных, сюда включены доменное имя и имя узла, которые изменить с
помощью \fBsetdomainname\fP(2) и \fBsethostname\fP(2),
соответственно. Изменившиеся идентификаторы в пространстве имён UTS видимы
всем остальным процессам в том же пространстве имён, но не видимы процессам
из других пространств имён UTS.
.IP
Только привилегированный процесс (\fBCAP_SYS_ADMIN\fP) может использовать
\fBCLONE_NEWUTS\fP.
.IP
Дополнительную информацию о пространствах имён UTS смотрите в
\fBnamespaces\fP(7).
.TP 
\fBCLONE_PARENT\fP (начиная с Linux 2.3.12)
Если задан флаг \fBCLONE_PARENT\fP, то родитель нового потомка (возвращаемый
\fBgetppid\fP(2)) будет таким же как и у вызывающего процесса.
.IP
Если флаг \fBCLONE_PARENT\fP не задан, то (как и в \fBfork\fP(2)) родителем будет
вызывающий процесс.
.IP
Заметим, что это тот родительский процесс, который возвращается вызовом
\fBgetppid\fP(2), и которому приходит сигнал когда потомок завершается, так что
если указан флаг \fBCLONE_PARENT\fP, то сигнал будет посылаться родителю
вызывающего процесса, а не самому вызывающему процессу.
.TP 
\fBCLONE_PARENT_SETTID\fP (начиная с Linux 2.5.49)
Сохранить ID нити потомка, расположенный в \fIptid\fP в памяти родителя (в
Linux 2.5.32\-2.5.48 для этого использовался флаг \fBCLONE_SETTID\fP). Операция
сохранения завершается до возврата управления из \fBclone\fP() в
пользовательское пространство.
.TP 
\fBCLONE_PID\fP (в Linux 2.0 по 2.5.15)
Если задан флаг \fBCLONE_PID\fP, то процесс\-потомок создаётся с таким же
идентификатором процесса как у вызывающего процесса. Это хорошо для
ковыряния в системе, но не более того. Начиная с 2.3.21 этот флаг может быть
указан только у процесса загрузки системы (PID 0). Флаг полностью удалён из
исходного кода в Linux 2.5.16. Начиная с этой версии, ядро просто игнорирует
этот бит, если он установлен в \fIflags\fP.
.TP 
\fBCLONE_PTRACE\fP (начиная с Linux 2.2)
Если задан флаг \fBCLONE_PTRACE\fP и вызывающий процесс находится в режиме
трассировки, то процесс\-потомок также будет работать в режиме трассировки
(см. \fBptrace\fP(2)).
.TP 
\fBCLONE_SETTLS\fP (начиная с Linux 2.5.32)
Дескриптор TLS (локальная память нитей) помещается в \fInewtls\fP.
.IP
Назначение \fInewtls\fP и его влияние на результат зависит от архитектуры. На
x86 \fInewtls\fP рассматривается как \fIstruct user_desc\ *\fP (смотрите
\fBset_thread_area\fP(2)). На x86_64 это новое значение будет присвоено
базовому регистру %fs (смотрите описание \fBARCH_SET_FS\fP в
\fBarch_prctl\fP(2)). На архитектурах с отдельным регистром для TLS это новое
значение помещается в этот регистр.
.TP 
\fBCLONE_SIGHAND\fP (начиная с Linux 2.0)
Если задан флаг \fBCLONE_SIGHAND\fP, то вызывающий процесс и процесс\-потомок
используют одну и ту же таблицу обработчиков сигналов. Если вызывающий
процесс или процесс\-потомок вызывают \fBsigaction\fP(2) для изменения поведения
при получении сигнала, то это поведение изменяется также и в другом
процессе. Однако, вызывающий процесс и процесс\-потомок имеют различные маски
сигналов и списки ожидающих обработки сигналов. Так, один из них может
блокировать или деблокировать сигналы, используя \fBsigprocmask\fP(2), и это не
будет влиять на другой процесс.
.IP
Если флаг \fBCLONE_SIGHAND\fP не указан, то процесс\-потомок наследует копию
обработчиков событий вызывающего процесса, снятую на момент вызова
\fBclone\fP(). Вызовы \fBsigaction\fP(2), выполняемые позже одним из процессов, не
оказывают влияния на другой процесс.
.IP
.\" Precisely: Linux 2.6.0-test6
Начиная с Linux 2.6.0, аргумент \fIflags\fP должен также включать \fBCLONE_VM\fP,
если указан флаг \fBCLONE_SIGHAND\fP
.TP 
\fBCLONE_STOPPED\fP (начиная с Linux 2.6.0)
.\" Precisely: Linux 2.6.0-test2
Если указан флаг \fBCLONE_STOPPED\fP, то после создания потомок перейдёт в
состояние останова (как если бы ему послали сигнал \fBSIGSTOP\fP), и начнёт
работу по сигналу \fBSIGCONT\fP.
.IP
.\" glibc 2.8 removed this defn from bits/sched.h
Этот флаг \fIустарел\fP начиная с Linux 2.6.25 и был \fIудалён\fP в Linux
2.6.38. Начиная с этой версии, ядро просто игнорирует его без
ошибки. Начиная с Linux 4.6 используемый под него бит используется для флага
\fBCLONE_NEWCGROUP\fP.
.TP 
\fBCLONE_SYSVSEM\fP (начиная с Linux 2.5.10)
Если указан флаг \fBCLONE_SYSVSEM\fP, то потомок и вызывающий процесс будут
иметь общий единый список значений регулировки семафоров System V
(\fIsemadj\fP) (смотрите \fBsemop\fP(2)). В этом случае общий список накапливает
значения \fIsemadj\fP из общего списка процессов и регулировки семафоров
выполняются только когда завершается последний процесс, использующий общий
список (или перестаёт пользоваться общим списком с помощью
\fBunshare\fP(2)). Если этот флаг не указан, то потомок имеет отдельный список
\fIsemadj\fP, который первоначально пуст.
.TP 
\fBCLONE_THREAD\fP (начиная с Linux 2.4.0)
.\" Precisely: Linux 2.6.0-test8
Если указан флаг \fBCLONE_THREAD\fP, то потомок размещается в той же группе
нитей, что и вызывающий процесс. Чтобы сделать остаток обсуждения
\fBCLONE_THREAD\fP более понятным, термин «нить» используется для ссылки на
процессы внутри группы нитей.
.IP
Группы нитей были добавлены в Linux 2.4 для поддержки нитей POSIX,
описываемых как набор нитей, использующих один и тот же PID. Внутренне общий
PID — это так называемый идентификатор группы нитей (TGID). Начиная с Linux
2.4, вызов \fBgetpid\fP(2) возвращает идентификатор группы нитей вызывающего
процесса.
.IP
Внутри группы нити можно различать по их (глобальному) уникальному
идентификатору нити (TID). TID новой нити возвращается вызывающему как
результат \fBclone\fP(), а нить может узнать свой TID с помощью вызова
\fBgettid\fP(2).
.IP
Когда вызов \fBclone\fP() делается без \fBCLONE_THREAD\fP, то получаемая нить
помещается в новую группу нитей, чей TGID совпадает с TID нити. Эта нить
будет \fIлидером\fP новой группы нитей.
.IP
Новая нить, созданная с \fBCLONE_THREAD\fP, имеет тот же родительский процесс
что и вызвавший \fBclone\fP() (т.е., как \fBCLONE_PARENT\fP), поэтому при вызове
\fBgetppid\fP(2) возвращается одинаковое значение для всех нитей в группе
нитей. Когда нить \fBCLONE_THREAD\fP завершается, нити, создавшей её с помощью
\fBclone\fP(), не посылается сигнал \fBSIGCHLD\fP (или другой сигнал завершения);
состояние такой нити нельзя получить с помощью \fBwait\fP(2). Про нить говорят,
что она \fIотсоединена\fP (detached).
.IP
После завершения работы всех нитей в группе нитей родительскому процессу
группы нитей посылается сигнал \fBSIGCHLD\fP (или другой завершающий сигнал).
.IP
Если в любой из нитей группы нитей выполняется вызов \fBexecve\fP(2), то все
нити отличные от лидера группы нитей, завершаются и выполняется новая
программы в лидере группы нитей.
.IP
Если одна из нитей группы нитей создаёт потомка с помощью \fBfork\fP(2), то
любая нить группы может вызвать \fBwait\fP(2) для ожидания этого потомка.
.IP
.\" Precisely: Linux 2.6.0-test6
Начиная с Linux 2.5.35, аргумент \fIflags\fP должен также включать
\fBCLONE_SIGHAND\fP, если указан флаг \fBCLONE_THREAD\fP (также заметим, что
начиная с Linux 2.6.0, для \fBCLONE_SIGHAND\fP также требуется включать
\fBCLONE_VM\fP).
.IP
Расположение и действия сигналов распространяются на весь процесс: если
необработанный сигнал доставляется нити, то это влияет (завершение,
остановка, продолжение, игнорирование) на все члены группы нитей.
.IP
Каждая нить имеет свою маску сигналов, задаваемую \fBsigprocmask\fP(2).
.IP
Сигнал может быть направлен процессу и направлен нити. Целью сигнала,
направленного процессу, является группа нитей (т. е., TGID), и он
доставляется произвольно выбранной нити среди неблокирующих сигнал. Сигнал
может быть направлен процессу из ядра по причинам, не относящимся к
аппаратному исключению, или быть послан с помощью \fBkill\fP(2) или
\fBsigqueue\fP(3). Целью сигнала, направленного нити, является определённая
(т. е., указанная в адресе назначения) нить. Сигнал может быть направлен
нити вызовом \fBtgkill\fP(2) или \fBpthread_sigqueue\fP(3), или если в работе нити
возникло аппаратное исключение при выполнении ей языковой инструкции
(например, при доступе к памяти по неправильному адресу возникает
\fBSIGSEGV\fP, а исключение в блоке выполнения инструкций с плавающей запятой
приводит к \fBSIGFPE\fP).
.IP
Вызов \fBsigpending\fP(2) возвращает набор сигналов, который представляет собой
объединение ожидающих сигналов, направленных процессу, и сигналов, которые
ожидает вызывающая нить.
.IP
Если сигнал, оправленный процессу, доставляется группе нитей и у группы
нитей установлен обработчик сигнала, то обработчик будет вызван только один
раз в произвольно выбранном члене группы нитей, который не блокирует
сигнал. Если несколько нитей в группе ждут приёма того же сигнала с помощью
\fBsigwaitinfo\fP(2), то ядро произвольно выберет одну из этих нитей для приёма
сигнала.
.TP 
\fBCLONE_UNTRACED\fP (начиная с Linux 2.5.46)
Если указан флаг \fBCLONE_UNTRACED\fP, то выполняющий трассировку процесс не
сможет указать \fBCLONE_PTRACE\fP на этом процессе\-потомке.
.TP 
\fBCLONE_VFORK\fP (начиная с Linux 2.2)
Если указан флаг \fBCLONE_VFORK\fP, то выполнение вызывающего процесса
приостанавливается до тех пор, пока потомок не освободит ресурсы виртуальной
памяти с помощь вызова \fBexecve\fP(2) или \fB_exit\fP(2) (как с \fBvfork\fP(2)).
.IP
Если флаг \fBCLONE_VFORK\fP не указан, то вызывающий процесс и потомок доступны
для планирования после вызова, и приложение не должно полагаться на то, что
выполнение производится в каком\-то определённом порядке.
.TP 
\fBCLONE_VM\fP (начиная с Linux 2.0)
Если задан флаг \fBCLONE_VM\fP, то вызывающий и дочерний процесс работают в
одном пространстве памяти. В частности, запись в память одним процессом
видна другому. Кроме того, выполнение отображения или снятия отображения в
память, выполняемая с помощью \fBmmap\fP(2) или \fBmunmap\fP(2), одним процессом,
влияет на другой.
.IP
Если флаг \fBCLONE_VM\fP не установлен, то дочерний процесс выполняется в
отдельной копии пространства памяти вызывающего процесс с момента
\fBclone\fP(). Запись в память или отображение/снятие отображения файла,
выполняемое одним процессом, не влияет на другой (как с \fBfork\fP(2)).
.SH ЗАМЕЧАНИЯ
.\"
Заметим, что обёрточная функция glibc \fBclone\fP() делает некоторые изменения
в памяти, на которую указывает \fIchild_stack\fP (изменения требуются для
правильной настройки стека в потомке) \fIперед\fP запуском системного вызова
\fBclone\fP(). Поэтому в случаях, когда \fBclone\fP() используется для
рекурсивного создания потомков, не используйте буфер стека родителя в
качестве стека потомка.
.SS "Отличия между библиотекой C и ядром"
Системный вызов \fBclone\fP() больше похож на \fBfork\fP(2) в том плане, что
выполнение в потомке продолжается от места вызова. Таким образом, аргументы
\fIfn\fP и \fIarg\fP обёрточной функции \fBclone\fP() отсутствуют.
.PP
Другим отличием системного вызова \fBclone\fP() является то, что аргумент
\fIchild_stack\fP может быть равен NULL, если потомок использует копию
родительского стека (копирование\-при\-записи гарантирует, что потомок получит
отдельные копии страниц стека, если один из процессов изменит стек). В этом
случае для правильной работы не должен использоваться флаг \fBCLONE_VM\fP (если
потомок \fIиспользует\fP родительскую память из\-за указания \fBCLONE_VM\fP, то
создания копии при копировании\-при\-записи не происходит и, вероятно, это
вызове хаос).
.PP
В системном вызове также другой порядок аргументов, он различен у разных
архитектур (описан далее).
.PP
Интерфейс внутреннего системного вызова на x86\-64 и некоторых других
архитектурах (включая sh, tile, ia\-64 и alpha):
.PP
.in +4
.EX
\fBlong clone(unsigned long \fP\fIflags\fP\fB, void *\fP\fIchild_stack\fP\fB,\fP
\fB           int *\fP\fIptid\fP\fB, int *\fP\fIctid\fP\fB,\fP
\fB           unsigned long \fP\fInewtls\fP\fB);\fP
.EE
.in
.PP
.\" CONFIG_CLONE_BACKWARDS
На x86\-32 и некоторых других распространённых архитектурах (включая score,
ARM, ARM 64, PA\-RISC, arc, Power PC, xtensa и MIPS) порядок последних двух
аргументов обратный:
.PP
.in +4
.EX
\fBlong clone(unsigned long \fP\fIflags\fP\fB, void *\fP\fIchild_stack\fP\fB,\fP
\fB          int *\fP\fIptid\fP\fB, unsigned long \fP\fInewtls\fP\fB,\fP
\fB          int *\fP\fIctid\fP\fB);\fP
.EE
.in
.PP
.\" CONFIG_CLONE_BACKWARDS2
На архитектурах cris и s390 порядок первых двух аргументов обратный:
.PP
.in +4
.EX
\fBlong clone(void *\fP\fIchild_stack\fP\fB, unsigned long \fP\fIflags\fP\fB,\fP
\fB           int *\fP\fIptid\fP\fB, int *\fP\fIctid\fP\fB,\fP
\fB           unsigned long \fP\fInewtls\fP\fB);\fP
.EE
.in
.PP
.\" CONFIG_CLONE_BACKWARDS3
На архитектуре microblaze есть дополнительный аргумент:
.PP
.in +4
.EX
\fBlong clone(unsigned long \fP\fIflags\fP\fB, void *\fP\fIchild_stack\fP\fB,\fP
\fB           int \fP\fIstack_size\fP\fB,\fP         /* Size of stack */
\fB           int *\fP\fIptid\fP\fB, int *\fP\fIctid\fP\fB,\fP
\fB           unsigned long \fP\fInewtls\fP\fB);\fP
.EE
.in
.\"
.SS "blackfin, m68k и sparc"
.\" Mike Frysinger noted in a 2013 mail:
.\"     these arches don't define __ARCH_WANT_SYS_CLONE:
.\"     blackfin ia64 m68k sparc
Соглашение по передаче аргументов на blackfin, m68k и sparc отличается от
описанного выше. Подробности смотрите в исходном коде ядра (и glibc).
.SS ia64
На ia64 используется другой интерфейс:
.PP
.in +4
.EX
\fBint __clone2(int (*\fP\fIfn\fP\fB)(void *), \fP
\fB             void *\fP\fIchild_stack_base\fP\fB, size_t \fP\fIstack_size\fP\fB,\fP
\fB             int \fP\fIflags\fP\fB, void *\fP\fIarg\fP\fB, ... \fP
\fB          /* pid_t *\fP\fIptid\fP\fB, struct user_desc *\fP\fItls\fP\fB, pid_t *\fP\fIctid\fP\fB */ );\fP
.EE
.in
.PP
Прототип, показанный выше, относится к обёрточной функции glibc; прототип
системного вызова можно описать следующим образом (одинаков с прототипом
\fBclone\fP() на microblaze):
.PP
.in +4
.EX
\fBlong clone2(unsigned long \fP\fIflags\fP\fB, void *\fP\fIchild_stack_base\fP\fB,\fP
\fB            int \fP\fIstack_size\fP\fB,\fP         /* Size of stack */
\fB            int *\fP\fIptid\fP\fB, int *\fP\fIctid\fP\fB,\fP
\fB            unsigned long \fP\fItls\fP\fB);\fP
.EE
.in
.PP
Системный вызов \fB__clone2\fP() работает также как и \fBclone\fP() за исключением
того, что \fIchild_stack_base\fP указывает на самый нижний адрес области стека
потомка, и в \fIstack_size\fP задаётся размер стека, указываемого в
\fIchild_stack_base\fP.
.SS "Linux версии 2.4 и более ранние"
В Linux 2.4 и более ранних \fBclone\fP() не принимал аргументов \fIptid\fP, \fItls\fP
и \fIctid\fP.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
.\" gettid(2) returns current->pid;
.\" getpid(2) returns current->tgid;
При успешном выполнении в вызывающую исполняемую нить возвращается ID нити
дочернего процесса. Иначе в контекст вызывающего возвращается \-1, дочерний
процесс не создаётся и \fIerrno\fP устанавливается в соответствующее значение.
.SH ОШИБКИ
.TP 
\fBEAGAIN\fP
Уже выполняется максимальное количество процессов; смотрите \fBfork\fP(2).
.TP 
\fBEINVAL\fP
.\" Precisely: Linux 2.6.0-test6
Указан флаг \fBCLONE_SIGHAND\fP, но нет \fBCLONE_VM\fP (начиная с Linux 2.6.0).
.TP 
\fBEINVAL\fP
.\" .TP
.\" .B EINVAL
.\" Precisely one of
.\" .B CLONE_DETACHED
.\" and
.\" .B CLONE_THREAD
.\" was specified.
.\" (Since Linux 2.6.0-test6.)
Указан флаг \fBCLONE_THREAD\fP, но нет \fBCLONE_SIGHAND\fP (начиная с Linux
2.5.35).
.TP 
\fBEINVAL\fP
Указан флаг \fBCLONE_THREAD\fP, но текущий процесс до этого вызвал
\fBunshare\fP(2) с флагом \fBCLONE_NEWPID\fP или использовал \fBsetns\fP(2) для
своего отсоединения от пространства имён PID.
.TP 
\fBEINVAL\fP
.\" commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
Указаны оба флага, \fBCLONE_FS\fP и \fBCLONE_NEWNS\fP, в \fIflags\fP.
.TP 
\fBEINVAL\fP (начиная с Linux 3.9)
Указаны оба флага, \fBCLONE_NEWUSER\fP и \fBCLONE_FS\fP, в \fIflags\fP.
.TP 
\fBEINVAL\fP
Указаны оба флага, \fBCLONE_NEWIPC\fP и \fBCLONE_SYSVSEM\fP, в \fIflags\fP.
.TP 
\fBEINVAL\fP
Указан один или оба флага, \fBCLONE_NEWPID\fP или \fBCLONE_NEWUSER\fP, и один или
оба флага, \fBCLONE_THREAD\fP или \fBCLONE_PARENT\fP, в \fIflags\fP.
.TP 
\fBEINVAL\fP
Возвращается обёрточной функцией glibc \fBclone\fP(), если \fIfn\fP или
\fIchild_stack\fP равны NULL.
.TP 
\fBEINVAL\fP
Указан флаг \fBCLONE_NEWIPC\fP в \fIflags\fP, но ядро собрано без параметров
\fBCONFIG_SYSVIPC\fP и \fBCONFIG_IPC_NS\fP.
.TP 
\fBEINVAL\fP
Указан флаг \fBCLONE_NEWNET\fP в \fIflags\fP, но ядро собрано без параметра
\fBCONFIG_NET_NS\fP.
.TP 
\fBEINVAL\fP
Указан флаг \fBCLONE_NEWPID\fP в \fIflags\fP, но ядро собрано без параметра
\fBCONFIG_PID_NS\fP.
.TP 
\fBEINVAL\fP
Указан флаг \fBCLONE_NEWUSER\fP в \fIflags\fP, но ядро собрано без параметра
\fBCONFIG_USER_NS\fP.
.TP 
\fBEINVAL\fP
Указан флаг \fBCLONE_NEWUTS\fP в \fIflags\fP, но ядро собрано без параметра
\fBCONFIG_UTS_NS\fP.
.TP 
\fBEINVAL\fP
Значение \fIchild_stack\fP не выровнено по нужной границе для этой
архитектуры. Например, на aarch64 \fIchild_stack\fP должно быть кратно 16.
.TP 
\fBENOMEM\fP
Не удалось выделить достаточно памяти для структуры задач потомка или
скопировать необходимые части контекста вызывающего.
.TP 
\fBENOSPC\fP (начиная с Linux 3.7)
.\" commit f2302505775fd13ba93f034206f1e2a587017929
В флагах указан \fBCLONE_NEWPID\fP, но вызов привёл бы к превышению ограничения
на количество вложенных имён PID; смотрите \fBpid_namespaces\fP(7).
.TP 
\fBENOSPC\fP (начиная с Linux 4.9; до этого \fBEUSERS\fP)
Флаг \fBCLONE_NEWUSER\fP указан в \fIflags\fP, и вызов привёл бы к превышению
ограничения на количество вложенных пользовательских пространств
имён. Смотрите \fBuser_namespaces\fP(7).
.IP
В этом случае в Linux 3.11 по Linux 4.8 возвращалась ошибка \fBEUSERS\fP.
.TP 
\fBENOSPC\fP (начиная с Linux 4.9)
Одним из значений в \fIflags\fP задаётся создание нового пространства
пространства имён пользователя, но это превысило бы ограничение,
определённое в соответствующем файле в каталоге
\fI/proc/sys/user\fP. Дополнительную информацию смотрите в \fBnamespaces\fP(7).
.TP 
\fBEPERM\fP
Указан флаг \fBCLONE_NEWCGROUP\fP, \fBCLONE_NEWIPC\fP, \fBCLONE_NEWNET\fP,
\fBCLONE_NEWNS\fP, \fBCLONE_NEWPID\fP или \fBCLONE_NEWUTS\fP, но процесс не имеет
достаточно прав (нет мандата \fBCAP_SYS_ADMIN\fP).
.TP 
\fBEPERM\fP
Указан флаг \fBCLONE_PID\fP, но ID процесса не равен 0 (эта ошибка возникает
только в Linux 2.5.15 и старее).
.TP 
\fBEPERM\fP
Флаг \fBCLONE_NEWUSER\fP указан в \fIflags\fP, но эффективный пользовательский ID
или эффективный ID группы вызывающего не отображён в родительское
пространство имён (смотрите \fBuser_namespaces\fP(7)).
.TP 
\fBEPERM\fP (начиная с Linux 3.9)
.\" commit 3151527ee007b73a0ebd296010f1c0454a919c7d
.\" FIXME What is the rationale for this restriction?
В \fIflags\fP был указан флаг \fBCLONE_NEWUSER\fP и вызывающий выполняется в
окружении chroot (т. е. корневой каталог вызывающего не совпадает с корневым
каталогом пространства имён монтирования, в котором он находится).
.TP 
\fBERESTARTNOINTR\fP (начиная с Linux 2.6.17)
.\" commit 4a2c7a7837da1b91468e50426066d988050e4d56
Системный вызов был прерван сигналом и перезапущен (может быть замечено
только при трассировке).
.TP 
\fBEUSERS\fP (с Linux 3.11 по Linux 4.8)
.\" .SH VERSIONS
.\" There is no entry for
.\" .BR clone ()
.\" in libc5.
.\" glibc2 provides
.\" .BR clone ()
.\" as described in this manual page.
Флаг \fBCLONE_NEWUSER\fP указан в \fIflags\fP, и вызов привёл бы к превышению
ограничения на количество вложенных пользовательских пространств
имён. Смотрите описание ошибки \fBENOSPC\fP, представленное выше.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
Вызов \fBclone\fP() есть только в Linux и не должен использоваться в
переносимых программах.
.SH ЗАМЕЧАНИЯ
Системный вызов \fBkcmp\fP(2) можно использовать для проверки того, что два
процесса совместно используют различные ресурсы, такие как таблицу файловых
дескрипторов, семафор System V для отмены операций или виртуальное адресное
пространство.
.PP
.PP
Обработчики, зарегистрированные с помощью \fBpthread_atfork\fP(3), не
выполняются во время вызова \fBclone\fP().
.PP
Для ядер версий Linux 2.4.x, флаг \fBCLONE_THREAD\fP не делает родителем новой
нити того же родителя что и у вызывающего процесса. Однако для ядер версий
2.4.7\-2.4.18 флаг \fBCLONE_THREAD\fP неявно подразумевает флаг \fBCLONE_PARENT\fP
(как в ядре Linux 2.6.0 и новее).
.PP
Некоторое время существовал флаг \fBCLONE_DETACHED\fP (начиная с 2.5.32):
родитель не хочет получать сигнал завершения потомка. В Linux 2.6.2
необходимость указывать этот флаг вместе с \fBCLONE_THREAD\fP отпала. Этот флаг
ещё определён, но не оказывает никакого действия.
.PP
На архитектуре i386 \fBclone\fP() не должен вызываться через vsyscall, а
запускаться явно с помощью \fIint $0x80\fP.
.SH ДЕФЕКТЫ
Версии библиотеки GNU C с 2.3.4 и по 2.24 включительно содержат обёрточную
функцию для \fBgetpid\fP(2), которая выполняет кэширование значений PID. Это
кэширование основано на поддержке обёрточной функции glibc для \fBclone\fP(),
но ограничения в реализации полагаются, что кэш в некоторых случаях не
устаревает до определённой даты. В частности, если сигнал был доставлен
потомку сразу после вызова \fBclone\fP(), то вызов \fBgetpid\fP(2) обработчике
сигнала может вернуть PID вызывающего процесса («родителя»), если у обёртки
clone пока не было шанса изменить кэш PID в потомке (в этом описании
игнорируется случай, где потомок был создал с использованием
\fBCLONE_THREAD\fP, когда \fBgetpid\fP(2)  \fIдолжен\fP вернуть то же значение в
потомок и в процесс, вызывавший \fBclone\fP(), так как вызывающий и потомок
находятся в одной группе нитей. Проблема просроченного кэша также не
возникает, если в аргументе \fIflags\fP содержится \fBCLONE_VM\fP). Чтобы узнать
правду, было иногда необходимо использовать такой код:
.PP
.in +4n
.EX
#include <syscall.h>

pid_t mypid;

mypid = syscall(SYS_getpid);
.EE
.in
.\" See also the following bug reports
.\" https://bugzilla.redhat.com/show_bug.cgi?id=417521
.\" http://sourceware.org/bugzilla/show_bug.cgi?id=6910
.PP
Из\-за проблем просроченного кэша (stale\-cache), а также других, упомянутых в
\fBgetpid\fP(2), свойство кэширования PID было удалено в glibc 2.25.
.SH ПРИМЕР
Следующая программа демонстрирует использование \fBclone\fP() для создания
дочернего процесса, который выполняется в отдельном пространстве имён
UTS. Потомок изменяет имя узла в своём пространстве имён UTS. И предок и
потомок затем выводят системное имя узла, чтобы можно было убедиться в
неодинаковости пространств имён. Пример использования этой программы
смотрите в \fBsetns\fP(2).
.SS "Исходный код программы"
.EX
#define _GNU_SOURCE
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sched.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \e
                        } while (0)

static int              /* Начало функции клонированного
                           потомка */
childFunc(void *arg)
{
    struct utsname uts;

    /* Изменяем имя узла в пространстве имён UTS потомка */

    if (sethostname(arg, strlen(arg)) == \-1)
        errExit("sethostname");

    /* Получаем и показывает имя узла */

    if (uname(&uts) == \-1)
        errExit("uname");
    printf("uts.nodename in child:  %s\en", uts.nodename);

    /* Перед сном оставим пространство имён открытым.
       Это позволяет поэкспериментировать — например, другой
       процесс может подключиться к пространству имён. */

    sleep(200);

    return 0;           /* Завершение работы потомка */
}

#define STACK_SIZE (1024 * 1024)    /* Размер стека клонированного
                                       потомка */

int
main(int argc, char *argv[])
{
    char *stack;                    /* Начало буфера стека */
    char *stackTop;                 /* Конец буфера стека */
    pid_t pid;
    struct utsname uts;

    if (argc < 2) {
        fprintf(stderr, "Usage: %s <child\-hostname>\en", argv[0]);
        exit(EXIT_SUCCESS);
    }

    /* Выделение стека для потомка */

    stack = malloc(STACK_SIZE);
    if (stack == NULL)
        errExit("malloc");
    stackTop = stack + STACK_SIZE;  /* Считаем, что стек растёт вниз */

    /* Создаём потомка с собственным пространством имён UTS;
       потомок начинает выполнение с childFunc() */

    pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[1]);
    if (pid == \-1)
        errExit("clone");
    printf("clone() returned %ld\en", (long) pid);

    /* Предок попадает сюда */

    sleep(1);           /* Даём время потомку изменить своё имя узла */

    /* Показываем имя узла в пространстве имён UTS предка. Оно будет
       отличаться от имени узла в пространстве имён UTS потомка. */

    if (uname(&uts) == \-1)
        errExit("uname");
    printf("uts.nodename in parent: %s\en", uts.nodename);

    if (waitpid(pid, NULL, 0) == \-1)    /* Ждём потомка */
        errExit("waitpid");
    printf("child has terminated\en");

    exit(EXIT_SUCCESS);
}
.EE
.SH "СМОТРИТЕ ТАКЖЕ"
\fBfork\fP(2), \fBfutex\fP(2), \fBgetpid\fP(2), \fBgettid\fP(2), \fBkcmp\fP(2),
\fBset_thread_area\fP(2), \fBset_tid_address\fP(2), \fBsetns\fP(2), \fBtkill\fP(2),
\fBunshare\fP(2), \fBwait\fP(2), \fBcapabilities\fP(7), \fBnamespaces\fP(7),
\fBpthreads\fP(7)
