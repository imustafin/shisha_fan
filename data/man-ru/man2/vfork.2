.\" -*- mode: troff; coding: UTF-8 -*-
.\" Copyright (c) 1999 Andries Brouwer (aeb@cwi.nl), 1 Nov 1999
.\" and Copyright 2006, 2012, 2017 Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"
.\" 1999-11-10: Merged text taken from the page contributed by
.\" Reed H. Petty (rhp@draper.net)
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH VFORK 2 2017\-09\-15 Linux "Руководство программиста Linux"
.SH ИМЯ
vfork \- создаёт дочерний процесс и блокирует родительский
.SH ОБЗОР
\fB#include <sys/types.h>\fP
.br
\fB#include <unistd.h>\fP
.PP
\fBpid_t vfork(void);\fP
.PP
.in -4n
Требования макроса тестирования свойств для glibc
(см. \fBfeature_test_macros\fP(7)):
.in
.PP
\fBvfork\fP():
.ad l
.RS 4
.PD 0
.TP  4
Начиная с glibc 2.12:
.nf
(_XOPEN_SOURCE\ >=\ 500) && ! (_POSIX_C_SOURCE\ >=\ 200809L)
    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE
    || /* в версиях glibc <= 2.19: */ _BSD_SOURCE
.TP  4
.fi
.\"     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
до glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\ >=\ 500
.PD
.RE
.ad b
.SH ОПИСАНИЕ
.SS "Описание в стандарте"
(Из POSIX) Функция \fBvfork\fP() аналогична \fBfork\fP(2) за тем исключением, что
поведение не определено, если процесс, созданный \fBvfork\fP(), изменяет любые
данные, кроме переменной типа \fIpid_t\fP, используемой в качестве значения,
возвращаемого \fBvfork\fP(), или возвращается из функции, из которой была
вызвана функция \fBvfork\fP(), или вызывает любую функцию до удачного
исполнения \fB_exit\fP(2) или одной из функций семейства \fBexec\fP(3).
.SS "Описание в Linux"
\fBvfork\fP(), так же как и \fBfork\fP(2), создаёт дочерний процесс для
вызывающего процесса. Подробности, возвращаемые значения и ошибки смотрите в
\fBfork\fP(2).
.PP
\fBvfork\fP() \(em это специальный вариант \fBclone\fP(2). Он используется для
создания новых процессов без копирования таблиц страниц родительского
процесса. Это может использоваться в приложениях, критичных к
производительности, для создания дочерних процессов, сразу же запускающих
\fBexecve\fP(2).
.PP
Вызов \fBvfork\fP() отличается от \fBfork\fP(2) тем, что вызывающая нить
блокируется до тех пор, пока не завершится потомок (обычно, вызовом
\fB_exit\fP(2) или, что ненормально, из\-за принятого необработанного сигнала)
или не выполнит \fBexecve\fP(2). До этих пор потомок имеет общую память с
родителем, включая стек. Потомок не должен выходить из текущей функции или
вызывать \fBexit\fP(3) (что приводит к вызовы обработчиков выхода, настроенных
родительским процессом и сбрасывает буферы \fBstdio\fP(3) родителя), но может
вызвать \fB_exit\fP(2).
.PP
Как и у \fBfork\fP(2), дочерний процесс, созданный \fBvfork\fP(), наследует копии
различных атрибутов вызвавшего процесса (например, дескрипторы файлов,
обработчики сигналов и текущий рабочий каталог); вызов \fBvfork\fP() отличается
только в применении виртуального адресного пространства (как описывалось
выше).
.PP
Сигналы передаются родителю после того, как потомок разблокирует его память
(т.е. после того, как потомок завершится или вызовет \fBexecve\fP(2)).
.SS "Историческое описание"
В Linux вызов \fBfork\fP(2) реализован при помощи страниц, «копируемых при
записи» (copy\-on\-write), поэтому единственная задержка, возникающая при
вызове \fBfork\fP(2) \(em это время, необходимое для создания копии таблиц
страниц родительского процесса и уникальной структуры описания задачи
дочернего процесса. Однако, в прошлом для \fBfork\fP(2) могло требоваться
создание полной копии пространства данных вызывающего процесса, что часто
было ненужно, так как в потомке сразу следовал запуск функции
\fBexec\fP(3). Поэтому для большей эффективности в BSD был предложен системный
вызов \fBvfork\fP(), который не копировал адресное пространство процесса, а
использовал то же самое пространство и управления нитью, блокируя
родительский процесс до вызова \fBexecve\fP(2) или до прекращения работы
потомка. Родительский процесс останавливался до тех пор, пока потомок
использовал его ресурсы. Использование \fBvfork\fP() было ненадёжно: например,
сохранность данных родительского процесса зависела от того, хранились ли на
тот момент переменные в регистрах.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
4.3BSD; POSIX.1\-2001 (помечен как УСТАРЕВШИЙ). Из POSIX.1\-2008 описание
\fBvfork\fP() было удалено.
.PP
.\" In AIXv3.1 vfork is equivalent to fork.
Требования, предъявляемые стандартами к \fBvfork\fP(), не такие жёсткие как те,
которые предъявляются к \fBfork\fP(2), поэтому в реализации достаточно просто
сделать их синонимами. В частности, программист не может полагаться на
блокировку родителя до завершения потомка или до вызова им \fBexecve\fP(2), и
не может полагаться на специфическое поведение возникновения общей памяти.
.SH ЗАМЕЧАНИЯ
.PP
Некоторые считают, что в семантике \fBvfork\fP() есть архитектурный недостаток,
а в справочной странице BSD написано следующее: «Данный системный вызов
будет удалён после того, как будут правильно реализованы соответствующие
механизмы разделения ресурсов системы. Пользователи не должны опираться на
существующую семантику общей памяти \fBvfork\fP(), то есть программа должна
быть аналогична программе с \fBfork\fP(2)». Однако, даже при том, что
современные аппаратные средства управления памятью уменьшили разницу в
производительности между \fBfork\fP(2) и \fBvfork\fP(), есть другие причины почему
в Linux и других операционных системах \fBvfork\fP() ещё существует:
.IP * 3
Для некоторых критичных к производительности приложений очень важна та
маленькая прибавка к производительности, предоставляемая \fBvfork\fP().
.IP *
.\" http://stackoverflow.com/questions/4259629/what-is-the-difference-between-fork-and-vfork
.\" http://developers.sun.com/solaris/articles/subprocess/subprocess.html
.\" http://mailman.uclinux.org/pipermail/uclinux-dev/2009-April/000684.html
.\"
Вызов \fBvfork\fP() может быть реализован в системах, у которых нет блока
управления памятью (MMU), а \fBfork\fP(2) невозможно реализовать на таких
системах (из POSIX.1\-2008 вызов \fBvfork\fP() удалён; для реализации
эквивалента \fBfork\fP(2)+\fBexec\fP(3) в системах без MMU в POSIX предлагается
использовать функцию \fBposix_spawn\fP(3)).
.IP *
.\"
В системах с малым количеством памяти \fBvfork\fP() при запуске новой программы
не выполняет временное выделение памяти (смотрите описание
\fI/proc/sys/vm/overcommit_memory\fP в \fBproc\fP(5)) (это особенно полезно, если
огромный родительский процесс хочет выполнить маленькую вспомогательную
программу в дочернем процессе). Вызов \fBfork\fP(2) в этом случае или
потребуется выделения количества памяти как у родительского процесса (если
включён жёсткий учёт обязательств) или перерасходует память с риском
завершения процесса посредством сторожа расходования памяти ядра (OOM).
.SS Предостережения
Потомок не должен изменять память не ожидаемым образом, так как такие
изменения будут видны родительскому процессу после завершения потомка или
выполнении другой программы. При таком отношении особенно остро стоит
проблема в обработчиках сигналов: если обработчик сигналов, вызванный в
потомке (созданном \fBvfork\fP()), изменяет память, то эти изменения могут
привести к нарушению целостности состояния процесса с точки зрения родителя
(например, изменения памяти были бы видны родителю, а изменения состояния
открытых файловых дескрипторов не видны).
.PP
.\"
Если \fBvfork\fP() вызывается многонитиевом процессе, то в ожидании завершения
процесса или запуска новой программы приостанавливается только вызывающая
нить. Это означает, что потомок совместно использует адресное пространство
другим выполняющимся кодом. Это может быть опасно, если другая нить в
родительском процессе изменяет полномочия (с помощью \fBsetuid\fP(2) и
подобных), так как теперь есть два процесса с разным уровнем прав,
выполняемых в одном адресном пространстве. Как пример представим, что
многонитиевая программа, работающая с правами суперпользователя, создаёт
потомка с помощью \fBvfork\fP(). После \fBvfork\fP() нить в родительском процессе
понижает права процесса до непривилегированных, чтобы выполнить некий
недоверенный код (например, модуль, открытый через \fBdlopen\fP(3)). В этом
случае появляется уязвимость, если родительский процесс использует
\fBmmap\fP(2) для отображения кода, то он будет выполнен в привилегированном
дочернем процессе.
.SS "Замечания, касающиеся Linux"
Обработчики fork, установленные с помощью \fBpthread_atfork\fP(3), не
вызываются когда многонитиевая программа использует вызовы библиотеки нитей
NPTL \fBvfork\fP(). Обработчики fork вызываются в этом случае в программе, в
которой используется библиотека нитей LinuxThreads. (См. в \fBpthreads\fP(7)
описание библиотек нитей Linux.)
.PP
Вызов \fBvfork\fP() эквивалентен вызову \fBclone\fP(2) со следующим значением
\fIflags\fP:
.PP
     CLONE_VM | CLONE_VFORK | SIGCHLD
.SS История
.\" In the release notes for 4.2BSD Sam Leffler wrote: `vfork: Is still
.\" present, but definitely on its way out'.
Системный вызов \fBvfork\fP() впервые появился в 30BSD. В 4.4BSD он стал
синонимом \fBfork\fP(2), но в NetBSD он был введён снова; смотрите
.UR http://www.netbsd.org\:/Documentation\:/kernel\:/vfork.html
.UE .
В
Linux этот системный вызов был эквивалентом \fBfork\fP(2), примерно, до ядра
2.2.0\-pre6. Начиная с 2.2.0\-pre9 (на i386 и немного позже на других
архитектурах), он стал независимым системным вызовом. Его поддержка была
добавлена в glibc 2.0.112.
.SH ДЕФЕКТЫ
.PP
.\"
.\" As far as I can tell, the following is not true in 2.6.19:
.\" Currently (Linux 2.3.25),
.\" .BR strace (1)
.\" cannot follow
.\" .BR vfork ()
.\" and requires a kernel patch.
Обработка сигналов ещё более запутана и различается от системы к системе. В
справочной странице BSD написано следующее: «Для исключения возможности
взаимных блокировок процессы, находящиеся в середине исполнения \fBvfork\fP(),
никогда не получат сигналов \fBSIGTTOU\fP или \fBSIGTTIN\fP, хотя вывод или
\fIioctl\fP всегда разрешены, а попытки ввода приводят к ситуации появления
конца файла».
.SH "СМОТРИТЕ ТАКЖЕ"
\fBclone\fP(2), \fBexecve\fP(2), \fB_exit\fP(2), \fBfork\fP(2), \fBunshare\fP(2),
\fBwait\fP(2)
