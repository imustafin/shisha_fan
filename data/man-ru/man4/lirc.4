.\" -*- mode: troff; coding: UTF-8 -*-
.\" Copyright (c) 2015-2016, Alec Leamas
.\" Copyright (c) 2018, Sean Young <sean@mess.org>
.\"
.\" %%%LICENSE_START(GPLv2+_DOC_FULL)
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, see
.\" <http://www.gnu.org/licenses/>.
.\" %%%LICENSE_END
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH LIRC 4 2019\-03\-06 Linux "Руководство программиста Linux"
.SH ИМЯ
lirc \- устройства lirc
.SH ОПИСАНИЕ
.PP
Символьные устройства \fI/dev/lirc*\fP предоставляют низкоуровневый
двунаправленный интерфейс к аппаратуре с инфракрасным (IR)
управлением. Большинство этих устройств может принимать данные, а не которые
и отправлять. При приёме или отправке данных драйвер работает в двух
различных режимах, в зависимости от имеющейся аппаратуры.
.PP
Некоторая аппаратура (обычно, ТВ\-карты) декодирует IR\-сигнал самостоятельно
и выдаёт обработанные события о нажатых кнопках в виде значений
сканкодов. Драйверы такой аппаратуры работают в режиме
\fBLIRC_MODE_SCANCODE\fP. Обычно, такая аппаратура не поддерживает отправку
IR\-сигналов. Кроме того, она может декодировать ограниченный набор
IR\-протоколов, обычно, только определённых пультов, поставляющихся с ней в
комплекте.
.PP
Другой вид аппаратуры выдаёт потоки длительностей наличия/отсутствия
импульсов. Такие драйверы работают в режиме \fBLIRC_MODE_MODE2\fP. Иногда такая
аппаратура также поддерживает отправку данных через IR. Она может
использоваться с любым (почти) видом аппаратуры. Этот тип аппаратуры также
можно использовать в режиме \fBLIRC_MODE_SCANCODE\fP, в этом случае сигнал
декодируют декодеры ядра. Эти декодеры можно писать в расширенных BPF
(смотрите \fBbpf\fP(2)) и присоединять к устройству \fBlirc\fP.
.PP
.\"
Команда ioctl \fBLIRC_GET_FEATURES\fP (смотрите далее) позволяет определить
доступность приёма и отправки, режимы, а также другие возможности.
.SS "Чтение входящих данных в режиме LIRC_MODE_MODE2"
.PP
В режиме \fBLIRC_MODE_MODE2\fP данные, возвращаемые \fBread\fP(2), представляют
собой 32\-битные значения длительностей наличия/отсутствуя импульсов. Время
длительностей (микросекунды) кодируется в младших 24 битах. Старшими 8 битам
определяется тип пакета:
.TP  4
\fBLIRC_MODE2_SPACE\fP
Значение представляет длительность отсутствия импульса (микросекунды).
.TP  4
\fBLIRC_MODE2_PULSE\fP
Значение представляет длительность импульса (микросекунды).
.TP  4
\fBLIRC_MODE2_FREQUENCY\fP
Значение представляет частоту (Гц); смотрите команду ioctl
\fBLIRC_SET_MEASURE_CARRIER_MODE\fP.
.TP  4
\fBLIRC_MODE2_TIMEOUT\fP
.\"
Значение представляет длительность отсутствия импульса (микросекунды). Пакет
описывает паузу; смотрите ioctl \fBLIRC_SET_REC_TIMEOUT_REPORTS\fP.
.SS "Чтение входящих данных в режиме LIRC_MODE_SCANCODE"
.PP
.\"
В режиме \fBLIRC_MODE_SCANCODE\fP данные, возвращаемые \fBread\fP(2) в структуре
\fIlirc_scancode\fP,  содержат декодированные нажатия кнопок. Сканкод
сохраняется в поле \fIscancode\fP, а протокол IR — в \fIrc_proto\fP. В этом поле
хранится одно из значений \fIenum rc_proto\fP.
.SS "Запись выходных данных в режиме LIRC_MODE_PULSE"
.PP
Данные, записываемые в символьное устройство с помощью \fBwrite\fP(2),
представляют собой последовательность наличия/отсутствия импульсов в виде
целых чисел. Импульсы и их отсутствие неявно разделяются только по их
положению. Данные должны начинаться и заканчиваться импульсом, то есть
всегда должно быть нечётное количество выборок. Функция \fBwrite\fP(2)
блокирует выполнение до тех пор, пока данные не будут переданы
аппаратурой. Если данных больше, чем аппаратура может послать, то
\fBwrite\fP(2) завершается с ошибкой \fBEINVAL\fP.
.SS "Запись выходных данных в режиме LIRC_MODE_SCANCODE"
.PP
Данные, записываемые в символьные устройства, должны храниться в структуре
\fIlirc_scancode\fP. Должны быть заполнены поля \fIscancode\fP и \fIrc_proto\fP,
остальные должны быть равны 0. IR\-кодировщики ядра преобразуют сканкод в
импульсы и паузы. При некорректном протоколе, сканкоде или устройстве
\fBlirc\fP передача невозможна.
.SH "КОМАНДЫ IOCTL"
.PP
Работа ioctl с устройствами LIRC ограничена определением \fIstruct
file_operations\fP функции ioctl, что даёт \fIunsigned int\fP для команды ioctl и
\fIunsigned long\fP для аргумента. С целью переносимости ioctl между 32\-битными
и 64\-битными архитектурами эти значения ограничены 32\-битными значениями.
.PP
.nf
#include <linux/lirc.h>    /* но смотрите ДЕФЕКТЫ */
int ioctl(int fd, int cmd, ...);
.fi
.PP
.\"
Следующие команды ioctl можно использовать для тестирования или изменения
определённых аппаратных настроек через \fBlirc\fP. Для многих команд требуется
третий аргумент, обычно с типом \fIint\fP, который обозначается далее как
\fIval\fP.
.SS "Всегда поддерживаемые команды"
.PP
Устройства \fI/dev/lirc*\fP всегда поддерживают следующие команды:
.TP  4
\fBLIRC_GET_FEATURES\fP (\fIvoid\fP)
Возвращает битовую маску возможностей; смотрите ВОЗМОЖНОСТИ.
.PP
.\"
Если устройство возвращает код ошибки после \fBLIRC_GET_FEATURES\fP, то можно
считать, что это устройство не является \fBlirc\fP.
.SS "Необязательные команды"
.PP
Некоторые устройства \fBlirc\fP поддерживают команды, перечисленные ниже. Если
не утверждается обратное, они завершаются с ошибкой \fBENOTTY\fP, если операция
не поддерживается, или с ошибкой \fBEINVAL\fP, если операция завершилась с
ошибкой или указаны некорректные параметры. Если драйвер не анонсирует
поддержку определённых возможностей, то вызов соответствующих ioctl
завершается с ошибкой \fBENOTTY\fP.
.TP 
\fBLIRC_GET_REC_MODE\fP (\fIvoid\fP)
Если в устройстве \fBlirc\fP нет приёмника, то эта операция завершается ошибкой
\fBENOTTY\fP. В противном случае возвращается режим приёма, который может быть
одним из:
.RS
.TP 
\fBLIRC_MODE_MODE2\fP
Драйвер возвращает последовательность длительностей наличия/ отсутствуя
импульсов.
.TP 
\fBLIRC_MODE_SCANCODE\fP
Драйвер возвращает значения struct \fIlirc_scancode\fP, каждое из которых
представляет декодированное нажатие кнопки.
.RE
.TP 
\fBLIRC_SET_REC_MODE\fP (\fIint\fP)
Задаёт режим приёма. Значением \fIval\fP может быть \fBLIRC_MODE_SCANCODE\fP или
\fBLIRC_MODE_MODE2\fP.Если в устройстве \fBlirc\fP нет приёмника, то эта операция
завершается ошибкой \fBENOTTY\fP.
.TP 
\fBLIRC_GET_SEND_MODE\fP (\fIvoid\fP)
Возвращает режим передачи. Поддерживаются \fBLIRC_MODE_PULSE\fP и
\fBLIRC_MODE_SCANCODE\fP. Если в устройстве \fBlirc\fP нет передатчика, то эта
операция завершается ошибкой \fBENOTTY\fP.
.TP 
\fBLIRC_SET_SEND_MODE\fP (\fIint\fP)
Задаёт режим передачи. Значением \fIval\fP может быть \fBLIRC_MODE_SCANCODE\fP или
\fBLIRC_MODE_PULSE\fP. Если в устройстве \fBlirc\fP нет передатчика, то эта
операция завершается ошибкой \fBENOTTY\fP.
.TP 
\fBLIRC_SET_SEND_CARRIER\fP (\fIint\fP)
Задаёт частоту модуляции. Значением аргумента является частота (в Гц).
.TP 
\fBLIRC_SET_SEND_DUTY_CYCLE\fP (\fIint\fP)
Задаёт скважность несущей частоты (carrier duty cycle). Значение \fIval\fP —
число в диапазоне [0,100], описывающей  ширину импульса в виде процента от
всего сигнала. Значения 0 и 100 не несут какого\-то особенного смысла, но
зарезервированы для использования в будущем.
.IP
.TP 
\fBLIRC_GET_MIN_TIMEOUT\fP (\fIvoid\fP)\fB,\fP \fBLIRC_GET_MAX_TIMEOUT\fP (\fIvoid\fP)
В некоторых устройствах есть встроенные таймеры, которые можно использовать
для обнаружения длительного отсутствия активности IR. Это может помочь
\fBlircd\fP(8) обнаружить окончание сигнала IR и что можно запускать процесс
декодирования. Такие операции возвращают целочисленные значения
минимального/максимального периода ожидания, которое можно задать (в
микросекундах). У некоторых устройств период ожидания нельзя изменить. В
таких драйверах \fBLIRC_GET_MIN_TIMEOUT\fP и \fBLIRC_GET_MAX_TIMEOUT\fP возвращают
ошибку \fBENOTTY\fP.
.TP 
\fBLIRC_SET_REC_TIMEOUT\fP (\fIint\fP)
Задаёт период неактивности IR в виде целого значения
(микросекунды). Корректные значения должны находиться в пределах, полученных
от \fBLIRC_GET_MIN_TIMEOUT\fP и \fBLIRC_GET_MAX_TIMEOUT\fP. Значение 0 (если
поддерживается оборудованием) отключает все аппаратные ожидания и о данных
сообщается сразу после появления. Если точное значение установить
невозможно, то нужно указать следующее \fIбольшее\fP возможное значение.
.TP 
\fBLIRC_GET_REC_TIMEOUT\fP (\fIvoid\fP)
Возвращает текущий период неактивности (в микросекундах). Доступен в Linux с
версии 4.18.
.TP 
\fBLIRC_SET_REC_TIMEOUT_REPORTS\fP (\fIint\fP)
Включает (\fIval\fP равно 1) или выключает пакеты об (\fIval\fP равно 0) ожидании
в \fBLIRC_MODE_MODE2\fP. Работа этой операции в разных версиях ядра отличается:
.RS
.IP * 3
Начиная с Linux 4.16: каждый раз \fBпри открытии устройства lirc\fP сообщения о
неактивности по умолчанию включается для файлового дескриптора
результата. Операцию \fBLIRC_SET_REC_TIMEOUT\fP можно использовать для
выключения (и, если нужно, потом включить заново) ожидания на файловом
дескрипторе.
.IP *
В Linux 4.15 и старее: сообщения о неактивности по умолчанию выключено и его
включение (\fBLIRC_SET_REC_TIMEOUT\fP) на любом файловом дескрипторе, связанном
с устройством \fBlirc\fP, привод к включению ожидания неактивности для всех
файловых дескрипторов, которые ссылаются на устройство (пока неактивность не
будет снова выключена).
.RE
.TP 
\fBLIRC_SET_REC_CARRIER\fP (\fIint\fP)
Задаёт верхнюю границу несущей частоты приёмника (Гц). Смотрите
\fBLIRC_SET_REC_CARRIER_RANGE\fP.
.TP 
\fBLIRC_SET_REC_CARRIER_RANGE\fP (\fIint\fP)
Задаёт нижнюю границу несущей частоты приёмника (Гц). Для выполнения этой
операции сначала нужно задать нижнюю границу с помощью ioctl
\fBLIRC_SET_REC_CARRIER_RANGE\fP, а затем верхнюю границу с помощью ioctl
\fBLIRC_SET_REC_CARRIER\fP.
.TP 
\fBLIRC_SET_MEASURE_CARRIER_MODE\fP (\fIint\fP)
Включает (\fIval\fP равно 1) или выключает (\fIval\fP равно 0) режим
измерения. Если режим включён, то после следующего нажатия клавиши драйвер
пошлёт пакеты \fBLIRC_MODE2_FREQUENCY\fP. По умолчанию должен быть выключен.
.TP 
\fBLIRC_GET_REC_RESOLUTION\fP (\fIvoid\fP)
Возвращает точность разрешения драйвера (в микросекундах).
.TP 
\fBLIRC_SET_TRANSMITTER_MASK\fP (\fIint\fP)
Включает набор передатчиков, указанных в \fIval\fP в виде битовой маски, где
каждый включаемый передатчик обозначен 1. Первый передатчик кодируется в
самом младшем бите и т. д. Если указана некорректная битовая маска,
например, указан бит, но в устройстве нет столько передатчиков, то данная
операция возвращает количество доступных передатчиков и ничего не делает.
.TP 
\fBLIRC_SET_WIDEBAND_RECEIVER\fP (\fIint\fP)
У некоторых устройств есть специальный широкополосный приёмник, который
предназначен для обучения выводу существующего пульта. Данную ioctl можно
использовать для включения (\fIval\fP равно 1) или отключения (\fIval\fP равно 0)
этого свойства. Это может быть полезно для устройств с узкополосными
приёмниками, которые не могут работать с некоторыми пультами. Широкополосные
приёмники могут иметь большую точность. С другой стороны, их недостаток в
меньшей дальности приёма.
.IP
.\"
Замечание: широкополосные приёмники могут неявно включаться, если вы
включаете сообщения о несущей. В этом случае, он отключится сразу после
отключения сообщений о несущей. Попытка отключить широкополосный приёмник
при включённых сообщениях о несущей ни к чему не приводит.
.SH ВОЗМОЖНОСТИ
.PP
ioctl \fBLIRC_GET_FEATURES\fP возвращает битовую маску, описывающую свойства
драйвера. В маске могут быть установлены следующие биты:
.TP 
\fBLIRC_CAN_REC_MODE2\fP
Драйвер способен вести приём в режиме \fBLIRC_MODE_MODE2\fP.
.TP 
\fBLIRC_CAN_REC_SCANCODE\fP
Драйвер способен вести приём в режиме \fBLIRC_MODE_SCANCODE\fP.
.TP 
\fBLIRC_CAN_SET_SEND_CARRIER\fP
Драйвер поддерживает изменение частоты модуляции с помощью
\fBLIRC_SET_SEND_CARRIER\fP.
.TP 
\fBLIRC_CAN_SET_SEND_DUTY_CYCLE\fP
Драйвер поддерживает изменение опорного сигнала с помощью
\fBLIRC_SET_SEND_DUTY_CYCLE\fP.
.TP 
\fBLIRC_CAN_SET_TRANSMITTER_MASK\fP
Драйвер поддерживает изменение передатчика(ов) с помощью
\fBLIRC_SET_TRANSMITTER_MASK\fP.
.TP 
\fBLIRC_CAN_SET_REC_CARRIER\fP
Драйвер поддерживает установку частоты приёмной несущей с помощью
\fBLIRC_SET_REC_CARRIER\fP. Из\-за объединения драйверов в ядре версии 2.6.36
любое устройство \fBlirc\fP должно устанавливать
\fBLIRC_CAN_SET_REC_CARRIER_RANGE\fP, если указано свойство
\fBLIRC_CAN_SET_REC_CARRIER\fP.
.TP 
\fBLIRC_CAN_SET_REC_CARRIER_RANGE\fP
Драйвер поддерживает \fBLIRC_SET_REC_CARRIER_RANGE\fP. Перед использованием
ioctl \fBLIRC_SET_REC_CARRIER\fP для указания верхней границы,нужно вызвать
ioctl \fBLIRC_SET_REC_CARRIER_RANGE\fP для указания нижней границы несущей.
.TP 
\fBLIRC_CAN_GET_REC_RESOLUTION\fP
Драйвер поддерживает \fBLIRC_GET_REC_RESOLUTION\fP.
.TP 
\fBLIRC_CAN_SET_REC_TIMEOUT\fP
Драйвер поддерживает \fBLIRC_SET_REC_TIMEOUT\fP.
.TP 
\fBLIRC_CAN_MEASURE_CARRIER\fP
Драйвер поддерживает измерение частоты модуляции с помощью
\fBLIRC_SET_MEASURE_CARRIER_MODE\fP.
.TP 
\fBLIRC_CAN_USE_WIDEBAND_RECEIVER\fP
Драйвер поддерживает режим обучения с помощью \fBLIRC_SET_WIDEBAND_RECEIVER\fP.
.TP 
\fBLIRC_CAN_SEND_PULSE\fP
.\"
Драйвер поддерживает отправку в режиме \fBLIRC_MODE_SCANCODE\fP или
\fBLIRC_MODE_SCANCODE\fP.
.SH ДЕФЕКТЫ
.\"
Для использования этих устройств требуется заголовочный файл ядра
\fIlirc.h\fP. Этот файл был недоступен до ядра версии 4.6. Пользователи старых
ядер могут использовать файл с сайта
.UR http://www.lirc.org
.UE .
.SH "СМОТРИТЕ ТАКЖЕ"
\fBir\-ctl\fP(1), \fBlircd\fP(8),\ \fBbpf\fP(2)
.PP
https://www.kernel.org/doc/html/latest/media/uapi/rc/lirc\-dev.html
