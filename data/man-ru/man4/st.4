.\" -*- mode: troff; coding: UTF-8 -*-
.\" Copyright 1995 Robert K. Nichols (Robert.K.Nichols@att.com)
.\" Copyright 1999-2005 Kai Mäkisara (Kai.Makisara@kolumbus.fi)
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH ST 4 2019\-03\-06 Linux "Руководство программиста Linux"
.SH ИМЯ
st \- ленточный накопитель SCSI
.SH ОБЗОР
.nf
\fB#include <sys/mtio.h>\fP
.PP
\fBint ioctl(int \fP\fIfd\fP\fB, int \fP\fIrequest\fP\fB [, (void *)\fP\fIarg3\fP\fB]);\fP
\fBint ioctl(int \fP\fIfd\fP\fB, MTIOCTOP, (struct mtop *)\fP\fImt_cmd\fP\fB);\fP
\fBint ioctl(int \fP\fIfd\fP\fB, MTIOCGET, (struct mtget *)\fP\fImt_status\fP\fB);\fP
\fBint ioctl(int \fP\fIfd\fP\fB, MTIOCPOS, (struct mtpos *)\fP\fImt_pos\fP\fB);\fP
.fi
.SH ОПИСАНИЕ
Драйвер \fBst\fP предоставляет интерфейс к различным ленточным накопителям
SCSI. В настоящее время драйвер позволяет управлять любыми устройствами
"последовательного доступа". Драйвер \fBst\fP использует для устройств старший
номер 9.
.PP
Для каждого устройства есть восемь младших номеров. Первые пять битов в
младших номерах определяют последовательность обнаружения. В ядрах 2.6
первые восемь битов объединяются с первыми пятью битами для создания номера
ленты. Младшие номера могут быть сгруппированы в два набора из четырех
чисел: основные младшие номера для устройств (\fIn\fP) с автоперемоткой и
номера устройств без автоперемотки (\fIn\fP + 128). При открытии устройства с
основным младшим номером, будет послана команда \fBREWIND\fP. При открытии с
использованием устройства без автоперемотки этого произведено не
будет. (Заметим, что использование устройства с автоперемоткой для установки
ленты в определённое положение, например, mt, не даст желаемого результата:
лента перемотается после команды mt, и следующая команда будет выполняться с
начала ленты).
.PP
В каждой группе четыре младших номера доступны для определения устройств с
особыми характеристиками (такими как: размер блока, сжатие, плотность и
другое). Когда система запускается, доступно только первое
устройство. Другие три приводятся в действие, когда определены некоторые их
характеристики (смотрите ниже). Путем изменения константы при компиляции
возможно изменение баланса между максимальным числом ленточных накопителей и
числом из младших номеров каждого накопителя. Начальное значение позволяет
контролировать 32 ленточных устройства. Например, возможно контролировать до
64\-х ленточных устройств с двумя младшими номерами для различных параметров.
.PP
Устройства обычно создаются так:
.PP
.in +4n
.EX
mknod \-m 666 /dev/st0 c 9 0
mknod \-m 666 /dev/st0l c 9 32
mknod \-m 666 /dev/st0m c 9 64
mknod \-m 666 /dev/st0a c 9 96
mknod \-m 666 /dev/nst0 c 9 128
mknod \-m 666 /dev/nst0l c 9 160
mknod \-m 666 /dev/nst0m c 9 192
mknod \-m 666 /dev/nst0a c 9 224
.EE
.in
.PP
Соответствующее блочное устройство отсутствует.
.PP
Драйвер использует внутренний буфер, которого достаточно для сохранения, как
минимум, одного блока ленты. В ядре до версии 2.1.121 буфер выделялся как
один непрерывный блок. Это ограничивало размер блока самым большим
непрерывным участком памяти, которое может выделить ядро. Ограничение в
настоящее время составляет: 128\ Кбайт для 32\-битной и 256\ Кбайт для
64\-битной архитектуры. В новейших ядрах драйвер располагает буфер в
нескольких частях, если это необходимо. По умолчанию максимальное число
частей \(em 16. Таким способом можно сделать максимальный размер блока очень
большим (2\ МБ, если выделяется 16 блоков по 128\ Кбайт).
.PP
Размер внутреннего буфера драйвера определяется константой при сборке; эта
константа может быть изменена при загрузке ядра. Вдобавок к этому, драйвер
пытается разместить больший временный буфер во время запуска, если это
необходимо. Тем не менее, размещение во время запуска больших блоков памяти
может завершиться неудачно, и лучше не полагаться на динамическое размещение
буфера в ядре до версии 2.1.121 (это применяется также при загрузке драйвера
по требованию с помощью kerneld или kmod).
.PP
В драйвере нет специальной поддержки для устройств определённых
производителей или моделей. После старта системы параметры ленточного
устройства определяются микропрограммой устройства. Для примера, если
микропрограмма выбирает режим с блоками одинакового размера, то ленточное
устройство использует этот режим. Параметры могут быть изменены вызовами
\fBioctl\fP(2) и действуют до тех пор, пока устройство не закрыто и потом не
открыто вновь. Установка параметров влияет на оба устройства (с
автоперемоткой и без автоперемотки).
.PP
Внутри подгруппы четырёх устройств для каждого могут быть заданы особые
параметры. Параметры начинают работать, когда устройство открывается. Для
примера, системный администратор может определить одно устройство, которое
записывает данные в режиме блоков одинакового размера с задаваемым размером
и другое, которое записывает данные в режиме блоков с разным размером (если
накопитель поддерживает оба режима).
.PP
Драйвер поддерживает \fBленточные разделы\fP, но только если их поддерживает
само устройство. Заметим, что ленточные разделы не имеют ничего общего с
разделами диска. Размеченная лента одного носителя может выглядеть как
несколько логических лент. Поддержка разделов включается с помощью
\fBioctl\fP(2). Местоположение ленты зафиксировано внутри каждого раздела. При
последующих ленточных операциях используется нужный раздел, выбранный с
помощью \fBioctl\fP(2). Переключение раздела выполняется вместе со следующей
операцией с лентой во избежании ненужной перемотки. Максимальное число
разделов на ленте определяется константой при компиляции (изначально оно
равно четырём). Драйвер содержит вызов \fBioctl\fP(2), который позволяет
форматировать ленту с одним или двумя разделами.
.PP
Обычно, в системе создаётся устройство \fI/dev/tape\fP в виде жёсткой или
символьной ссылки на ленточное устройство по умолчанию.
.PP
Начиная с ядра 2.6.2, драйвер экспортирует в каталог sysfs в файл
\fI/sys/class/scsi_tape\fP подключённые устройства и некоторые их параметры.
.SS "Передача данных"
Драйвер поддерживает операции в обоих режимах: с постоянным и переменным
размером блоков (только если оба режима поддерживает само устройство). В
режиме с постоянным размером блока устройство выполняет запись блоками
заданного размера, и размер блока не зависит от количества байтов, которые
записываются системными вызовами. В режиме с переменным размером блока один
блок ленты записывается при каждом вызове записи, и размер соответствующего
блока ленты определяется в соответствии с количеством записываемых
байт. Заметим, что блоки ленты не содержат информации о режиме записи: при
чтении единственно важной вещью является использование нужных команд,
которые принимают размеры блоков ленты.
.PP
В режиме с переменным размером блока при чтении количество байтов не
совпадает точно с размером блока ленты. Если количество байтов больше, чем в
следующем блоке ленты, драйвер возвращает данные, а функция возвращает
реальный размер блока. Если размер блока больше, чем количество байтов, то
возвращается ошибка.
.PP
При чтении в режиме с постоянным размером блока количества байтов может быть
произвольным, если включена буферизация, или пропорциональным размеру блока
ленты, если буферизация выключена. Ядра версий до 2.1.121, позволяли
записывать произвольное количество байтов, если включена буферизация. Во
всех других случаях (ядра до 2.1.121 с выключенной буферизацией и новые
ядра) количество байтов должно быть пропорциональным размеру блока ленты.
.PP
В ядрах 2.6 драйвер пытается использовать прямую пересылку между
пользовательским буфером и устройством. Если это невозможно, то используется
внутренний буфер драйвера. Причинами отказа от использования прямой
пересылки может быть включение неправильного выравнивания пользовательского
буфера (по умолчанию 512 байт, но может быть изменено драйвером HBA), одна
или более страниц пользовательского буфера недостижима из адаптера SCSI и
т. п.
.PP
Маркер файла автоматически записывается на ленту, если последней операцией
до закрытия была запись.
.PP
Когда при чтении обнаруживается маркер файла, происходит следующее. Если при
обнаружении маркера есть данные в буфере, то возвращаются данные
буфера. Следующее чтение вернёт ноль байтов. Затем вернёт данные из
следующего файла. О конце записанных данных будет сообщено возвращением нуля
байтов в двух операциях чтения подряд. И, наконец, третье чтение вернёт
ошибку.
.SS "Вызовы ioctl"
Драйвер поддерживает три запроса \fBioctl\fP(2). Запросы, не опознанные
драйвером \fBst\fP, пропускаются в драйвер \fBSCSI\fP. Определения, приведённые
далее, взяты из \fI/usr/include/linux/mtio.h\fP:
.SS "MTIOCTOP \(em выполнение операций с лентой"
.PP
Для этого запроса требуется аргумент с типом \fI(struct mtop\ *)\fP. Не все
устройства поддерживает все операции. Драйвер возвращает ошибку \fBEIO\fP, если
устройство не выполнило операцию.
.PP
.in +4n
.EX
/* Структура для MTIOCTOP \- операция с маг. лентой */
struct mtop {
    short   mt_op;       /* операции перечислены далее */
    int     mt_count;    /* их количество */
};
.EE
.in
.PP
Операции с магнитной лентой для обычного использования:
.TP  14
\fBMTBSF\fP
Перемотка ленты на \fImt_count\fP файловых маркеров назад.
.TP 
\fBMTBSFM\fP
Перемотка ленты на \fImt_count\fP файловых маркеров назад. Перемотка ленты на
сторону EOT последнего маркера файла.
.TP 
\fBMTBSR\fP
Перемотка ленты на \fImt_count\fP записей назад (блоков ленты).
.TP 
\fBMTBSS\fP
Перемотка ленты на \fImt_count\fP сборочных маркеров (setmarks) назад.
.TP 
\fBMTCOMPRESSION\fP
Включение режима сжатия данных на ленте устройства, если \fImt_count\fP не
равно 0, и отключение сжатия, если \fImt_count\fP равно 0. Эта команда
использует MODE page 15, поддерживаемую многими DAT\-устройствами.
.TP 
\fBMTEOM\fP
Переход в конец записанных на носителе данных (для добавления файлов).
.TP 
\fBMTERASE\fP
Стирание ленты. В ядре 2.6 выполняется быстрое стирание (удаление маркера
ленты), если аргумент равен 0. В противном случае выполняется полное
стирание.
.TP 
\fBMTFSF\fP
Перемотка ленты на \fImt_count\fP файловых маркеров вперёд.
.TP 
\fBMTFSFM\fP
Перемотка ленты на \fImt_count\fP файловых маркеров вперёд. Перемотка ленты на
сторону BOT последнего маркера файла.
.TP 
\fBMTFSR\fP
Перемотка ленты на \fImt_count\fP записей вперёд (блоков ленты).
.TP 
\fBMTFSS\fP
Перемотка ленты на \fImt_count\fP сборочных маркеров вперёд.
.TP 
\fBMTLOAD\fP
Выполнение SCSI\-команды загрузки. Для некоторых автозагрузчиков HP
выполняется особое действие. Если \fImt_count\fP равно константе
\fBMT_ST_HPLOADER_OFFSET\fP плюс  некоторое число, то это значение передаётся
устройству для управления автозагрузчиком.
.TP 
\fBMTLOCK\fP
Блокирование дверцы ленточного устройства.
.TP 
\fBMTMKPART\fP
.\" commit 8038e6456a3e6f5c4759e0d73c4f9165b90c93e7
Форматирование ленты на один или два раздела. Если \fImt_count\fP положительно,
то оно определяет размер раздела 1, а раздел 0 займёт остаток ленты. Если
\fImt_count\fP равно 0, то лента форматируется с одним разделом. Для ядра
версии 4.6: отрицательное значение \fImt_count\fP задаёт размер раздела 0, а
раздел 1 займёт остаток ленты. Физический порядок разделов зависит от
устройства. Эта команда запрещена для устройств, не поддерживающих разделы
(смотрите \fBMT_ST_CAN_PARTITIONS\fP далее).
.TP 
\fBMTNOP\fP
Нет операции, как побочный эффект — сброс буфера устройства. Операция должна
выполняться до чтения состояния с помощью \fBMTIOCGET\fP.
.TP 
\fBMTOFFL\fP
Перемотка ленты и отключение устройства.
.TP 
\fBMTRESET\fP
Возврат устройства в исходное состояние.
.TP 
\fBMTRETEN\fP
Подтягивание ленты.
.TP 
\fBMTREW\fP
Перемотка ленты назад.
.TP 
\fBMTSEEK\fP
Переход к блоку ленты с номером \fImt_count\fP. Эта операция требует устройства
SCSI\-2, поддерживающего команду \fBLOCATE\fP (адрес, определяемый устройством),
или Tandberg\-совместимого устройства SCSI\-1 (Tandberg, Archive Viper,
Wangtek, ... ). Номер блока должен быть равен значению, которое было
получено ранее с помощью \fBMTIOCPOS\fP, если используется адрес, определяемый
устройством.
.TP 
\fBMTSETBLK\fP
Задание размера блока устройства равному \fImt_count\fP. Нулевое значение
включает режим с переменным размером блоков.
.TP 
\fBMTSETDENSITY\fP
Задание плотности данных на ленте равной \fImt_count\fP. Коды плотности данных,
поддерживаемые устройством, можно найти в документации к устройству.
.TP 
\fBMTSETPART\fP
Переключение активного раздела на номер \fImt_count\fP. Разделы нумеруются
начиная с нуля. Эта команда только для устройств с включённой поддержкой
разделов (см. \fBMT_ST_CAN_PARTITIONS\fP далее).
.TP 
\fBMTUNLOAD\fP
Выполнение SCSI\-команды выгрузки (но лента не выталкивается).
.TP 
\fBMTUNLOCK\fP
Разблокирование дверцы ленточного устройства.
.TP 
\fBMTWEOF\fP
Запись \fImt_count\fP маркеров файлов.
.TP 
\fBMTWSM\fP
Запись \fImt_count\fP сборочных маркеров.
.PP
Операции с магнитной лентой по установке параметров устройства (для
суперпользователя):
.TP  8
\fBMTSETDRVBUFFER\fP
Установка различных параметров устройства и драйвера согласно битам
\fImt_count\fP. Задаётся режим буферизации устройства, набор логических
параметров драйвера, порог буфера записи, значения по умолчанию для размера
блока, плотности и время ожидания (только для ядра версии 2.1 или более
поздних). Одна операция может присваивать значение только одного пункта из
списка выше (логические параметры считаются за одну).
.IP
Нулевое значение старших 4\-х битов будет использовано для установки режима
буферизации устройства. Режимы буферизации:
.RS 12
.IP 0 4
Устройство не сообщит, что запись прошла успешно (\fBGOOD\fP) до тех пор, пока
блоки данных фактически не будут записаны на носитель.
.IP 1
Устройство может сообщить, что запись прошла успешно после того, как все
данные будут перемещены во внутренний буфер устройства.
.IP 2
Устройство может сообщить, что запись прошла успешно после того, как: (а)
все данные будут перемещены во внутренний буфер устройства и (б) все
буферизованные данные из различных источников были успешно записаны на
носитель.
.RE
.IP
Для контроля записи пороговое значение \fImt_count\fP должно включать в себя
константу \fBMT_ST_WRITE_THRESHOLD\fP побитно сложенную (OR) с счётчиком
блоков в первых 28\-и битах. Счётчик блоков содержит количество блоков по
1024 байта, а не физических блоков на ленте. Пороговое значение не может
превышать размер внутреннего буфера устройства. (см. ОПИСАНИЕ выше).
.IP
Для установки и очистки логических параметров значение \fImt_count\fP должно
включать в себя одну из констант: \fBMT_ST_BOOLEANS\fP, \fBMT_ST_SETBOOLEANS\fP,
\fBMT_ST_CLEARBOOLEANS\fP, \fBMT_ST_DEFBOOLEANS\fP  или любую их побитно сложенную
комбинацию. Используя параметры \fBMT_ST_BOOLEANS\fP можно задать значения
соответствующими битами. С помощью параметров \fBMT_ST_SETBOOLEANS\fP можно
выборочно установить, а с помощью \fBMT_ST_DEFBOOLEANS\fP \(em выборочно
сбросить некоторые биты.
.IP ""
Параметры по умолчанию для ленточного устройства устанавливаются с помощью
\fBMT_ST_DEFBOOLEANS\fP. Неактивное ленточное устройство (например, устройство
с младшим номером 32 или 160) активируется когда для него назначаются
параметры по умолчанию в первый раз. Активированное устройство наследует
параметры, которые не заданы явно, от устройства, активированного при
загрузке ОС.
.IP ""
Логические параметры:
.RS
.TP 
\fBMT_ST_BUFFER_WRITES\fP (по умолчанию true)
Выполнять буферизацию чтения и опережающее чтение в режиме с постоянным
размером блока. Если значение параметра равно false и устройство использует
режим с постоянным размером блока, то во всех операциях чтения должны
использоваться блоки кратной длины. Для надёжной записи многотомных архивов
значение этого параметра должно быть равно false.
.TP 
\fBMT_ST_ASYNC_WRITES\fP (по умолчанию true)
Когда значение этого параметра равно true, то операции записи сразу
завершаются, не дожидаясь пока данные переместятся в устройство, если данные
помещаются в буфер драйвера. Порог записи определяет, насколько должен быть
заполнен буфер до ввода новых SCSI\-команд. Любые ошибки, возвращённые
устройством, хранятся до следующей операции. Для надёжной записи многотомных
архивов значение этого параметра должно быть равно false.
.TP 
\fBMT_ST_READ_AHEAD\fP (по умолчанию true)
Этот параметр указывает драйверу выполнять буферизацию чтения и опережающее
чтение в режиме с постоянным размером блока. Если значение параметра равно
false и устройство использует режим с постоянным размером блока, то во всех
операциях чтения должны использоваться блоки кратной длины.
.TP 
\fBMT_ST_TWO_FM\fP (по умолчанию false)
Этот параметр изменяет поведение драйвера после закрытия файла. По умолчанию
драйвер записывает один маркер файла. Если значение параметра равно true, то
драйвер запишет два маркера файла и вернётся на место второго.
.IP
Замечание: этому параметру не может быть присвоено значение true для
ленточных устройств QIC, так как  они не могут перезаписать маркер
файла. Они находят конец записанных данных ища пустое место на ленте, а не
два последовательных маркера файла. Многие современные устройства также
находят конец записанных данных, и использование двух меток файла обычно
необходимо только при одновременном использовании лент в нескольких разных
системах.
.TP 
\fBMT_ST_DEBUGGING\fP (по умолчанию false)
Этот параметр включает вывод отладочных сообщений драйвера (работает только
в том случае, если драйвер был собран с ненулевым значением \fBDEBUG\fP).
.TP 
\fBMT_ST_FAST_EOM\fP (по умолчанию false)
Этот параметр заставляет посылать операцию \fBMTEOM\fP непосредственно
устройству, потенциально увеличивая скорость операций, но возникает
опасность потерять дорожку текущего файла, номер которой обычно возвращается
по запросу \fBMTIOCGET\fP. Если значение параметра \fBMT_ST_FAST_EOM\fP равно
false, то драйвер отвечает на запрос \fBMTEOM\fP, перематывая ленту к концу
записанных файлов.
.TP 
\fBMT_ST_AUTO_LOCK\fP (по умолчанию false)
Когда этому параметру присвоено значение true, дверца блокируется, если
устройство открыто, и дверца разблокируется, когда устройство закрыто.
.TP 
\fBMT_ST_DEF_WRITES\fP (по умолчанию false)
Параметры ленты (размер блока, режим, сжатие и т.д.) могут изменяться, когда
выполняется переход от одного устройства к другому устройству, которое
связано с тем же устройством, в зависимости от того, как определяются
устройства. Этот параметр определяет, будут ли применяться изменения через
драйвер при помощи команд SCSI, или устройство само определит возможности,
которые будут использоваться. Если значение параметра равно false, то
драйвер будет посылать команды SCSI сразу после смены устройства. Если
значение параметра равно true, команды SCSI не отправляются до запроса
записи. В этом случае микропрограмма устройства позволяет выполнить
обнаружение структуры ленты во время чтения, а команды SCSI используются
только для проверки правильности записи на ленту в соответствии со
спецификацией.
.TP 
\fBMT_ST_CAN_BSR\fP (по умолчанию false)
Если используется упреждающее чтение, лента должна быть иногда перемотана
назад для правильного её размещения при закрытом устройстве. Для перемотки
ленты назад используется команда SCSI. Некоторые старые устройства не могут
правильно обрабатывать эту команду, и этот параметр может использоваться для
того, чтобы указать драйверу не применять данную команду. В конечном итоге,
с упреждающим чтением и в режиме с постоянным размером блока может быть
неверно определено местоположение файла при закрытом устройстве. В ядре 2.6
значение параметра равно true для устройств с поддержкой SCSI\-3.
.TP 
\fBMT_ST_NO_BLKLIMS\fP (по умолчанию false)
Некоторые устройства не понимают SCSI\-команду \fBREAD BLOCK LIMITS\fP. Если
параметр установлен, то драйвер не исполняет эту команду. Недостатком этого
является невозможность проверки драйвером до отправки команд, поддерживается
ли устройством выбранный размер блока.
.TP 
\fBMT_ST_CAN_PARTITIONS\fP (по умолчанию false)
Этот параметр даёт возможность поддерживать несколько разделов на ленте. Он
применяется ко всем файлам устройств, связанным с устройством.
.TP 
\fBMT_ST_SCSI2LOGICAL\fP (по умолчанию false)
Этот параметр заставляет драйвер использовать адресацию логических блоков,
определённую в стандарте SCSI\-2 для выполнения операций поиска и пересчёта
(с командами \fBMTSEEK\fP и \fBMTIOCPOS\fP и в том случае, когда изменяются
разделы ленты). Желательно установить этот параметр, если устройство
поддерживает логические адреса, потому что они рассчитывают также и маркеры
файлов. Некоторые устройства поддерживают только адресацию логических
блоков.
.TP 
\fBMT_ST_SYSV\fP (по умолчанию false)
Когда этот параметр установлен, ленточные устройства используют семантику
SystemV. В других случаях используется семантика BSD. Основное  различие
между ними (когда устройство, используемое для чтения, закрыто) состоит в
следующем: по семантике SYSV лента перематывается вперед за следующий маркер
файла, если этого не произошло во время использования устройства. В
семантике BSD позиция на ленте не меняется.
.TP 
\fBMT_NO_WAIT\fP (по умолчанию false)
Включает режим без задержки (т.е., не ждать завершения работы команды) для
некоторых команд (например, rewind).
.PP
Пример:
.PP
.in +4n
.EX
struct mtop mt_cmd;
mt_cmd.mt_op = MTSETDRVBUFFER;
mt_cmd.mt_count = MT_ST_BOOLEANS |
        MT_ST_BUFFER_WRITES | MT_ST_ASYNC_WRITES;
ioctl(fd, MTIOCTOP, mt_cmd);
.EE
.in
.RE
.IP ""
Размер блока по умолчанию для устройства может быть установлен с помощью
\fBMT_ST_DEF_BLKSIZE\fP, а плотность данных по умолчанию может быть установлена
с помощью \fBMT_ST_DEFDENSITY\fP. Значения параметров логически складываются с
кодом операции.
.IP ""
В ядре версии 2.1.x и более поздних время ожидания может быть установлено
подкомандой \fBMT_ST_SET_TIMEOUT\fP логически сложенной со значением
ожидания. Долгое время ожидания (используется при перемотке и выполнении
других команд, занимающих длительное время) может быть установлено с помощью
\fBMT_ST_SET_LONG_TIMEOUT\fP. Значения, используемые в ядре по умолчанию,
слишком велики, для уверенности в том, время ожидания не истечёт. Из\-за
этого драйвер может надолго застрять в ожидании. Эти команды могут быть
использованы для установки оптимальных для значений различных
устройств. Установка времени ожидания для одного устройства применяется для
всех файлов устройств, связанных с этим устройством.
.IP ""
Начиная с ядер 2.4.19 и 2.5.43, в драйвере появился бит состояния, который
показывает, была ли запрошена очистка у устройства. Метод, используемый
устройством для возврата информации об очистке, задаётся с помощью
подкоманды \fBMT_ST_SEL_CLN\fP. Если значение равно 0, то бит очистки всегда
ноль. Если значение равно 1, то используются данные TapeAlert, определённые
в стандарте SCSI\-3 (пока не реализовано). Значения 2\(en17
зарезервированы. Если самые младшие восемь бит >= 18, то используются
биты из расширенных данных уточнённого состояния (extended sense data). Биты
9\(en16 задают маску для выбора бит, которые должны просматриваться, а биты
17\(en23 задают битовый шаблон поиска. Если битовый шаблон равен 0, то один
или более бит в маске указывают на запрос очистки. Если шаблон не равен
нулю, то шаблон должен совпадать с байтом уточнённого состояния согласно
маске.
.SS "MTIOCGET \(em получение состояния ленты"
.PP
Для этого запроса требуется аргумент с типом \fI(struct mtget\ *)\fP.
.PP
.in +4n
.EX
/* структура для MTIOCGET \- команда получения состояния ленты */
struct mtget {
    long     mt_type;
    long     mt_resid;
    /* следующие регистры зависят от устройства */
    long     mt_dsreg;
    long     mt_gstat;
    long     mt_erreg;
    /* следующие два поля используются не всегда */
    daddr_t  mt_fileno;
    daddr_t  mt_blkno;
};
.EE
.in
.IP \fImt_type\fP 11
В заголовочном файле определено множество значений \fImt_type\fP, но текущий
драйвер сообщает только об общих типах \fBMT_ISSCSI1\fP (лента общего типа
SCSI\-1) и \fBMT_ISSCSI2\fP (лента общего типа SCSI\-2).
.IP \fImt_resid\fP
Содержит номер текущего раздела ленты.
.IP \fImt_dsreg\fP
Содержит текущие настройки размера блока устройства (в младших 24\-х битах) и
плотность (в старших 8\-х битах). Эти поля определяются с помощью
\fBMT_ST_BLKSIZE_SHIFT\fP, \fBMT_ST_BLKSIZE_MASK\fP, \fBMT_ST_DENSITY_SHIFT\fP и
\fBMT_ST_DENSITY_MASK\fP.
.IP \fImt_gstat\fP
Содержит общую (независимую от устройства) информацию о состоянии. В
заголовочном файле определены макросы для тестирования бит:
.RS
.HP 4
\fBGMT_EOF\fP(\fIx\fP): Текущая позиция сразу после маркера файла (всегда false
после выполнения операции \fBMTSEEK\fP).
.HP
\fBGMT_BOT\fP(\fIx\fP): Текущая позиция на начале первого файла (всегда false
после операции \fBMTSEEK\fP).
.HP
\fBGMT_EOT\fP(\fIx\fP): Текущая позиция у физического конца ленты.
.HP
\fBGMT_SM\fP(\fIx\fP): Текущая позиция на сборочном маркере (всегда false после
выполнения операции \fBMTSEEK\fP).
.HP
\fBGMT_EOD\fP(\fIx\fP): Текущая позиция в конце записанных данных.
.HP
\fBGMT_WR_PROT\fP(\fIx\fP): Устройство защищено от записи. Для некоторых устройств
это может означать, что они не поддерживают запись на установленный носитель
(неподдерживаемый тип).
.HP
\fBGMT_ONLINE\fP(\fIx\fP): Последний вызов \fBopen\fP(2) привёл к тому, что лента в
нужном месте и устройство готово к работе.
.HP
\fBGMT_D_6250\fP(\fIx\fP), \fBGMT_D_1600\fP(\fIx\fP), \fBGMT_D_800\fP(\fIx\fP): "Общая"
информация о текущей плотности только для 9\-дорожечных \(12" устройств.
.HP
\fBGMT_DR_OPEN\fP(\fIx\fP): Нет ленты в устройстве.
.HP
\fBGMT_IM_REP_EN\fP(\fIx\fP): Сообщает о режиме. Этот бит устанавливается, если
нет гарантии, что данные были правильно физически записаны на ленту после
возврата из функции записи. Этот бит приобретает нулевое значение, когда
драйвер не записывает данные в буфер и устройство не настроено на
буферизацию данных.
.HP
\fBGMT_CLN\fP(\fIx\fP): У устройства запросили очистку. Реализовано в ядрах,
начиная с 2.4.19 и 2.5.43.
.RE
.IP \fImt_erreg\fP
Содержит счётчик (младшие 16 бит) исправленных ошибок, определяемых с
помощью \fBMT_ST_SOFTERR_SHIFT\fP и \fBMT_ST_SOFTERR_MASK\fP. Из\-за
противоречивости способов сообщения об исправленных ошибках устройствами,
часто этот счётчик не ведётся (большинство устройств по умолчанию не
сообщают об исправленных ошибках, это можно изменить с помощью SCSI\-команды
MODE SELECT).
.IP \fImt_fileno\fP
Содержит текущий номер файла (отсчёт ведётся с 0). Если номер файла
неизвестен, то значение равно \-1 (например, после \fBMTBSS\fP или \fBMTSEEK\fP).
.IP \fImt_blkno\fP
Содержит номер блока (отсчёт ведётся с 0) в пределах текущего файла. Если
номер блока неизвестен, то значение равно \-1 (например, после \fBMTBSF\fP,
\fBMTBSS\fP или \fBMTSEEK\fP).
.SS "MTIOCPOS \(em получение текущей позиции ленты"
.PP
Для этого запроса требуется аргумент с типом \fI(struct mtpos\ *)\fP. Он
возвращает текущий номер блока ленты, который необязательно совпадает со
значением \fImt_blkno\fP, возвращаемым \fBMTIOCGET\fP. Устройство должен быть
SCSI\-2, чтобы поддерживать команду \fBREAD POSITION\fP (адрес, определяемый
устройством), или Tandberg\-совместимым устройством SCSI\-1 (Tandberg, Archive
Viper, Wangtek, …).
.PP
.in +4n
.EX
/* структура для MTIOCPOS \- команда получения позиции на ленте */
struct mtpos {
    long mt_blkno;    /* текущий номер блока */
};
.EE
.in
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
.TP  14
.TP 
\fBEACCES\fP
Попытка записать или стереть ленту, защищённую от записи. (Эта ошибка не
возникает при \fBopen\fP(2).)
.TP 
\fBEBUSY\fP
Устройство уже используется, или драйвер не способен выделить буфер.
.TP 
\fBEFAULT\fP
Параметры команды указывают на память, не принадлежащую вызывающему
процессу.
.TP 
\fBEINVAL\fP
Вызову \fBioctl\fP(2) был передан неверный аргумент, или запрошен неправильный
размер блока.
.TP 
\fBEIO\fP
Запрошенные операции не могут быть завершены.
.TP 
\fBENOMEM\fP
.\" Precisely: Linux 2.6.0-test6
Счётчик байт в \fBread\fP(2) меньше чем следующий физический блок ленты (до
версии 2.2.18 и 2.4.0 лишние байты просто игнорировались).
.TP 
\fBENOSPC\fP
Операция записи не может завершиться, потому что лента закончилась.
.TP 
\fBENOSYS\fP
Неизвестный вызов \fBioctl\fP(2).
.TP 
\fBENXIO\fP
Во время открытия обнаружено, что ленточного устройства не существует.
.TP 
\fBEOVERFLOW\fP
Попытка чтения или записи блоков переменной длины, больших, чем внутренний
буфер драйвера.
.TP 
\fBEROFS\fP
Попытка открытия с параметром \fBO_WRONLY\fP или \fBO_RDWR\fP, но лента в
устройстве защищена от записи.
.SH ФАЙЛЫ
.TP 
\fI/dev/st*\fP
ленточные устройства SCSI с автоперемоткой
.TP 
\fI/dev/nst*\fP
.\" .SH AUTHOR
.\" The driver has been written by Kai M\(:akisara (Kai.Makisara@metla.fi)
.\" starting from a driver written by Dwayne Forsyth.
.\" Several other
.\" people have also contributed to the driver.
ленточные устройства SCSI без автоперемотки
.SH ЗАМЕЧАНИЯ
.IP 1. 4
При обмене данными между системами в них должен быть согласован физический
размер блока ленты. Параметры устройства после загрузки часто не являются
теми, которые использует большинство операционных систем, работающих с этими
устройствами. Большинство систем используют устройства в режиме с переменным
размером блока, если этот режим поддерживается устройством. Это применимо к
большинству современных  устройств, включая DAT, DLT и т.д. Возможно,
целесообразно использовать эти устройства в режиме с переменным размером
блока также и в Linux (т.е., используйте \fBMTSETBLK\fP или \fBMTSETDEFBLK\fP при
запуске системы для установки необходимого режима), по крайней мере при
обмене данными с другими системами. Недостатком этого является довольно
большой размер блока ленты, который нужно использовать для работы на
приемлемой скорости при передаче данных по шине SCSI.
.IP 2.
Многие программы (например, \fBtar\fP(1)) позволяют пользователю задать  размер
блока в командной строке. Заметим, что это помогает определить размер
физического блока на ленте, но только в режиме с переменным размером блока.
.IP 3.
Для использования ленточных устройств SCSI, базовый драйвер SCSI, драйвер
SCSI\-адаптера и драйвер ленты SCSI должны быть включены в ядро или
загружаться как модули. Если драйвер SCSI\-ленты отсутствует, то устройство
считается распознанным, но поддержка работы с лентой, описанная здесь, будет
недоступна.
.IP 4.
Драйвер записывает сообщения об ошибках в консоль/журнал. Коды SENSE,
содержащиеся в некоторых сообщениях, автоматически транслируются в текст,
если в ядре включён параметр подробного вывода сообщений SCSI.
.IP 5.
Использование внутреннего буфера драйвера позволяет достичь хорошей
пропускной способности в режиме с постоянным размером блока даже с маленьким
числом байт в \fBread\fP(2) и \fBwrite\fP(2). Прямой обмен для этого невозможен и
может привести к неожиданностям при переходе на ядро 2.6. В качестве решения
предлагается указать ПО использовать больший обмен передачи (часто, указав
использовать больший размер блоков). Если это невозможно, то прямой обмен
может быть выключен.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBmt\fP(1)
.PP
Файл \fIdrivers/scsi/README.st\fP или \fIDocumentation/scsi/st.txt\fP (ядро >=
2.6) из дерева исходного кода ядра Linux содержит самую последнюю информацию
о драйвере и его возможностях настройки
