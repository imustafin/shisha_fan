.\" -*- mode: troff; coding: UTF-8 -*-
'\" t
.\" Copyright (c) 1996 Andries Brouwer <aeb@cwi.nl>, Mon Oct 31 22:13:04 1996
.\"
.\" %%%LICENSE_START(GPLv2+_DOC_ONEPARA)
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\" %%%LICENSE_END
.\"
.\" This is combined from many sources.
.\" For Linux, the definitive source is of course console.c.
.\" About vt100-like escape sequences in general there are
.\" the ISO 6429 and ISO 2022 norms, the descriptions of
.\" an actual vt100, and the xterm docs (ctlseqs.ms).
.\" Substantial portions of this text are derived from a write-up
.\" by Eric S. Raymond <esr@thyrsus.com>.
.\"
.\" Tiny correction, aeb, 961107.
.\"
.\" 2006-05-27, Several corrections - Thomas E. Dickey
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH CONSOLE_CODES 4 2019\-03\-06 Linux "Руководство программиста Linux"
.SH ИМЯ
console_codes \- управляющие и экранирующие последовательности консоли Linux
.SH ОПИСАНИЕ
Консоль Linux имеет большой набор средств управления терминалами VT102 и
ECMA\-48/ISO 6429/ANSI X364, а также некоторым количеством индивидуальных
последовательностей для изменения цветовой палитры, перекодировки
символьного набора и т. д. В таблицах, приведенных ниже (во втором столбце),
указывается мнемонический код ECMA\-48 или DEC (если последнее приписано к
DEC) данной функции. Последовательности без мнемонического кода не
принадлежат ни к ECMA\-48, ни к VT102.
.PP
Первым процессом, который выполняется после работы обычного процесса по
выводу информации и отправки к драйверу потока символов консоли (для их
реального вывода), является перевод кодов, используемых при обычной работе,
в коды, применяемые для печати.
.PP
Если консоль работает в режиме UTF\-8, то входящие байты сначала организуются
в 16\-битовый Юникод. В ином случае каждый байт преобразуется согласно
текущей таблице перекодировки (которая переводит данные в Юникод). Смотри
раздел \fBНаборы символов\fP ниже).
.PP
Обычно значения Юникода преобразуются в индекс шрифта, который хранится в
видеопамяти таким образом, что соответствующий образ (обнаруженный в
видео\-ПЗУ) появляется на экране. Заметим, что работа с Юникодом (и текущими
аппаратными средствами компьютеров) позволяет одновременно использовать
только 512 различных образов.
.PP
Если текущим значением Юникода является управляющий символ или если в данный
момент обрабатывается экранирующая последовательность, значение будет
обрабатываться особым образом. Вместо того, чтобы значение было
преобразовало в шрифт и отобразилось как образ, оно приведёт к выполнению
определённого действия (например, перемещение курсора) или другой функции
управления. Смотрите ниже раздел \fBУправление консолью Linux\fP.
.PP
Некорректно явно указывать в программах аппаратные последовательности
управление терминалом. Linux поддерживает работу с базой возможностей
терминала \fBterminfo\fP(5). Вместо того, чтобы вводить управляющие
последовательности вручную, вы, наверняка, захотите использовать для этой
работы библиотеку, использующую terminfo, или другие утилиты, такие как
\fBncurses\fP(3), \fBtput\fP(1) или \fBreset\fP(1).
.SS "Управление консолью Linux"
Этот раздел описывает все управляющие символы и экранирущие
последовательности, которые выполняют специальные команды (т.е., всё, что
отличается от простого вывода символа в текущую позицию курсора) консоли
Linux.
.PP
\fBУправляющие символы\fP
.PP
Символ считается управляющим, если (до преобразования согласно таблице
перекодировки) он содержит один из 4 кодов: 00 (NUL), 07 (BEL), 08 (BS), 09
(HT), 0a (LF), 0b (VT), 0c (FF), 0d (CR), 0e (SO), 0f (SI), 18 (CAN), 1a
(SUB), 1b (ESC), 7f (DEL). Можно установить режим "показывать управляющие
символы" (см. ниже), при этом символы 07, 09, 0b, 18, 1a, 7f будут
выводиться на экран в виде образов. С другой стороны, в режиме UTF\-8 все
коды с 00 по 1f воспринимаются как управляющие символы, независимо от режима
«показа управляющих символов».
.PP
Если встречается управляющий символ, то он учитывается немедленно, и никак
не влияет в дальнейшем (даже если он стоял в середине  экранирующей
последовательности), и управляющая последовательность продолжается со
следующего символа. Однако, символ ESC, начинающий новую экранирующую
последовательность, возможно, отменит незаконченную предыдущую
последовательность, а символы CAN и SUB точно закончат любую экранирующую
последовательность. Распознаваемыми управляющими символами являются: BEL,
BS, HT, LF, VT, FF, CR, SO, SI, CAN, SUB, ESC, DEL, CSI. Они выполняют
стандартные для них действия:
.HP
BEL (0x07, \fB^G\fP) издает звуковой сигнал;
.HP
BS (0x08, \fB^H\fP) удаляет предыдущий символ (смещается влево на один столбец,
но не далее, чем за начало строки);
.HP
HT (0x09, \fB^I\fP) перемещается на следующую позицию табуляции или в конец
строки, если до этого не было установлено позиций табуляции;
.HP
LF (0x0A, \fB^J\fP), VT (0x0B, \fB^K\fP) и FF (0x0C, \fB^L\fP) задают перевод строки,
а LF/NL (в режиме новой строки) выполняет перевод каретки;
.HP
CR (0x0D, \fB^M\fP) задает перевод каретки;
.HP
SO (0x0E, \fB^N\fP) приводит в действие набор символов G1;
.HP
SI (0x0F, \fB^O\fP) приводит в действие набор символов G0;
.HP
CAN (0x18, \fB^X\fP) и SUB (0x1A, \fB^Z\fP) прерывают экранирующую
последовательность;
.HP
ESC (0x1B, \fB^[\fP) начинают экранирующую последовательность;
.HP
DEL (0x7F) игнорируется;
.HP
CSI (0x9B) эквивалентно ESC [.
.PP
\fBESC\- но не CSI\-последовательности\fP
.TS
l l l.
ESC c	RIS	Сброс
ESC D	IND	Перевод строки
ESC E	NEL	Новая строка
ESC H	HTS	Установить позицию табуляции в текущем столбце
ESC M	RI	Обратный перевод строки
ESC Z	DECID	T{
Есть только у DEC. Ядро
возвращает строку ESC [ ? 6 c,
утверждая что это VT102.
T}
ESC 7	DECSC	T{
Сохранить текущее состояние (координаты курсора,
атрибуты, наборы символов, указанные G0, G1).
T}
ESC 8	DECRC	Восстановить последнее сохранённое ESC 7 состояние
ESC [	CSI	Начало управляющей последовательности
ESC %		Начать последовательность с выбором набора символов
ESC % @		\0\0\0выбор по умолчанию (ISO 646/ISO 8859\-1)
ESC % G		\0\0\0выбор UTF\-8
ESC % 8		\0\0\0выбор UTF\-8 (устарело)
ESC # 8	DECALN	Экранный тест на выравнивание DEC: заполняет экран символами E
ESC (		Начать последовательность с выбором набора символов G0
ESC ( B		\0\0\0выбор по умолчанию (таблица перекодировки ISO 8859\-1)
ESC ( 0		\0\0\0выбор графической перекодировки VT100
ESC ( U		\0\0\0выбрать null\-перекодировку — сразу в символьную ROM
ESC ( K		\0\0\0пользовательская перекодировка — карта
		\0\0\0загружается утилитой \fBmapscrn\fP(8)
ESC )		Начать последовательность с выбором набора символов G1
		(следом идёт один из символов B, 0, U, K, как с G0)
ESC >	DECPNM	Установить режим ввода цифр для дополнительной клавиатуры
ESC =	DECPAM	Установить режим управления для дополнительной клавиатуры
ESC ]	OSC	T{
(Должно быть: команда операционной системы)
ESC  ] P \fInrrggbb\fP: задать палитру, в параметре
указывается 7 шестнадцатеричных цифр после
последнего P :\-(. Здесь \fIn\fP определяет цвет (0\(en15),
а в \fIrrggbb\fP указываются значения
красного/зелёного/синего (0\(en255)
ESC ] R: сбросить палитру
T}
.TE
.PP
\fBCSI\-последовательности ECMA\-48\fP
.PP
CSI (или ESC [) сопровождаются последовательностью параметров, являющихся
десятичными номерами, разделёнными точкой с запятой (самый больший из них
\(em NPAR (16)). Пустой или отсутствующий параметр приравнивается
нулю. Последовательность параметров может начинаться одним знаком вопроса.
.PP
Тем не менее, после CSI [ (или ESC [ [) считывается единственный символ и
оставшаяся часть последовательности игнорируется. (Смысл этого в том, чтобы
не отображать функциональную клавишу).
.PP
Результат работы CSI\-последовательности определяется её конечным символом.
.TS
l l l.
@	ICH	Вставить N пустых символов
A	CUU	Переместить курсор вверх на N строк
B	CUD	Переместить курсор вниз на N строк
C	CUF	Переместить курсор вправо на N столбцов
D	CUB	Переместить курсор влево на N столбцов
E	CNL	Переместить курсор вниз на N строк в столбец 1
F	CPL	Переместить курсор вверх на N строк в столбец 1
G	CHA	Переместить курсор в указанный столбец текущей строки
H	CUP	Переместить курсор в указанную строку и столбец (начало в 1,1)
J	ED	Очистить экран (по умолчанию от курсора до конца экрана)
		ESC [ 1 J: очистить от начала до курсора
		ESC [ 2 J: очистить весь экран
		ESC [ 3 J: очистить весь экран, включая буфер
		           обратной прокрутки (начиная с Linux 3.0)
.\" ESC [ 3 J: commit f8df13e0a901fe55631fed66562369b4dba40f8b
K	EL	Очистить строку (по умолчанию от курсора до конца строки)
		ESC [ 1 K: очистить от начала строки до курсора
		ESC [ 2 K: очистить всю строку
L	IL	Вставить N пустых строк
M	DL	Удалить N строк
P	DCH	Удалить N символов в текущей строке
X	ECH	Очистить N символов в текущей строке
a	HPR	Переместить курсор вправо на N столбцов
c	DA	Ответ по ESC [ ? 6 c: «Я терминал VT102»
d	VPA	Переместить курсор в указанную строку текущего столбца
e	VPR	Переместить курсор вниз на N строк
f	HVP	Переместить курсор в указанную строку и столбец
g	TBC	Без параметра: очистить текущую позицию табуляции
		ESC [ 3 g: удалить все позиции табуляции
h	SM	Режим установки (смотрите ниже)
l	RM	Режим сброса (смотрите ниже)
m	SGR	Установка атрибутов (смотрите ниже)
n	DSR	Отчёт о состоянии (смотрите ниже)
q	DECLL	Управление индикаторами на клавиатуре
		ESC [ 0 q: выключить все индикаторы
		ESC [ 1 q: включить Scroll Lock
		ESC [ 2 q: включить Num Lock
		ESC [ 3 q: включить Caps Lock
r	DECSTBM	Установить область прокрутки; параметрами будут верхняя и нижняя строки
s	?	Сохранить местоположение курсора
u	?	Восстановить местоположение курсора
\`	HPA	Переместить курсор в указанный столбец текущей строки
.TE
.PP
\fBУстановка параметров графики ECMA\-48\fP
.PP
Последовательность ECMA\-48 SGR управляющих символов ESC [ \fIparameters\fP m
устанавливает атрибуты экрана. В одной последовательности может быть задано
несколько атрибутов. Пустой параметр (между точкой с запятой или начальной
строкой или символом завершения) считается нулём.
.TS
l l.
параметр	результат
0	сбросить все атрибуты в их значения по умолчанию
1	установить жирный
2	установить более яркий (имитируется цветом на цветном дисплее)
4	T{
установить подчеркивание (имитируется цветом на цветном дисплее)
(цвета, используемые для имитации затемнения или подчеркивания,
устанавливаются при помощи ESC ] …)
T}
5	включить мерцание
7	включить инвертирование видео
10	T{
сбросить выбранную перекодировку, флаг управления экраном
и переключить метафлаг (в ECMA\-48 указан как «первичный шрифт»).
T}
11	T{
выбрать null\-перекодировку, установить флаг управления экраном, сбросить
переключатель метафлага (в ECMA\-48 указан как «первый альтернативный шрифт»).
T}
12	T{
выбрать null\-перекодировку, установить флаг управления экраном, установить
переключатель метафлага (в ECMA\-48 указан как «второй альтернативный шрифт»).
Переключение метафлага вызывает переключение старшего бита в байте до его
перекодировки согласно таблице трансляции.
T}
21	включить нормальную интенсивность (в ECMA\-48 указан как «двойное подчёркивание»)
22	включить нормальную интенсивность
24	выключить подчеркивание
25	выключить мерцание
27	выключить инвертированное видео
30	установить чёрный цвет символов
31	установить красный цвет символов
32	установить зелёный цвет символов
33	установить коричневый цвет символов
34	установить синий цвет символов
35	установить сиреневый цвет символов
36	установить голубой цвет символов
37	установить белый цвет символов
38	включить подчеркивание, установить цвет символов по умолчанию
39	выключить подчеркивание, установить цвет символов по умолчанию
40	установить чёрный цвет фона
41	установить красный цвет фона
42	установить зелёный цвет фона
43	установить коричневый цвет фона
44	установить синий цвет фона
45	установить сиреневый цвет фона
46	установить голубой цвет фона
47	установить белый цвет фона
49	установить цвет фона по умолчанию
.TE
.PP
\fBПереключатели режимов ECMA\-48\fP
.TP 
ESC [ 3 h
DECCRM (по умолчанию выключен): Показывать управляющие символы.
.TP 
ESC [ 4 h
DECIM (по умолчанию выключен): Включить режим вставки.
.TP 
ESC [ 20 h
.\"
LF/NL (по умолчанию выключен): Автоматически выводить код CR после LF, VT
или FF.
.PP
.\"
\fBКоманды вывода состояния ECMA\-48\fP
.TP 
ESC [ 5 n
Сообщение о состоянии устройства (DSR): Ответом является ESC [ 0 n (терминал
в порядке).
.TP 
ESC [ 6 n
.\"
Сообщение о позиции курсора (CPR): Ответом является ESC [ \fIy\fP ; \fIx\fP R, где
\fIx,y\fP являются координатами курсора.
.PP
\fBПоследовательности спец\-режима DEC (DECSET/DECRST)\fP
.PP
.\"
Не описаны в ECMA\-48. Далее будут перечислены последовательности установки
режима; в последовательности для сброса режима последний знак  \(aqh\(aq
заменяется на \(aql\(aq.
.TP 
ESC [ ? 1 h
DECCKM (по умолчанию выключено): Если включено, то клавиши курсора посылают
префикс ESC O, а не с ESC [.
.TP 
ESC [ ? 3 h
DECCOLM (по умолчанию = 80 столбцов): режим переключения количества столбцов
80/132. В исходном коде драйвера указано, что одной этой команды
недостаточно; некоторые пользовательские утилиты, использующие нестандартные
режимы, такие как \fBresizecons\fP(8), должны менять регистры настройки
видеокарты консоли.
.TP 
ESC [ ? 5 h
DECSCNM (по умолчанию выключено): Включить инвертированный видеорежим.
.TP 
ESC [ ? 6 h
DECOM (по умолчанию выключено): Если включено, то координаты курсора
рассматриваются относительно верхнего левого угла области прокрутки.
.TP 
ESC [ ? 7 h
DECAWM (по умолчанию включено): Включить режим автопереноса. В этом режиме
графический символ, вводящийся после 80\-го столбца (или 132\-го, если DECCOLM
включён), переносится в начало следующей строки.
.TP 
ESC [ ? 8 h
DECARM (по умолчанию включено): Включить режим автоповтора символов при
вводе с клавиатуры.
.TP 
ESC [ ? 9 h
Отчёт X10 о состоянии мыши (по умолчанию выключено): Установить режим отчёта
о состоянии мыши, равным 1 (или сбросить в 0), см. ниже.
.TP 
ESC [ ? 25 h
DECTECM (по умолчанию включено): Сделать курсор видимым.
.TP 
ESC [ ? 1000 h
.\"
Отчёт X11 о состоянии мыши (по умолчанию выключено): Установить режим отчёта
о состоянии мыши, равным 2 (или сбросить в 0), см. ниже.
.PP
\fBСпецифические CSI\-последовательности консоли Linux\fP
.PP
.\"
Следующие последовательности не являются ни ECMA\-48, ни VT102. Они есть
только в драйвере консоли Linux. Цвета в параметрах SGR: 0 = чёрный, 1 =
красный, 2 = зелёный, 3 = коричневый, 4 = синий, 5 = сиреневый, 6 = голубой,
7 = белый, 8\(en15 = яркие версии 0\(en7.
.TS
l l.
ESC [ 1 ; \fIn\fP ]	Назначить цвет \fIn\fP цветом подчеркивания.
ESC [ 2 ; \fIn\fP ]	Назначить цвет \fIn\fP цветом затемнения.
ESC [ 8 ]       	Сделать текущую пару цветов атрибутами по умолчанию
ESC [ 9 ; \fIn\fP ]	Показывать заставку через \fIn\fP минут
ESC [ 10 ; \fIn\fP ]	Задать частоту звукового сигнала (в герцах)
ESC [ 11 ; \fIn\fP ]	Задать длительность звукового сигнала (в миллисекундах)
ESC [ 12 ; \fIn\fP ]	Переместить указанную консоль перед остальными
ESC [ 13 ]      	Убрать заставку (blank screen)
ESC [ 14 ; \fIn\fP ]   	Задать интервал отключения питания VESA (в минутах)
ESC [ 15 ]      	T{
Переместить предыдущую консоль перед остальными
(начиная с Linux 2.6.0)
T}
ESC [ 16 ; \fIn\fP ]   	T{
Задать интервал мигания курсора (в миллисекундах)
(начиная с Linux 4.2).
T}
.\" commit bd63364caa8df38bad2b25b11b2a1b849475cce5
.TE
.SS "Наборы символов"
Ядро располагает информацией о 4\-х типах трансляции байтов в символы консоли
экрана. Эти четыре таблицы: a) Latin1 \-> PC, b) графика VT100 \-> PC,
c) PC \-> PC, d) определяется пользователем.
.PP
В системе существует два набора символов, называемых G0 и G1, и один из них
является текущим набором символов системы (изначально это G0). Ввод \fB^N\fP
заставляет набор G1 стать текущим, \fB^O\fP делает текущим набор G0.
.PP
Данные переменные G0 и G1 указывают на таблицу трансляции и  могут меняться
пользователем. Изначально они указывают на таблицы a) и b)
соответственно. Последовательности ESC ( B, ESC ( 0, ESC ( U и ESC ( K
заставляют G0 ссылаться на таблиц трансляции a), b), c) и d),
соответственно. Последовательности ESC ) B, ESC ) 0, ESC ) U, и ESC ) K
заставляют G1 ссылаться на таблицу трансляции a), b), c) и d),
соответственно.
.PP
Последовательность ESC c приводит к сбросу терминала, то есть то, что вы
хотели бы сделать при наличии «мусора» на экране. Рекомендация, указанная
после «echo ^V^O», только сделает G0 текущим набором, но нет никакой
гарантии, что G0 указывает на таблицу a). В некоторых дистрибутивах есть
программа \fBreset\fP(1), которая всего лишь выполняет команду «echo ^[c». Если
элемент terminfo является правильным для консоли (и содержит элемент
rs1=\eEc), то «tput reset» также сработает.
.PP
Определенная пользователем таблица перекодировки может быть установлена с
помощью \fBmapscrn\fP(8). Результатом перекодировки будет то, что при указании
символа c в видеопамять будет отправлен символ s = перекодировка[c]
\&. Побитовое изображение, соответствующее s, ищется в ПЗУ символов и может
меняться при помощи \fBsetfont\fP(8).
.SS "Отслеживание мыши"
Для отслеживания работы мыши в системе предполагается выдача
\fBxterm\fP(1)\-совместимых сигналов о состоянии мыши. Так как драйвер консоли
не распознает такого устройства, как мышь (или похожего типа), то эти
сигналы отправляются во входной поток консоли, только когда драйвер
виртуального терминала получает сигнал ioctl об обновлении состояния
мыши. Эти сигналы ioctl должны генерироваться пользовательскими
приложениями, поддерживающими работу с мышью такими, как служба \fBgpm\fP(8).
.PP
Параметром для всех созданных \fBxterm\fP(1) экранирующих последовательностей
(сигналов от мыши) будет один символ, код которого равен
\fIзначение\fP+040. Например, \(aq!\(aq  соответствует единице. Отчёт системы
координат экрана начинается с 1.
.PP
В режиме совместимости с X10 при нажатии на кнопки посылаются экранирующие
последовательности, в которых кодируется и расположение мыши, и информация о
нажатой кнопке. Режим включается при выдаче ESC [ ? 9 h и выключается при
выдаче ESC [ ? 9 l. При нажатии на кнопку \fBxterm\fP(1) посылает ESC [ M
\fIbxy\fP (6 символов), где b \(em это кнопка 1, а x и y равны координатам x и
y при нажатии на кнопку. Это такие же коды, какие генерирует и выдаёт ядро.
.PP
В обычном режиме отслеживания мыши (который не был реализован в Linux
2.0.24) экранирующие последовательности посылаются и при нажатии и при
отпускании кнопки мыши. Также посылается информация о модификаторе. Режим
включается при выдаче ESC [ ? 1000 h и выключается при выдаче ESC [ 1000
l. При нажатии или отпускании кнопки \fBxterm\fP(1) выдает ESC [ M \fIbxy\fP. Два
младших бита \fIb\fP содержат информацию о кнопках: 0=MB1 нажата, 1=MB2 нажата,
2=MB3 нажата, 3=отпущена. Старшие биты содержат информацию о том, какие
модификаторы были нажаты, когда была нажата кнопка. Эта информация
складывается при нажатии: 4=Shift, 8=Meta, 16=Control. Ещё раз: \fIx\fP и \fIy\fP
являются координатами x и y мыши при обработке события. Координаты верхнего
левого угла рассматриваются как (1,1).
.SS "Сравнение с другими терминалами"
.\"
Множество других типов терминалов описаны, подобно консоли Linux, как
VT100\-совместимые. Далее мы обсудим различия между консолью Linux и двумя
другими важнейшими типами \(em DEC VT102 и \fBxterm\fP(1).
.PP
\fBОбработка управляющих символов\fP
.PP
Тип VT102 также распознает следующие управляющие символы:
.HP
NUL (0x00) игнорируется;
.HP
ENQ (0x05) запускает обратное ответное сообщение;
.HP
DC1 (0x11, \fB^Q\fP, XON) возобновляет передачу;
.HP
DC3 (0x13, \fB^S\fP, XOFF) заставляет VT100 игнорировать (и останавливать
передачу) всех кодов за исключением XOFF и XON.
.PP
VT100\-подобную обработку DC1/DC3 можно включить в драйвере терминала.
.PP
.\"
Программа \fBxterm\fP(1) (в режиме VT100) распознает управляющие символы BEL,
BS, HT, LF, VT, FF, CR, SO, SI, ESC.
.PP
\fBЭкранирующие последовательности\fP
.PP
Последовательности консоли VT100, не реализованные в консоли Linux:
.TS
l l l.
ESC N	SS2	Сдвиг на 2 (выбрать набор символов G2 только для следующего
		символа)
ESC O	SS3	Сдвиг на 3 (выбрать набор символов G3 только для следующего
		символа)
ESC P	DCS	Строка управления устройством (заканчивается ESC \e)
ESC X	SOS	Начало строки
ESC ^	PM	Частное сообщение (заканчивается ESC \e)
ESC \e	ST	Символ завершения строки
ESC * ...		Определить набор символов G2
ESC + ...		Определить набор символов G3
.TE
.PP
Программа \fBxterm\fP(1) (в режиме VT100) распознает ESC c, ESC # 8, ESC >,
ESC =, ESC D, ESC E, ESC H, ESC M, ESC N, ESC O, ESC P ... ESC \e, ESC Z
(отвечает ESC [ ? 1 ; 2 c, "Я VT100 с улучшенными видеопараметрами") и ESC ^
\&... ESC \e с теми же значениями, какие указаны выше. Принимаются ESC (, ESC
), ESC *, ESC + за которыми 0, A, B для специального символа DEC и режима
рисования линий, UK и US\-ASCII, соответственно.
.PP
Пользователь может настроить \fBxterm\fP(1) так, чтобы он  отвечал на
специальные управляющие последовательности VT220, и в этом случае он будет
идентифицировать себя как VT52, VT100 и далее, в зависимости от способа
настройки и инициализации.
.PP
Для настройки определённых ресурсов он принимает ESC ] (OSC). Помимо символа
завершения строки (ST) из ECMA\-48, \fBxterm\fP(1) для завершения OSC\-строки
также принимает BEL. Есть несколько управляющих последовательностей OSC,
распознаваемых \fBxterm\fP(1):
.TS
l l.
ESC ] 0 ; \fItxt\fP ST	Установить имя значка и заголовок окна равным \fItxt\fP
ESC ] 1 ; \fItxt\fP ST	Установить имя значка равным \fItxt\fP
ESC ] 2 ; \fItxt\fP ST	Установить заголовок окна равным \fItxt\fP
ESC ] 4 ; \fInum\fP; \fItxt\fP ST	Установить цвет ANSI \fInum\fP равным \fItxt\fP
ESC ] 10 ; \fItxt\fP ST	Установить цвет динамического текста равным \fItxt\fP
ESC ] 4 6 ; \fIname\fP ST	Изменить файл журнала на \fIname\fP (обычно отключено
	в параметрах компиляции)
ESC ] 5 0 ; \fIfn\fP ST	Установить шрифт равным \fIfn\fP.
.TE
.PP
Распознаются следующие параметры с несколько измененным значением (больше
сохраняется состояние, поведение ближе к VT100/VT220):
.TS
l l l.
ESC 7  DECSC	Сохранить курсор
ESC 8  DECRC	Восстановить курсор
.TE
.PP
Также распознаются
.TS
l l l.
ESC F		Курсор в нижний левый угол экрана (если разрешено
		ресурсом \fBhpLowerleftBugCompat\fP в \fBxterm\fP(1))
ESC l		Блокировать память (терминалы HP)
		Блокировать память выше курсора
ESC m		Разблокировать память (терминалы HP)
ESC n	LS2	Вызов набора символов G2
ESC o	LS3	Вызов набора символов G3
ESC |	LS3R	Вызов набора символов G3 в качестве GR
ESC }	LS2R	Вызов набора символов G2 в качестве GR
ESC ~	LS1R	Вызов набора символов G1 в качестве GR
.TE
.PP
.\"
Также распознается ESC % и предоставляется более полная реализация UTF\-8 чем
в консоли Linux.
.PP
\fBПоследовательности CSI\fP
.PP
Старые версии \fBxterm\fP(1), например из X11R5, воспринимают мерцание SGR как
жирность SGR. В более новых версиях, в которых реализованы цвета ANSI,
например в XFree86 3.1.2A 1995 года, атрибут мерцания отображается цветом. В
современных версиях xterm мерцание SGR реализовано в виде мерцающего текста,
который можно также сделать цветным в качестве альтернативы отображения
SGR. Исходные версии X11R6 не распознают настройки цвета SGR вплоть до
версии X11R6.8, в которую был включён XFree86 xterm.  Все последовательности
CSI ECMA\-48 CSI, понимаемые Linux, также понимает \fIxterm\fP, однако в
\fBxterm\fP(1) реализовано несколько управляющих последовательностей ECMA\-48 и
DEC, которые не понимаются Linux.
.PP
Программа \fBxterm\fP(1) распознаёт все последовательности спец\-режимов DEC,
описанных выше, но ни одной последовательности спец\-режимов Linux. О
собственных спец\-режимах \fBxterm\fP(1) можно прочитать в документе
\fIУправляющие последовательности Xterm\fP, написанном Edward Moy, Stephen
Gildea и Thomas E.\& Dickey и доступном в дистрибутиве X. Этот документ хотя
и сокращённый, но всё равно намного больше данной справочной
страницы. Хронологический обзор в
.PP
.RS
.UR http://invisible\-island.net\:/xterm\:/xterm.log.html
.UE
.RE
.PP
описывает изменения в xterm.
.PP
Программа \fIvttest\fP
.PP
.RS
.UR http://invisible\-island.net\:/vttest/
.UE
.RE
.PP
демонстрирует многие из этих управляющих последовательностей. В исходном
дистрибутиве \fBxterm\fP(1) также содержатся примеры сценариев, которые учат
работать с другими свойствами.
.SH ЗАМЕЧАНИЯ
Последовательность ESC 8 (DECRC) не может восстановить набор символов,
изменённый с помощью ESC %.
.SH ДЕФЕКТЫ
В версии 2.0.23 набор CSI является неправильным и недейственным, NUL не
игнорируется внутри экранирующих последовательностей.
.PP
Некоторые старые версии ядер (после 2.0) анализируют 8\-битные управляющие
последовательности. В них ("управляющие коды C1") используются коды от 128
до 159 для замены ESC [, ESC ] и подобных начальных двухбайтовых управляющих
последовательностей. Они частично существуют в современных ядрах (или не
распознаются или не работают из\-за поддержки UTF\-8), и реализованы не
полностью, и должны расцениваться как ненадежные.
.PP
Последовательности "спец\-режима" Linux не учитывают правила ECMA\-48 для
управляющих последовательностей спец\-режима. В частности, они заканчиваются
] и не используют стандартный символ завершения. Последовательность OSC
(установить палитру) \(em большая проблема, так как \fBxterm\fP(1)
рассматривает её как управляющую последовательность, которой требуется
окончание строки (ST). В отличие от последовательностей \fBsetterm\fP(1),
которые будут проигнорированы (так как они не являются правильными
управляющими последовательностями), последовательность палитры приведёт к
подвисанию \fBxterm\fP(1) (хотя нажав клавишу return это исправится). Чтобы
приспособить приложения, в которых жёстко заданы управляющие
последовательности Linux, установите ресурс \fBxterm\fP(1) \fBbrokenLinuxOSC\fP
равным true.
.PP
В старой версии данного документа предполагалось, что Linux распознаёт
управляющую последовательность ECMA\-48 для невидимости текста. Она
игнорируется.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBioctl_console\fP(2), \fBcharsets\fP(7)
