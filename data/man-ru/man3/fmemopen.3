.\" -*- mode: troff; coding: UTF-8 -*-
.\" Copyright 2005, 2012, 2016 Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" %%%LICENSE_START(GPL_NOVERSION_ONELINE)
.\" Distributed under the GPL.
.\" %%%LICENSE_END
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH FMEMOPEN 3 2019\-03\-06 GNU "Руководство программиста Linux"
.SH ИМЯ
fmemopen \- открывает память как поток
.SH ОБЗОР
.nf
\fB#include <stdio.h>\fP
.PP
\fBFILE *fmemopen(void *\fP\fIbuf\fP\fB, size_t \fP\fIsize\fP\fB, const char *\fP\fImode\fP\fB);\fP
.fi
.PP
.in -4n
Требования макроса тестирования свойств для glibc
(см. \fBfeature_test_macros\fP(7)):
.in
.PP
\fBfmemopen\fP():
.PD 0
.ad l
.RS 4
.TP  4
Начиная с glibc 2.10:
_POSIX_C_SOURCE\ >=\ 200809L
.TP 
До glibc 2.10:
_GNU_SOURCE
.RE
.ad
.PD
.SH ОПИСАНИЕ
Функция \fBfmemopen\fP() открывает поток, тип доступа указывается в
\fImode\fP. Поток позволяет выполнять операции ввода\-вывода со строкой или
буфером памяти, указанным в \fIbuf\fP.
.PP
В аргументе \fImode\fP задаётся семантика ввода\-вывода потока и может
указываться одно из следующих значений:
.TP  8
\fIr\fP
Поток открывается для чтения.
.TP 
\fIw\fP
Поток открывается для записи.
.TP 
\fIa\fP
Добавление; поток открывается для записи, начальное положение в буфере
указывает на первый байт null.
.TP 
\fIr+\fP
Поток открывается для чтения и записи.
.TP 
\fIw+\fP
Поток открывается для чтения и записи. Содержимое буфера обрезается (то
есть, в первый байт буфера помещается \(aq\e0\(aq).
.TP 
\fIa+\fP
Добавление; поток открывается для чтения и записи, начальное положение в
буфере указывает на первый байт null.
.PP
Для потока поддерживается понятие текущего положения — место, откуда будет
выполнена следующая операция ввода\-вывода. Текущее положение неявно
обновляется операциями ввода\-вывода. Оно может быть изменено явным образом с
помощью \fBfseek\fP(3) и получено с помощью \fBftell\fP(3). Во всех режимах кроме
добавления, начальное положение указывает на начало буфера. В режиме
добавления, если в буфере нет байта null, то начальное положение равно
\fIsize+1\fP.
.PP
Если значение \fIbuf\fP равно NULL, то \fBfmemopen\fP() выделяет буфер длиной
\fIsize\fP байт. Это полезно для приложений, которым нужно записать данные во
временный буфер и прочитать из него. Начальное положение указывает на начало
буфера. Буфер автоматически освобождается при закрытии потока. Заметим, что
вызывающий никогда не получит указатель на временный буфер, выделенный этим
вызовом (но смотрите \fBopen_memstream\fP(3)).
.PP
Если \fIbuf\fP не равно NULL, то значение должно указывать на  буфер длиной не
менее \fIlen\fP байт, выделенный вызывающим.
.PP
Когда поток, открытый на запись, сбрасывается (flushed) (\fBfflush\fP(3)) или
закрывается (\fBfclose\fP(3)), то в конец буфера записывается байт null, если
есть место. Вызывающий должен быть уверен, что в буфере есть место для
дополнительного байта (и в \fIsize\fP учитывается этот байт), чтобы это
произошло.
.PP
В потоке, открытом на чтение, при обнаружении байтов null («\e0») в буфере
операции чтения не возвращают конец файла. Чтение из буфера будет возвращать
конец файла, только когда текущее положение в буфере достигнет \fIsize\fP байт
от начала буфера.
.PP
Операции записи выполняются, или по текущему положению (для всех режимов,
кроме добавления), или по текущему размеру потока (в режимах добавления).
.PP
Попытка записать более \fIsize\fP байт в буфер приводит к ошибке. По умолчанию,
такие ошибки будут видимы (по отсутствию данных) только в момент сброса
буфера \fIstdio\fP. Следующий вызов отключает буферизацию, что может быть
полезно для обнаружения ошибок в момент операции вывода:
.PP
    setbuf(stream, NULL);
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
При успешном выполнении \fBfmemopen\fP() возвращается указатель \fIFILE\fP. В
противном случае возвращается NULL и \fIerrno\fP присваивается код ошибки.
.SH ВЕРСИИ
Функция \fBfmemopen\fP() была доступна уже в glibc 1.0.x.
.SH АТРИБУТЫ
Описание терминов данного раздела смотрите в \fBattributes\fP(7).
.TS
allbox;
lb lb lb
l l l.
Интерфейс	Атрибут	Значение
T{
\fBfmemopen\fP(),
T}	Безвредность в нитях	MT\-Safe
.TE
.sp 1
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
POSIX.1\-2008. Эта функция не определена в POSIX.1\-2001 и широко не
распространена среди других систем.
.PP
.\" http://austingroupbugs.net/view.php?id=396
В POSIX.1\-2008 указано, что символ «b» в \fImode\fP должен
игнорироваться. Однако в Technical Corrigendum 1 изменили стандарт, позволив
реализации решать что делать; это позволяет glibc учитывать «b».
.SH ЗАМЕЧАНИЯ
У файлового потока, возвращаемого этой  функцией, отсутствует файловый
дескриптор (т. е., если файловый поток передать в \fBfileno\fP(3), то
произойдёт ошибка).
.PP
.\"
Начиная с версии 2.22 двоичный режим (смотрите ниже) был удалён, было
исправлено много дефектов в реализации \fBfmemopen\fP() и для этого интерфейса
был создан новый символ с версией.
.SS "Двоичный режим"
В версиях с 2.9 по 2.21  реализация \fBfmemopen\fP() в glibc поддерживает
«двоичный» режим, включаемый в \fImode\fP указанием вторым символа \(aqb\(aq. В
этом режиме при записи не выполняется неявное добавление конечного байта
null и \fBfseek\fP(3)  \fBSEEK_END\fP считается относительно конца буфера (т. е.,
значения, указанного в аргументе \fIsize\fP), а не длины текущей строки.
.PP
.\" http://sourceware.org/bugzilla/show_bug.cgi?id=12836
Дефект программного интерфейса перешёл и в реализацию двоичного режима: для
задания двоичного режима \(aqb\(aq должен указываться \fIвторым\fP символом в
\fImode\fP. То есть, например, «wb+» сработает, а «w+b» — нет. Это не совпадает
с трактовкой \fImode\fP в \fBfopen\fP(3).
.PP
Двоичный режим удалён в glibc 2.22; указание \(aqb\(aq в \fImode\fP
игнорируется.
.SH ДЕФЕКТЫ
.\" http://sourceware.org/bugzilla/show_bug.cgi?id=11216
В glibc до версии 2.22, если \fIsize\fP равно нулю, то \fBfmemopen\fP()
завершается с ошибкой \fBEINVAL\fP. Было бы логичней, если бы в этом случае
успешно создавался поток, который затем бы возвращал конец файла при первой
попытке его чтения; начиная с версии 2.22 реализация glibc поступает именно
так.
.PP
.\" http://sourceware.org/bugzilla/show_bug.cgi?id=13152
В glibc до версии 2.22 указание в \fBfmemopen\fP() режима добавления («a» или
«a+») устанавливает начальное положение в буфере на первый байт null, но
(если положение сбрасывается в расположение, отличное от конца потока) не
заставляет последующие операции записи выполнять добавление в конец
потока. Этот дефект исправлен в glibc 2.22.
.PP
.\" http://sourceware.org/bugzilla/show_bug.cgi?id=13151
В glibc до версии 2.22, если в аргументе \fImode\fP в \fBfmemopen\fP() включено
добавление («a» или «a+») и аргумент \fIsize\fP не учитывает байт null в
\fIbuf\fP, то согласно POSIX.1\-2008 начальное положение буфера должно указывать
на следующий байт за концом буфера. Однако, в этом случае glibc
\fBfmemopen\fP() присваивает положению буфера значение \-1. Этот дефект
исправлен в glibc 2.22.
.PP
.\" https://sourceware.org/bugzilla/show_bug.cgi?id=14292
В glibc до версии 2.22 при вызове \fBfseek\fP(3) со значением \fIwhence\fP, равным
\fBSEEK_END\fP, и для потока, созданного \fBfmemopen\fP(), значение \fIoffset\fP
\fIвычитается\fP из положения конца потока, а не добавляется. Этот дефект
исправлен в glibc 2.22.
.PP
.\" http://sourceware.org/bugzilla/show_bug.cgi?id=6544
При дополнении \fBfmemopen\fP() в glibc 2.9 «двоичным» режимом было потихоньку
изменено ABI: раньше \fBfmemopen\fP() игнорировала «b» в \fImode\fP.
.SH ПРИМЕР
Программа, показанная ниже, использует \fBfmemopen\fP() для открытия входного
буфера и \fBopen_memstream\fP(3) для открытия выходного буфера с динамически
изменяющимся размером. Программа сканирует входную строку (первый аргумент
командной строки программы), читая целые числа, и записывает квадраты этих
чисел в выходной буфер. Пример результата работы программы:
.PP
.in +4n
.EX
$\fB ./a.out \(aq1 23 43\(aq\fP
размер=11; ptr=1 529 1849
.EE
.in
.SS "Исходный код программы"
\&
.EX
#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#define handle_error(msg) \e
    do { perror(msg); exit(EXIT_FAILURE); } while (0)

int
main(int argc, char *argv[])
{
    FILE *out, *in;
    int v, s;
    size_t size;
    char *ptr;

    if (argc != 2) {
        fprintf(stderr, "Использование: %s \(aq<num>...\(aq\en", argv[0]);
        exit(EXIT_FAILURE);
    }

    in = fmemopen(argv[1], strlen(argv[1]), "r");
    if (in == NULL)
        handle_error("fmemopen");

    out = open_memstream(&ptr, &size);
    if (out == NULL)
        handle_error("open_memstream");

    for (;;) {
        s = fscanf(in, "%d", &v);
        if (s <= 0)
            break;

        s = fprintf(out, "%d ", v * v);
        if (s == \-1)
            handle_error("fprintf");
    }

    fclose(in);
    fclose(out);

    printf("размер=%zu; ptr=%s\en", size, ptr);

    free(ptr);
    exit(EXIT_SUCCESS);
}
.EE
.SH "СМОТРИТЕ ТАКЖЕ"
\fBfopen\fP(3), \fBfopencookie\fP(3), \fBopen_memstream\fP(3)
