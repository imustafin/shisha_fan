.\" -*- mode: troff; coding: UTF-8 -*-
.\" Copyright (c) 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" %%%LICENSE_START(BSD_3_CLAUSE_UCB)
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\" %%%LICENSE_END
.\"
.\"	@(#)queue.3	8.2 (Berkeley) 1/24/94
.\" $FreeBSD$
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.Dd 7 февраля 2015 г.
.Dt QUEUE 3
.Os
.Sh ИМЯ
.\" .Nm SLIST_FOREACH_FROM ,
.\" .Nm SLIST_FOREACH_SAFE ,
.\" .Nm SLIST_FOREACH_FROM_SAFE ,
.\" .Nm SLIST_REMOVE_AFTER ,
.\" .Nm SLIST_SWAP ,
.\" .Nm STAILQ_FOREACH_FROM ,
.\" .Nm STAILQ_FOREACH_SAFE ,
.\" .Nm STAILQ_FOREACH_FROM_SAFE ,
.\" .Nm STAILQ_LAST ,
.\" .Nm STAILQ_REMOVE_AFTER ,
.\" .Nm STAILQ_SWAP ,
.\" .Nm LIST_FOREACH_FROM ,
.\" .Nm LIST_FOREACH_SAFE ,
.\" .Nm LIST_FOREACH_FROM_SAFE ,
.\" .Nm LIST_PREV ,
.\" .Nm LIST_SWAP ,
.\" .Nm TAILQ_FOREACH_FROM ,
.\" .Nm TAILQ_FOREACH_SAFE ,
.\" .Nm TAILQ_FOREACH_FROM_SAFE ,
.\" .Nm TAILQ_FOREACH_REVERSE_FROM ,
.\" .Nm TAILQ_FOREACH_REVERSE_SAFE ,
.\" .Nm TAILQ_FOREACH_REVERSE_FROM_SAFE ,
.Nm SLIST_EMPTY ,
.Nm SLIST_ENTRY ,
.Nm SLIST_FIRST ,
.Nm SLIST_FOREACH ,
.Nm SLIST_HEAD ,
.Nm SLIST_HEAD_INITIALIZER ,
.Nm SLIST_INIT ,
.Nm SLIST_INSERT_AFTER ,
.Nm SLIST_INSERT_HEAD ,
.Nm SLIST_NEXT ,
.Nm SLIST_REMOVE_HEAD ,
.Nm SLIST_REMOVE ,
.Nm STAILQ_CONCAT ,
.Nm STAILQ_EMPTY ,
.Nm STAILQ_ENTRY ,
.Nm STAILQ_FIRST ,
.Nm STAILQ_FOREACH ,
.Nm STAILQ_HEAD ,
.Nm STAILQ_HEAD_INITIALIZER ,
.Nm STAILQ_INIT ,
.Nm STAILQ_INSERT_AFTER ,
.Nm STAILQ_INSERT_HEAD ,
.Nm STAILQ_INSERT_TAIL ,
.Nm STAILQ_NEXT ,
.Nm STAILQ_REMOVE_HEAD ,
.Nm STAILQ_REMOVE ,
.Nm LIST_EMPTY ,
.Nm LIST_ENTRY ,
.Nm LIST_FIRST ,
.Nm LIST_FOREACH ,
.Nm LIST_HEAD ,
.Nm LIST_HEAD_INITIALIZER ,
.Nm LIST_INIT ,
.Nm LIST_INSERT_AFTER ,
.Nm LIST_INSERT_BEFORE ,
.Nm LIST_INSERT_HEAD ,
.Nm LIST_NEXT ,
.Nm LIST_REMOVE ,
.Nm TAILQ_CONCAT ,
.Nm TAILQ_EMPTY ,
.Nm TAILQ_ENTRY ,
.Nm TAILQ_FIRST ,
.Nm TAILQ_FOREACH ,
.Nm TAILQ_FOREACH_REVERSE ,
.Nm TAILQ_HEAD ,
.Nm TAILQ_HEAD_INITIALIZER ,
.Nm TAILQ_INIT ,
.Nm TAILQ_INSERT_AFTER ,
.Nm TAILQ_INSERT_BEFORE ,
.Nm TAILQ_INSERT_HEAD ,
.Nm TAILQ_INSERT_TAIL ,
.Nm TAILQ_LAST ,
.Nm TAILQ_NEXT ,
.Nm TAILQ_PREV ,
.Nm TAILQ_REMOVE ,
.Nm TAILQ_SWAP
.Nd реализации односвязных списков, односвязных хвостовых очередей,
списков и хвостовых очередей
.Sh ОБЗОР
.In sys/queue.h
.\"
.\" .Fn SLIST_FOREACH_FROM "TYPE *var" "SLIST_HEAD *head" "SLIST_ENTRY NAME"
.\" .Fn SLIST_FOREACH_SAFE "TYPE *var" "SLIST_HEAD *head" "SLIST_ENTRY NAME" "TYPE *temp_var"
.\" .Fn SLIST_FOREACH_FROM_SAFE "TYPE *var" "SLIST_HEAD *head" "SLIST_ENTRY NAME" "TYPE *temp_var"
.\" .Fn SLIST_REMOVE_AFTER "TYPE *elm" "SLIST_ENTRY NAME"
.\" .Fn SLIST_SWAP "SLIST_HEAD *head1" "SLIST_HEAD *head2" "SLIST_ENTRY NAME"
.\"
.\" .Fn STAILQ_FOREACH_FROM "TYPE *var" "STAILQ_HEAD *head" "STAILQ_ENTRY NAME"
.\" .Fn STAILQ_FOREACH_SAFE "TYPE *var" "STAILQ_HEAD *head" "STAILQ_ENTRY NAME" "TYPE *temp_var"
.\" .Fn STAILQ_FOREACH_FROM_SAFE "TYPE *var" "STAILQ_HEAD *head" "STAILQ_ENTRY NAME" "TYPE *temp_var"
.\" .Fn STAILQ_LAST "STAILQ_HEAD *head" "TYPE" "STAILQ_ENTRY NAME"
.\" .Fn STAILQ_REMOVE_AFTER "STAILQ_HEAD *head" "TYPE *elm" "STAILQ_ENTRY NAME"
.\" .Fn STAILQ_SWAP "STAILQ_HEAD *head1" "STAILQ_HEAD *head2" "STAILQ_ENTRY NAME"
.\"
.\" .Fn LIST_FOREACH_FROM "TYPE *var" "LIST_HEAD *head" "LIST_ENTRY NAME"
.\" .Fn LIST_FOREACH_SAFE "TYPE *var" "LIST_HEAD *head" "LIST_ENTRY NAME" "TYPE *temp_var"
.\" .Fn LIST_FOREACH_FROM_SAFE "TYPE *var" "LIST_HEAD *head" "LIST_ENTRY NAME" "TYPE *temp_var"
.\" .Fn LIST_PREV "TYPE *elm" "LIST_HEAD *head" "TYPE" "LIST_ENTRY NAME"
.\"
.\" .Fn TAILQ_FOREACH_FROM "TYPE *var" "TAILQ_HEAD *head" "TAILQ_ENTRY NAME"
.\" .Fn TAILQ_FOREACH_SAFE "TYPE *var" "TAILQ_HEAD *head" "TAILQ_ENTRY NAME" "TYPE *temp_var"
.\" .Fn TAILQ_FOREACH_FROM_SAFE "TYPE *var" "TAILQ_HEAD *head" "TAILQ_ENTRY NAME" "TYPE *temp_var"
.\" .Fn TAILQ_FOREACH_REVERSE_FROM "TYPE *var" "TAILQ_HEAD *head" "HEADNAME" "TAILQ_ENTRY NAME"
.\" .Fn TAILQ_FOREACH_REVERSE_SAFE "TYPE *var" "TAILQ_HEAD *head" "HEADNAME" "TAILQ_ENTRY NAME" "TYPE *temp_var"
.\" .Fn TAILQ_FOREACH_REVERSE_FROM_SAFE "TYPE *var" "TAILQ_HEAD *head" "HEADNAME" "TAILQ_ENTRY NAME" "TYPE *temp_var"
.\"
.Fn SLIST_EMPTY "SLIST_HEAD *head"
.Fn SLIST_ENTRY "TYPE"
.Fn SLIST_FIRST "SLIST_HEAD *head"
.Fn SLIST_FOREACH "TYPE *var" "SLIST_HEAD *head" "SLIST_ENTRY NAME"
.Fn SLIST_HEAD "HEADNAME" "TYPE"
.Fn SLIST_HEAD_INITIALIZER "SLIST_HEAD head"
.Fn SLIST_INIT "SLIST_HEAD *head"
.Fn SLIST_INSERT_AFTER "TYPE *listelm" "TYPE *elm" "SLIST_ENTRY NAME"
.Fn SLIST_INSERT_HEAD "SLIST_HEAD *head" "TYPE *elm" "SLIST_ENTRY NAME"
.Fn SLIST_NEXT "TYPE *elm" "SLIST_ENTRY NAME"
.Fn SLIST_REMOVE_HEAD "SLIST_HEAD *head" "SLIST_ENTRY NAME"
.Fn SLIST_REMOVE "SLIST_HEAD *head" "TYPE *elm" "TYPE" "SLIST_ENTRY NAME"
.Fn STAILQ_CONCAT "STAILQ_HEAD *head1" "STAILQ_HEAD *head2"
.Fn STAILQ_EMPTY "STAILQ_HEAD *head"
.Fn STAILQ_ENTRY "TYPE"
.Fn STAILQ_FIRST "STAILQ_HEAD *head"
.Fn STAILQ_FOREACH "TYPE *var" "STAILQ_HEAD *head" "STAILQ_ENTRY NAME"
.Fn STAILQ_HEAD "HEADNAME" "TYPE"
.Fn STAILQ_HEAD_INITIALIZER "STAILQ_HEAD head"
.Fn STAILQ_INIT "STAILQ_HEAD *head"
.Fn STAILQ_INSERT_AFTER "STAILQ_HEAD *head" "TYPE *listelm" "TYPE *elm" "STAILQ_ENTRY NAME"
.Fn STAILQ_INSERT_HEAD "STAILQ_HEAD *head" "TYPE *elm" "STAILQ_ENTRY NAME"
.Fn STAILQ_INSERT_TAIL "STAILQ_HEAD *head" "TYPE *elm" "STAILQ_ENTRY NAME"
.Fn STAILQ_NEXT "TYPE *elm" "STAILQ_ENTRY NAME"
.Fn STAILQ_REMOVE_HEAD "STAILQ_HEAD *head" "STAILQ_ENTRY NAME"
.Fn STAILQ_REMOVE "STAILQ_HEAD *head" "TYPE *elm" "TYPE" "STAILQ_ENTRY NAME"
.Fn LIST_EMPTY "LIST_HEAD *head"
.Fn LIST_ENTRY "TYPE"
.Fn LIST_FIRST "LIST_HEAD *head"
.Fn LIST_FOREACH "TYPE *var" "LIST_HEAD *head" "LIST_ENTRY NAME"
.Fn LIST_HEAD "HEADNAME" "TYPE"
.Fn LIST_HEAD_INITIALIZER "LIST_HEAD head"
.Fn LIST_INIT "LIST_HEAD *head"
.Fn LIST_INSERT_AFTER "TYPE *listelm" "TYPE *elm" "LIST_ENTRY NAME"
.Fn LIST_INSERT_BEFORE "TYPE *listelm" "TYPE *elm" "LIST_ENTRY NAME"
.Fn LIST_INSERT_HEAD "LIST_HEAD *head" "TYPE *elm" "LIST_ENTRY NAME"
.Fn LIST_NEXT "TYPE *elm" "LIST_ENTRY NAME"
.Fn LIST_REMOVE "TYPE *elm" "LIST_ENTRY NAME"
.Fn LIST_SWAP "LIST_HEAD *head1" "LIST_HEAD *head2" "TYPE" "LIST_ENTRY NAME"
.Fn TAILQ_CONCAT "TAILQ_HEAD *head1" "TAILQ_HEAD *head2" "TAILQ_ENTRY NAME"
.Fn TAILQ_EMPTY "TAILQ_HEAD *head"
.Fn TAILQ_ENTRY "TYPE"
.Fn TAILQ_FIRST "TAILQ_HEAD *head"
.Fn TAILQ_FOREACH "TYPE *var" "TAILQ_HEAD *head" "TAILQ_ENTRY NAME"
.Fn TAILQ_FOREACH_REVERSE "TYPE *var" "TAILQ_HEAD *head" "HEADNAME" "TAILQ_ENTRY NAME"
.Fn TAILQ_HEAD "HEADNAME" "TYPE"
.Fn TAILQ_HEAD_INITIALIZER "TAILQ_HEAD head"
.Fn TAILQ_INIT "TAILQ_HEAD *head"
.Fn TAILQ_INSERT_AFTER "TAILQ_HEAD *head" "TYPE *listelm" "TYPE *elm" "TAILQ_ENTRY NAME"
.Fn TAILQ_INSERT_BEFORE "TYPE *listelm" "TYPE *elm" "TAILQ_ENTRY NAME"
.Fn TAILQ_INSERT_HEAD "TAILQ_HEAD *head" "TYPE *elm" "TAILQ_ENTRY NAME"
.Fn TAILQ_INSERT_TAIL "TAILQ_HEAD *head" "TYPE *elm" "TAILQ_ENTRY NAME"
.Fn TAILQ_LAST "TAILQ_HEAD *head" "HEADNAME"
.Fn TAILQ_NEXT "TYPE *elm" "TAILQ_ENTRY NAME"
.Fn TAILQ_PREV "TYPE *elm" "HEADNAME" "TAILQ_ENTRY NAME"
.Fn TAILQ_REMOVE "TAILQ_HEAD *head" "TYPE *elm" "TAILQ_ENTRY NAME"
.Fn TAILQ_SWAP "TAILQ_HEAD *head1" "TAILQ_HEAD *head2" "TYPE" "TAILQ_ENTRY NAME"
.Sh ОПИСАНИЕ
Данные макросы определяют и управляют четырьмя типами структур данных:
односвязными списками, односвязными хвостовыми очередями, списками и
хвостовыми очередями. Все четыре структуры поддерживают следующие
возможности:
.Pp
.Bl -enum -compact -offset indent
.It 
Вставка нового элемента в начало списка.
.It 
Вставка нового элемента после любого элемента списка.
.It 
Удаление элемента из начала списка за время O(1).
.It 
Обход списка из начала в конец.
.It 
Перестановка содержимого двух списков.
.El
.Pp
Односвязные списки — самая простая из этих четырёх структур данных и
поддерживает только указанные выше возможности. Односвязные списки идеальны
для приложений с большими наборами данных, из которых производится очень
мало удалений, или для реализации очереди LIFO (последним пришёл — первым
ушёл). У односвязных списков есть дополнительное свойство:
.Pp
.Bl -enum -compact -offset indent
.It 
Удаление любого элемента списка за время O(n).
.El
.Pp
У односвязных хвостовых очередей есть дополнительные свойства:
.Pp
.Bl -enum -compact -offset indent
.It 
Добавление элементов в конец списка.
.It 
Удаление любого элемента списка за время O(n).
.It 
Возможность объединения.
.El
.Pp
Однако:
.Pp
.Bl -enum -compact -offset indent
.It 
При вставке элементов нужно указывать начало списка.
.It 
Каждый начальный элемент требует двух указателей вместо одного.
.It 
Код примерно на 15% больше и на 20% медленнее, чем для односвязных списков.
.El
.Pp
Односвязные хвостовые очереди идеальны для приложений с большими наборами
данных из которых производится очень мало удалений, или для реализации
очереди FIFO (первым пришёл — первым ушёл).
.Pp
Все двусвязные типы структур данных (списки и хвостовые очереди)
дополнительно позволяют:
.Pp
.Bl -enum -compact -offset indent
.It 
Вставку нового элемента перед любым элементом списка.
.It 
Удаление любого элемента списка за время O(1).
.El
.Pp
Однако:
.Pp
.Bl -enum -compact -offset indent
.It 
Для каждого элемента требуется два указателя вместо одного.
.It 
Размер кода и время выполнения операций (кроме удаления) удваивается, по
сравнению с односвязными структурами данных.
.El
.Pp
Связные списки — самая простая из двусвязных структур данных. К указанным
выше возможностям для них возможно:
.Pp
.Bl -enum -compact -offset indent
.It 
Обход в обратном направлении.
.El
.Pp
Однако:
.Pp
.Bl -enum -compact -offset indent
.It 
Для обхода в обратном направлении требуется указывать начало обхода и сам
список.
.El
.Pp
У хвостовых очередей есть дополнительные свойства:
.Bl -enum -compact -offset indent
.It 
Добавление элементов в конец списка.
.It 
Обход может идти в обратном направлении, от конца к началу.
.It 
Возможность объединения.
.El
.Pp
Однако:
.Pp
.Bl -enum -compact -offset indent
.It 
При вставке и удалении элементов нужно указывать начало списка.
.It 
Каждый начальный элемент требует двух указателей вместо одного.
.It 
Код примерно на 15% больше и на 20% медленнее, чем для односвязных списков.
.El
.Pp
В определениях макросов
.Fa TYPE
— это имя определяемое пользователем
структуры, которая должна содержать поле типа
.Li SLIST_ENTRY ,
.Li STAILQ_ENTRY ,
.Li LIST_ENTRY
или
.Li TAILQ_ENTRY ,
названное
.Fa NAME .
Аргумент
.Fa HEADNAME
— это имя определяемое пользователем
структуры, которая должна быть объявлена с помощью макроса
.Li SLIST_HEAD ,
.Li STAILQ_HEAD ,
.Li LIST_HEAD
или
.Li TAILQ_HEAD .
Ниже показаны примеры использования этих макросов.
.Ss Односвязные списки
Односвязный список начинается со структуры, определённой макросом
.Nm SLIST_HEAD .
В этой структуре содержится одиночный указатель на первый
элемент списка. Элементы имеют по одной связи для минимизации занимаемого
пространства, а дополнительный расход на операции с указателями равен O(n)
при удалении произвольного элемента. Новые элементы можно добавлять в список
после существующего элемента или в начало списка. Структура
.Fa SLIST_HEAD
объявляется следующим образом:
.Bd -literal -offset indent
SLIST_HEAD(HEADNAME, TYPE) head;
.Ed
.Pp
где
.Fa HEADNAME
— имя определяемой структуры, а
.Fa TYPE
— тип
элементов, объединяемых в список. Указатель на начало списка может в
дальнейшем объявляться так:
.Bd -literal -offset indent
struct HEADNAME *headp;
.Ed
.Pp
(Имена
.Li head
и
.Li headp
могут выбираться пользователем.)
.Pp
Макрос
.Nm SLIST_HEAD_INITIALIZER
запускает инициализатор для
.Fa head
списка.
.Pp
Макрос
.Nm SLIST_EMPTY
возвращает true, если в списке нет элементов.
.Pp
Макрос
.Nm SLIST_ENTRY
объявляет структуру, которая добавляет элементы в
список.
.Pp
Макрос
.Nm SLIST_FIRST
возвращает первый элемент списка или NULL, если
список пуст.
.Pp
.\" .Pp
.\" The macro
.\" .Nm SLIST_FOREACH_FROM
.\" behaves identically to
.\" .Nm SLIST_FOREACH
.\" when
.\" .Fa var
.\" is NULL, else it treats
.\" .Fa var
.\" as a previously found SLIST element and begins the loop at
.\" .Fa var
.\" instead of the first element in the SLIST referenced by
.\" .Fa head .
.\" .Pp
.\" The macro
.\" .Nm SLIST_FOREACH_SAFE
.\" traverses the list referenced by
.\" .Fa head
.\" in the forward direction, assigning each element in
.\" turn to
.\" .Fa var .
.\" However, unlike
.\" .Fn SLIST_FOREACH
.\" here it is permitted to both remove
.\" .Fa var
.\" as well as free it from within the loop safely without interfering with the
.\" traversal.
.\" .Pp
.\" The macro
.\" .Nm SLIST_FOREACH_FROM_SAFE
.\" behaves identically to
.\" .Nm SLIST_FOREACH_SAFE
.\" when
.\" .Fa var
.\" is NULL, else it treats
.\" .Fa var
.\" as a previously found SLIST element and begins the loop at
.\" .Fa var
.\" instead of the first element in the SLIST referenced by
.\" .Fa head .
Макрос
.Nm SLIST_FOREACH
обходит список, на который ссылается
.Fa head ,
от начало в конец, назначая
.Fa var
каждый элемент.
.Pp
Макрос
.Nm SLIST_INIT
инициализирует список, на который ссылается
.Fa head .
.Pp
Макрос
.Nm SLIST_INSERT_HEAD
вставляет новый элемент
.Fa elm
в начало
списка.
.Pp
Макрос
.Nm SLIST_INSERT_AFTER
вставляет новый элемент
.Fa elm
за
элементом
.Fa listelm .
.Pp
.\" .Pp
.\" The macro
.\" .Nm SLIST_REMOVE_AFTER
.\" removes the element after
.\" .Fa elm
.\" from the list.
.\" Unlike
.\" .Fa SLIST_REMOVE ,
.\" this macro does not traverse the entire list.
Макрос
.Nm SLIST_NEXT
возвращает следующий элемент списка.
.Pp
Макрос
.Nm SLIST_REMOVE_HEAD
удаляет элемент
.Fa elm
из начала
списка. В целях эффективности удаления элемента из начала списка нужно
использовать именно этот макрос вместо обычного
.Fa SLIST_REMOVE .
.Pp
.\" .Pp
.\" The macro
.\" .Nm SLIST_SWAP
.\" swaps the contents of
.\" .Fa head1
.\" and
.\" .Fa head2 .
Макрос
.Nm SLIST_REMOVE
удаляет элемент
.Fa elm
из списка.
.Ss Пример односвязного списка
.Bd -literal
SLIST_HEAD(slisthead, entry) head =
    SLIST_HEAD_INITIALIZER(head);
struct slisthead *headp;		/* начало односвязного
                                           списка */
struct entry {
	...
	SLIST_ENTRY(entry) entries;	/* односвязный список */
	...
} *n1, *n2, *n3, *np;

SLIST_INIT(&head);			/* инициализация списка */

n1 = malloc(sizeof(struct entry));	/* вставка начального элемента */
SLIST_INSERT_HEAD(&head, n1, entries);

n2 = malloc(sizeof(struct entry));	/* вставка последующих */
SLIST_INSERT_AFTER(n1, n2, entries);

SLIST_REMOVE(&head, n2, entry, entries);/* удаление */
free(n2);

.\"					/* Safe forward traversal. */
.\"SLIST_FOREACH_SAFE(np, &head, entries, np_temp) {
.\"	np\->do_stuff();
.\"	...
.\"	SLIST_REMOVE(&head, np, entry, entries);
.\"	free(np);
.\"}
n3 = SLIST_FIRST(&head);
SLIST_REMOVE_HEAD(&head, entries);	/* удаление начального элемента */
free(n3);
					/* обход из начала в конец */
SLIST_FOREACH(np, &head, entries)
	np\-> ...

while (!SLIST_EMPTY(&head)) {		/* удаление списка */
	n1 = SLIST_FIRST(&head);
	SLIST_REMOVE_HEAD(&head, entries);
	free(n1);
}
.Ed
.Ss Односвязные хвостовые очереди
Односвязная хвостовая очередь начинается со структуры, определяемой макросом
.Nm STAILQ_HEAD .
В этой структуре содержится пара указателей, один на
первый элемент хвостовой очереди, а другой на последний элемент. Элементы
имеют по одной связи для минимизации занимаемого пространства, а
дополнительный расход на операции с указателями равен O(n) при удалении
произвольного элемента. Новые элементы можно добавлять в хвостовую очередь
после существующего элемента, в начало или конец хвостовой очереди,
Структура
.Fa STAILQ_HEAD
объявляется следующим образом:
.Bd -literal -offset indent
STAILQ_HEAD(HEADNAME, TYPE) head;
.Ed
.Pp
где
.Li HEADNAME
— имя определяемой структуры, а
.Li TYPE
— тип
связанных элементов в хвостовой очереди. Указатель на начало хвостовой
очереди может в дальнейшем объявляться так:
.Bd -literal -offset indent
struct HEADNAME *headp;
.Ed
.Pp
(Имена
.Li head
и
.Li headp
могут выбираться пользователем.)
.Pp
Макрос
.Nm STAILQ_HEAD_INITIALIZER
запускает инициализатор для
.Fa head
хвостовой очереди.
.Pp
Макрос
.Nm STAILQ_CONCAT
добавляет хвостовую очередь с началом
.Fa head2
в конец очереди с началом
.Fa head1 ,
удаляя все элементы из
первой.
.Pp
Макрос
.Nm STAILQ_EMPTY
возвращает true, если в хвостовой очереди нет
элементов.
.Pp
Макрос
.Nm STAILQ_ENTRY
объявляет структуру, которая подключает элементы
в хвостовую очередь.
.Pp
Макрос
.Nm STAILQ_FIRST
возвращает первый элемент из хвостовой очереди
или NULL, если очередь пуста.
.Pp
.\" .Pp
.\" The macro
.\" .Nm STAILQ_FOREACH_FROM
.\" behaves identically to
.\" .Nm STAILQ_FOREACH
.\" when
.\" .Fa var
.\" is NULL, else it treats
.\" .Fa var
.\" as a previously found STAILQ element and begins the loop at
.\" .Fa var
.\" instead of the first element in the STAILQ referenced by
.\" .Fa head .
.\" .Pp
.\" The macro
.\" .Nm STAILQ_FOREACH_SAFE
.\" traverses the tail queue referenced by
.\" .Fa head
.\" in the forward direction, assigning each element
.\" in turn to
.\" .Fa var .
.\" However, unlike
.\" .Fn STAILQ_FOREACH
.\" here it is permitted to both remove
.\" .Fa var
.\" as well as free it from within the loop safely without interfering with the
.\" traversal.
.\" .Pp
.\" The macro
.\" .Nm STAILQ_FOREACH_FROM_SAFE
.\" behaves identically to
.\" .Nm STAILQ_FOREACH_SAFE
.\" when
.\" .Fa var
.\" is NULL, else it treats
.\" .Fa var
.\" as a previously found STAILQ element and begins the loop at
.\" .Fa var
.\" instead of the first element in the STAILQ referenced by
.\" .Fa head .
Макрос
.Nm STAILQ_FOREACH
обходит хвостовую очередь, на которую ссылается
.Fa head ,
из начала в конец, назначая
.Fa var
каждый элемент.
.Pp
Макрос
.Nm STAILQ_INIT
инициализирует хвостовую очередь, на которую
ссылается
.Fa head .
.Pp
Макрос
.Nm STAILQ_INSERT_HEAD
вставляет новый элемент I
.Fa elm
в
начало хвостовой очереди.
.Pp
Макрос
.Nm STAILQ_INSERT_TAIL
вставляет новый элемент
.Fa elm
в конец
хвостовой очереди.
.Pp
.\" .Pp
.\" The macro
.\" .Nm STAILQ_LAST
.\" returns the last item on the tail queue.
.\" If the tail queue is empty the return value is
.\" .Dv NULL .
Макрос
.Nm STAILQ_INSERT_AFTER
вставляет новый элемент
.Fa elm
за
элементом
.Fa listelm .
.Pp
.\" .Pp
.\" The macro
.\" .Nm STAILQ_REMOVE_AFTER
.\" removes the element after
.\" .Fa elm
.\" from the tail queue.
.\" Unlike
.\" .Fa STAILQ_REMOVE ,
.\" this macro does not traverse the entire tail queue.
Макрос
.Nm STAILQ_NEXT
возвращает следующий элемент из хвостовой очереди
или NULL, если элемент последний.
.Pp
Макрос
.Nm STAILQ_REMOVE_HEAD
удаляет элемент из начала хвостовой
очереди. В целях эффективности удаления элемента из начала хвостовой очереди
нужно использовать именно этот макрос вместо обычного
.Fa STAILQ_REMOVE .
.Pp
.\" .Pp
.\" The macro
.\" .Nm STAILQ_SWAP
.\" swaps the contents of
.\" .Fa head1
.\" and
.\" .Fa head2 .
Макрос
.Nm STAILQ_REMOVE
удаляет элемент
.Fa elm
из хвостовой очереди.
.Ss Пример односвязной хвостовой очереди
.Bd -literal
STAILQ_HEAD(stailhead, entry) head =
    STAILQ_HEAD_INITIALIZER(head);
struct stailhead *headp;		/* начало односвязной хвостовой
                               очереди */
struct entry {
	...
	STAILQ_ENTRY(entry) entries;	/* хвостовая очередь */
	...
} *n1, *n2, *n3, *np;

STAILQ_INIT(&head);			/* инициализация очереди */

n1 = malloc(sizeof(struct entry));	/* вставка начального элемента */
STAILQ_INSERT_HEAD(&head, n1, entries);

n1 = malloc(sizeof(struct entry));	/* вставка в очередь */
STAILQ_INSERT_TAIL(&head, n1, entries);

.\"					/* Safe forward traversal. */
.\"STAILQ_FOREACH_SAFE(np, &head, entries, np_temp) {
.\"	np\->do_stuff();
.\"	...
.\"	STAILQ_REMOVE(&head, np, entry, entries);
.\"	free(np);
.\"}
n2 = malloc(sizeof(struct entry));	/* вставка последующего */
STAILQ_INSERT_AFTER(&head, n1, n2, entries);
					/* удаление */
STAILQ_REMOVE(&head, n2, entry, entries);
free(n2);
					/* удаление из начала */
n3 = STAILQ_FIRST(&head);
STAILQ_REMOVE_HEAD(&head, entries);
free(n3);
					/* обход от начала в конец */
STAILQ_FOREACH(np, &head, entries)
	np\-> ...
					/* удаление TailQ */
while (!STAILQ_EMPTY(&head)) {
	n1 = STAILQ_FIRST(&head);
	STAILQ_REMOVE_HEAD(&head, entries);
	free(n1);
}
					/* быстрое удаление TailQ */
n1 = STAILQ_FIRST(&head);
while (n1 != NULL) {
	n2 = STAILQ_NEXT(n1, entries);
	free(n1);
	n1 = n2;
}
STAILQ_INIT(&head);
.Ed
.Ss Списки
Список начинается структурой, определённой макросом
.Nm LIST_HEAD .
Эта
структура содержит единственный указатель на первый элемент списка. Элементы
дважды связаны, поэтому произвольный элемент можно удалить без прохода по
всему списку. Новые элементы могут быть добавлены в список перед или после
существующего элемента, а также в начало списка. Структура
.Fa LIST_HEAD
объявляется следующим образом:
.Bd -literal -offset indent
LIST_HEAD(HEADNAME, TYPE) head;
.Ed
.Pp
где
.Fa HEADNAME
— имя определяемой структуры, а
.Fa TYPE
— тип
элементов, объединяемых в список. Указатель на начало списка может в
дальнейшем объявляться так:
.Bd -literal -offset indent
struct HEADNAME *headp;
.Ed
.Pp
(Имена
.Li head
и
.Li headp
могут выбираться пользователем.)
.Pp
Макрос
.Nm LIST_HEAD_INITIALIZER
запускает инициализатор для
.Fa head
списка.
.Pp
Макрос
.Nm LIST_EMPTY
возвращает true, если в списке нет элементов.
.Pp
Макрос
.Nm LIST_ENTRY
объявляет структуру, которая добавляет элементы в
список.
.Pp
Макрос
.Nm LIST_FIRST
возвращает первый элемент списка или NULL, если
список пуст.
.Pp
.\" .Pp
.\" The macro
.\" .Nm LIST_FOREACH_FROM
.\" behaves identically to
.\" .Nm LIST_FOREACH
.\" when
.\" .Fa var
.\" is NULL, else it treats
.\" .Fa var
.\" as a previously found LIST element and begins the loop at
.\" .Fa var
.\" instead of the first element in the LIST referenced by
.\" .Fa head .
.\" .Pp
.\" The macro
.\" .Nm LIST_FOREACH_SAFE
.\" traverses the list referenced by
.\" .Fa head
.\" in the forward direction, assigning each element in turn to
.\" .Fa var .
.\" However, unlike
.\" .Fn LIST_FOREACH
.\" here it is permitted to both remove
.\" .Fa var
.\" as well as free it from within the loop safely without interfering with the
.\" traversal.
.\" .Pp
.\" The macro
.\" .Nm LIST_FOREACH_FROM_SAFE
.\" behaves identically to
.\" .Nm LIST_FOREACH_SAFE
.\" when
.\" .Fa var
.\" is NULL, else it treats
.\" .Fa var
.\" as a previously found LIST element and begins the loop at
.\" .Fa var
.\" instead of the first element in the LIST referenced by
.\" .Fa head .
Макрос
.Nm LIST_FOREACH
обходит список, на который ссылается
.Fa head ,
от начало в конец, назначая
.Fa var
каждый элемент.
.Pp
Макрос
.Nm LIST_INIT
инициализирует список, на который ссылается
.Fa head .
.Pp
Макрос
.Nm LIST_INSERT_HEAD
вставляет новый элемент
.Fa elm
в начало
списка.
.Pp
Макрос
.Nm LIST_INSERT_AFTER
вставляет новый элемент
.Fa elm
за
элементом
.Fa listelm .
.Pp
Макрос
.Nm LIST_INSERT_AFTER
вставляет новый элемент
.Fa elm
перед
элементом
.Fa listelm .
.Pp
.\" .Pp
.\" The macro
.\" .Nm LIST_PREV
.\" returns the previous element in the list, or NULL if this is the first.
.\" List
.\" .Fa head
.\" must contain element
.\" .Fa elm .
Макрос
.Nm LIST_NEXT
возвращает следующий элемент списка или NULL, если
элемент последний.
.Pp
.\" .Pp
.\" The macro
.\" .Nm LIST_SWAP
.\" swaps the contents of
.\" .Fa head1
.\" and
.\" .Fa head2 .
Макрос
.Nm LIST_REMOVE
удаляет элемент
.Fa elm
из списка.
.Ss Пример списка
.Bd -literal
LIST_HEAD(listhead, entry) head =
    LIST_HEAD_INITIALIZER(head);
struct listhead *headp;			/* начало списка */
struct entry {
	...
	LIST_ENTRY(entry) entries;	/* список */
	...
} *n1, *n2, *n3, *np, *np_temp;

LIST_INIT(&head);			/* инициализация списка */

n1 = malloc(sizeof(struct entry));	/* вставка в начало */
LIST_INSERT_HEAD(&head, n1, entries);

n2 = malloc(sizeof(struct entry));	/* вставка последующего */
LIST_INSERT_AFTER(n1, n2, entries);

n3 = malloc(sizeof(struct entry));	/* вставка перед */
LIST_INSERT_BEFORE(n2, n3, entries);

LIST_REMOVE(n2, entries);		/* удаление */
free(n2);
					/* обход из начала в конец */
LIST_FOREACH(np, &head, entries)
	np\-> ...

.\" 					/* Safe forward traversal. */
.\" LIST_FOREACH_SAFE(np, &head, entries, np_temp) {
.\" 	np\->do_stuff();
.\" 	...
.\" 	LIST_REMOVE(np, entries);
.\" 	free(np);
.\" }
.\"
while (!LIST_EMPTY(&head)) {		/* удаление списка */
	n1 = LIST_FIRST(&head);
	LIST_REMOVE(n1, entries);
	free(n1);
}

n1 = LIST_FIRST(&head);			/* быстрое удаление списка */
while (n1 != NULL) {
	n2 = LIST_NEXT(n1, entries);
	free(n1);
	n1 = n2;
}
LIST_INIT(&head);
.Ed
.Ss Хвостовые очереди
Хвостовая очередь начинается со структуры, определяемой макросом
.Nm TAILQ_HEAD .
Эта структура содержит пару указателей, один для первого
элемента хвостовой очереди, а другой для последнего элемента хвостовой
очереди. Элементы связаны дважды так, что любой элемент может быть удалён
без прохождения по всей очереди. Новые элементы могут быть добавлены в
хвостовую очередь перед и после существующего элемента, в конец или в начало
очереди. Структура
.Fa TAILQ_HEAD
объявляется следующим образом:
.Bd -literal -offset indent
TAILQ_HEAD(HEADNAME, TYPE) head;
.Ed
.Pp
где
.Li HEADNAME
— имя определяемой структуры, а
.Li TYPE
— тип
связанных элементов в хвостовой очереди. Указатель на начало хвостовой
очереди может в дальнейшем объявляться так:
.Bd -literal -offset indent
struct HEADNAME *headp;
.Ed
.Pp
(Имена
.Li head
и
.Li headp
могут выбираться пользователем.)
.Pp
Макрос
.Nm TAILQ_HEAD_INITIALIZER
запускает инициализатор для
.Fa head
хвостовой очереди.
.Pp
Макрос
.Nm TAILQ_CONCAT
добавляет хвостовую очередь с началом
.Fa head2
в конец очереди с началом
.Fa head1 ,
удаляя все элементы из
первой.
.Pp
Макрос
.Nm TAILQ_EMPTY
возвращает true, если в хвостовой очереди нет
элементов.
.Pp
Макрос
.Nm TAILQ_ENTRY
объявляет структуру, которая подключает элементы в
хвостовую очередь.
.Pp
Макрос
.Nm TAILQ_FIRST
возвращает первый элемент из хвостовой очереди или
NULL, если очередь пуста.
.Pp
.\" .Pp
.\" The macro
.\" .Nm TAILQ_FOREACH_FROM
.\" behaves identically to
.\" .Nm TAILQ_FOREACH
.\" when
.\" .Fa var
.\" is NULL, else it treats
.\" .Fa var
.\" as a previously found TAILQ element and begins the loop at
.\" .Fa var
.\" instead of the first element in the TAILQ referenced by
.\" .Fa head .
Макрос
.Nm TAILQ_FOREACH
обходит хвостовую очередь, на которую ссылается
.Fa head ,
из начала в конец, назначая
.Fa var
каждый элемент. Значение
.Fa var
равно
.Dv NULL ,
если пройдена вся очередь или в ней нет
элементов.
.Pp
.\" .Pp
.\" The macro
.\" .Nm TAILQ_FOREACH_REVERSE_FROM
.\" behaves identically to
.\" .Nm TAILQ_FOREACH_REVERSE
.\" when
.\" .Fa var
.\" is NULL, else it treats
.\" .Fa var
.\" as a previously found TAILQ element and begins the reverse loop at
.\" .Fa var
.\" instead of the last element in the TAILQ referenced by
.\" .Fa head .
.\" .Pp
.\" The macros
.\" .Nm TAILQ_FOREACH_SAFE
.\" and
.\" .Nm TAILQ_FOREACH_REVERSE_SAFE
.\" traverse the list referenced by
.\" .Fa head
.\" in the forward or reverse direction respectively,
.\" assigning each element in turn to
.\" .Fa var .
.\" However, unlike their unsafe counterparts,
.\" .Nm TAILQ_FOREACH
.\" and
.\" .Nm TAILQ_FOREACH_REVERSE
.\" permit to both remove
.\" .Fa var
.\" as well as free it from within the loop safely without interfering with the
.\" traversal.
.\" .Pp
.\" The macro
.\" .Nm TAILQ_FOREACH_FROM_SAFE
.\" behaves identically to
.\" .Nm TAILQ_FOREACH_SAFE
.\" when
.\" .Fa var
.\" is NULL, else it treats
.\" .Fa var
.\" as a previously found TAILQ element and begins the loop at
.\" .Fa var
.\" instead of the first element in the TAILQ referenced by
.\" .Fa head .
.\" .Pp
.\" The macro
.\" .Nm TAILQ_FOREACH_REVERSE_FROM_SAFE
.\" behaves identically to
.\" .Nm TAILQ_FOREACH_REVERSE_SAFE
.\" when
.\" .Fa var
.\" is NULL, else it treats
.\" .Fa var
.\" as a previously found TAILQ element and begins the reverse loop at
.\" .Fa var
.\" instead of the last element in the TAILQ referenced by
.\" .Fa head .
Макрос
.Nm TAILQ_FOREACH_REVERSE
обходит хвостовую очередь, на которую
ссылается
.Fa head ,
в обратном направлении, назначая
.Fa var
каждый
элемент.
.Pp
Макрос
.Nm TAILQ_INIT
инициализирует хвостовую очередь, на которую
ссылается
.Fa head .
.Pp
Макрос
.Nm TAILQ_INSERT_HEAD
вставляет новый элемент I
.Fa elm
в начало
хвостовой очереди.
.Pp
Макрос
.Nm TAILQ_INSERT_TAIL
вставляет новый элемент
.Fa elm
в конец
хвостовой очереди.
.Pp
Макрос
.Nm TAILQ_INSERT_AFTER
вставляет новый элемент
.Fa elm
за
элементом
.Fa listelm .
.Pp
Макрос
.Nm TAILQ_INSERT_BEFORE
вставляет новый элемент
.Fa elm
перед
элементом
.Fa listelm .
.Pp
Макрос
.Nm TAILQ_LAST
возвращает последний элемент из хвостовой очереди
или
.Dv NULL ,
если очередь пуста.
.Pp
Макрос
.Nm TAILQ_NEXT
возвращает следующий элемент из хвостовой очереди
или NULL, если элемент последний.
.Pp
Макрос
.Nm TAILQ_PREV
возвращает предыдущий элемент из хвостовой очереди
или NULL, если элемент первый.
.Pp
Макрос
.Nm TAILQ_REMOVE
удаляет элемент
.Fa elm
из хвостовой очереди.
.Pp
Макрос
.Nm TAILQ_SWAP
меняет местами содержимое
.Fa head1
и
.Fa head2 .
.Ss Пример хвостовой очереди
.Bd -literal
TAILQ_HEAD(tailhead, entry) head =
    TAILQ_HEAD_INITIALIZER(head);
struct tailhead *headp;			/* начало хвостовой очереди */
struct entry {
	...
	TAILQ_ENTRY(entry) entries;	/* хвостовая очередь */
	...
} *n1, *n2, *n3, *np;

TAILQ_INIT(&head);			/* инициализация очереди */

n1 = malloc(sizeof(struct entry));	/* вставка в начало */
TAILQ_INSERT_HEAD(&head, n1, entries);

n1 = malloc(sizeof(struct entry));	/* вставка в конец */
TAILQ_INSERT_TAIL(&head, n1, entries);

n2 = malloc(sizeof(struct entry));	/* вставка последующего */
TAILQ_INSERT_AFTER(&head, n1, n2, entries);

n3 = malloc(sizeof(struct entry));	/* вставка перед */
TAILQ_INSERT_BEFORE(n2, n3, entries);

.\" 					/* Safe forward traversal. */
.\" TAILQ_FOREACH_SAFE(np, &head, entries, np_temp) {
.\" 	np\->do_stuff();
.\" 	...
.\" 	TAILQ_REMOVE(&head, np, entries);
.\" 	free(np);
.\" }
TAILQ_REMOVE(&head, n2, entries);	/* удаление */
free(n2);
					/* обход из начало в конец */
TAILQ_FOREACH(np, &head, entries)
	np\-> ...
					/* обход в обратном направлении */
TAILQ_FOREACH_REVERSE(np, &head, tailhead, entries)
	np\-> ...
					/* удаление TailQ */
while (!TAILQ_EMPTY(&head)) {
	n1 = TAILQ_FIRST(&head);
	TAILQ_REMOVE(&head, n1, entries);
	free(n1);
}
					/* быстрое удаление TailQ */
n1 = TAILQ_FIRST(&head);
while (n1 != NULL) {
	n2 = TAILQ_NEXT(n1, entries);
	free(n1);
	n1 = n2;
}

TAILQ_INIT(&head);
n2 = malloc(sizeof(struct entry));  /* вставка перед */
CIRCLEQ_INSERT_BEFORE(&head, n1, n2, entries);
                                    /* обход из начала в конец */
for (np = head.cqh_first; np != (void *)&head;
        np = np\->entries.cqe_next)
    np\-> ...
                                    /* обход в обратном направлении */
for (np = head.cqh_last; np != (void *)&head; np = np\->entries.cqe_prev)
    np\-> ...
                                    /* удаление */
while (head.cqh_first != (void *)&head)
    CIRCLEQ_REMOVE(&head, head.cqh_first, entries);
.Ed
.Sh СООТВЕТСТВИЕ СТАНДАРТАМ
Нет в POSIX.1, POSIX.1-2001 и POSIX.1-2008. Присутствует в BSD.  Функции
.Nm queue
впервые появились в
.Bx 4.4 .
.Sh СМОТРИТЕ ТАКЖЕ
.Xr insque 3
.\" .Xr tree 3
