.\" -*- mode: troff; coding: UTF-8 -*-
.\" Copyright (C) 2014 Michael Kerrisk <mtk.manpages@gmail.com>
.\" and Copyright (C) 2014 Peter Zijlstra <peterz@infradead.org>
.\" and Copyright (C) 2014 Juri Lelli <juri.lelli@gmail.com>
.\" Various pieces from the old sched_setscheduler(2) page
.\" 	Copyright (C) Tom Bjorkholm, Markus Kuhn & David A. Wheeler 1996-1999
.\" 	and Copyright (C) 2007 Carsten Emde <Carsten.Emde@osadl.org>
.\" 	and Copyright (C) 2008 Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" %%%LICENSE_START(GPLv2+_DOC_FULL)
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, see
.\" <http://www.gnu.org/licenses/>.
.\" %%%LICENSE_END
.\"
.\" Worth looking at: http://rt.wiki.kernel.org/index.php
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH SCHED 7 2019\-08\-02 Linux "Руководство программиста Linux"
.SH ИМЯ
sched \- обзор планирования работы ЦП
.SH ОПИСАНИЕ
.\"
Начиная с Linux 2.6.23 планировщиком по умолчанию является CFS — «полностью
честный планировщик» (Completely Fair Scheduler). Планировщик CFS заменил
использовавшийся ранее «O(1)».
.SS "Краткие сведения о программном интерфейсе"
Для управления планированием, алгоритмом и приоритетом процессов (более
точно, нитей) на ЦП в Linux имеются следующие системные вызовы:
.TP 
\fBnice\fP(2)
Назначает новое значение уступчивости вызвавшей нити и возвращает новое
значение уступчивости.
.TP 
\fBgetpriority\fP(2)
Возвращает значение уступчивости нити, группы процессов или набора нитей,
принадлежащих указанному пользователю.
.TP 
\fBsetpriority\fP(2)
Изменяет значение уступчивости нити, группы процессов или набора нитей,
принадлежащих указанному пользователю.
.TP 
\fBsched_setscheduler\fP(2)
Назначает алгоритм планирования и параметры заданной нити.
.TP 
\fBsched_getscheduler\fP(2)
Возвращает алгоритм планирования и параметры заданной нити.
.TP 
\fBsched_setparam\fP(2)
Назначает параметры планирования заданной нити.
.TP 
\fBsched_getparam\fP(2)
Возвращает параметры планирования заданной нити.
.TP 
\fBsched_get_priority_max\fP(2)
Возвращает максимальный приоритет, доступный заданному алгоритму
планирования.
.TP 
\fBsched_get_priority_min\fP(2)
Возвращает минимальный приоритет, доступный заданному алгоритму
планирования.
.TP 
\fBsched_rr_get_interval\fP(2)
Возвращает квант, используемый нитями, которые запланированы «циклическим»
(round\-robin) алгоритмом планирования.
.TP 
\fBsched_yield\fP(2)
Заставляет вызывающего освободить ЦП для выполнения других нитей.
.TP 
\fBsched_setaffinity\fP(2)
(только в Linux) Назначить увязываемый ЦП указанной нити.
.TP 
\fBsched_getaffinity\fP(2)
(только в Linux) Возвращает увязываемый ЦП указанной нити.
.TP 
\fBsched_setattr\fP(2)
Назначает алгоритм планирования и параметры заданной нити. Данный системный
вызов (есть только в Linux) предоставляет охватывающий набор возможностей
\fBsched_setscheduler\fP(2) и \fBsched_setparam\fP(2).
.TP 
\fBsched_getattr\fP(2)
.\"
Возвращает алгоритм планирования и параметры заданной нити. Данный системный
вызов (есть только в Linux) предоставляет охватывающий набор возможностей
\fBsched_setscheduler\fP(2) и \fBsched_setparam\fP(2).
.SS "Алгоритмы планирования"
Планировщик — это часть ядра, которая решает какая запущенная нить будет
выполняться процессором следующей. Каждой нити назначается алгоритм
планирования и \fIстатический\fP приоритет планирования,
\fIsched_priority\fP. Планировщик принимает решение на основе данных об
алгоритме планирования и статическом приоритете всех нитей системы.
.PP
Для нитей, которые планируются одним из обычных алгоритмом планирования
(\fBSCHED_OTHER\fP, \fBSCHED_IDLE\fP, \fBSCHED_BATCH\fP), значение \fIsched_priority\fP
при принятии решения не используется (должен быть указан 0).
.PP
Для процессов, которые планируются одним из алгоритмов реального времени
(\fBSCHED_FIFO\fP, \fBSCHED_RR\fP), значение приоритета \fIsched_priority\fP лежит в
диапазоне от 1 (низкий) до 99 (высокий) Как и числовые значения, нити
реального времени всегда имеют более высокий приоритет чем обычные нити. Но
заметим: согласно POSIX.1 от реализации для алгоритмов реального времени
требуется поддержка только 32 различных уровней приоритета, и в некоторых
системах обеспечивается только этот минимум. В переносимых программах нужно
использовать вызовы \fBsched_get_priority_min\fP(2) и
\fBsched_get_priority_max\fP(2) для для определения диапазона приоритетов,
поддерживаемых определённым алгоритмом.
.PP
По существу, планировщик хранит в памяти списки всех работающих нитей для
каждого возможного значения \fIsched_priority\fP. Чтобы определить какую нить
выполнять следующей, планировщик ищет непустой список с самым высоким
статическим приоритетом и выбирает нить из начала списка.
.PP
Алгоритм планирования определяет, в какое место списка будет добавлена нить
с тем же статическим приоритетом и как она будет перемещаться внутри этого
списка.
.PP
Всё планирование основано на вытеснении: если нить с высшим статическим
приоритетом готова к выполнению, текущая выполняющаяся нить будет вытеснена
и возвращена в список ожидания согласно своему уровню статического
приоритета. Алгоритм выполнения определяет порядок только внутри списка
готовых к выполнению нитей с одинаковым статическим приоритетом.
.SS "SCHED_FIFO: планировщик «первым вошёл — первым вышел»"
Алгоритм \fBSCHED_FIFO\fP можно использовать только со значениями статического
приоритета большими нуля. Это означает, что если нить с \fBSCHED_FIFO\fP готова
к работе, то она сразу запустится, а все обычные нити с \fBSCHED_OTHER\fP,
\fBSCHED_BATCH\fP или \fBSCHED_IDLE\fP будут приостановлены. \fBSCHED_FIFO\fP — это
простой алгоритм планирования без квантования времени. Нити, работающие
согласно алгоритму \fBSCHED_FIFO\fP, подчиняются следующим правилам:
.IP 1) 3
Нить, выполняемая с алгоритмом \fBSCHED_FIFO\fP и вытесненная другой нитью с
большим приоритетом, останется в начале списка нитей с приоритетом как у
неё, и её исполнение будет продолжено сразу после того, как закончатся нити
с большими приоритетами.
.IP 2)
Когда заблокированная нить с алгоритмом \fBSCHED_FIFO\fP готова к работе, она
помещается в конец списка нитей с приоритетом как у неё.
.IP 3)
Если вызовом \fBsched_setscheduler\fP(2), \fBsched_setparam\fP(2),
\fBsched_setattr\fP(2), \fBpthread_setschedparam\fP(3) или
\fBpthread_setschedprio\fP(3) изменяется приоритет выполняющейся или готовой к
выполнению нити \fBSCHED_FIFO\fP, задаваемой \fIpid\fP, то  результат положения
нити в списке зависит от направления изменения приоритета нити:
.RS
.IP \(bu 3
Если приоритет нити повышается, то она помещается в конец списка со своим
новым приоритетом. В результате, может быть вытеснена выполняемая в этот
момент нить с таким же приоритетом.
.IP \(bu
Если приоритет нити не изменяется, то её положение в списке выполнения не
изменяется.
.IP \(bu
Если приоритет нити понижается, то она помещается в начало списка со своим
новым приоритетом.
.RE
.IP
.\" In 2.2.x and 2.4.x, the thread is placed at the front of the queue
.\" In 2.0.x, the Right Thing happened: the thread went to the back -- MTK
Согласно POSIX.1\-2008 изменение приоритета нити (или алгоритма) с помощью
какого\-либо механизма отличного от \fBpthread_setschedprio\fP(3), должно
приводить к размещению нити в конец списка с её приоритетом.
.IP 4)
Нить, вызывающая \fBsched_yield\fP(2), будет помещена в конец списка.
.PP
Других событий для перемещения нити с алгоритмом \fBSCHED_FIFO\fP в списке
ожидания запускаемых нитей с одинаковым статическим приоритетом не
существует.
.PP
Нить с алгоритмом \fBSCHED_FIFO\fP выполняется до тех пор, пока не будет
заблокирована запросом ввода/вывода, вытеснена нитью с большим приоритетом
или пока не вызовет \fBsched_yield\fP(2).
.SS "SCHED_RR: планирование выполнения по циклу"
.\" On Linux 2.4, the length of the RR interval is influenced
.\" by the process nice value -- MTK
.\"
\fBSCHED_RR\fP — это просто улучшение \fBSCHED_FIFO\fP. Всё, относящееся к
\fBSCHED_FIFO\fP, справедливо и для \fBSCHED_RR\fP за исключением того, что каждой
нити разрешено работать непрерывно не дольше максимального кванта
времени. Если нить с алгоритмом \fBSCHED_RR\fP работала столько же или дольше,
чем квант, то она помещается в конец списка с тем же приоритетом. Нить с
алгоритмом \fBSCHED_RR\fP, вытесненная нитью с большим приоритетом, возобновляя
работу, использует остаток своего кванта из старого цикла. Длину этого
кванта можно узнать, вызвав \fBsched_rr_get_interval\fP(2).
.SS "SCHED_DEADLINE: Модель планирования случайной задачи с предельным сроком"
Начиная с версии 3.14, в Linux появился алгоритм планирования с предельным
сроком (\fBSCHED_DEADLINE\fP). Сейчас этот алгоритм реализован с помощью GEDF
(Global Earliest Deadline First) в совокупности с CBS (Constant Bandwidth
Server). Для назначения и выборки данного алгоритма и его атрибутов, нужно
использовать системные вызовы (есть только в Linux) \fBsched_setattr\fP(2) и
\fBsched_getattr\fP(2).
.PP
Случайная задача — одна из последовательности заданий (jobs), где каждое
задание активизируется не более чем один раз за промежуток времени. Также у
каждого задания есть \fIотносительный крайний срок\fP, до которого оно должно
завершить выполнение и \fIвремя вычисления\fP — время ЦП, необходимое для
выполнения задания. Момент, когда задача пробуждается из\-за выполнения
нового задания, называется \fIвременем принятия (arrival time)\fP (его ещё
называют временем запроса (request time) или временем выпуска (release
time). \fIВремя начала\fP — это время когда задача начинает
выполнение. \fIАбсолютный предельный срок\fP получается сложением
относительного предельного срока с временем принятия.
.PP
Эти определения показаны в следующей диаграмме:
.PP
.in +4n
.EX
принятие/пробуждение                    абсолютный предельный срок
     |    время начала                  |
     |        |                         |
     v        v                         v
\-\-\-\-\-x\-\-\-\-\-\-\-\-xooooooooooooooooo\-\-\-\-\-\-\-\-x\-\-\-\-\-\-\-\-x\-\-\-
              |<\- comp. time \->|
     |<\-\-\-\-\-\-\- относительный предельный срок \-\-\-\-\-\->|
     |<\-\-\-\-\-\-\-\-\-\-\-\-\-\- промежуток времени \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->|
.EE
.in
.PP
При назначении нити алгоритма \fBSCHED_DEADLINE\fP с помощью
\fBsched_setattr\fP(2) можно указать три параметра: \fIRuntime\fP, \fIDeadline\fP и
\fIPeriod\fP. Эти параметры не обязательно соответствуют вышеупомянутым
терминам: на практике, Runtime задаётся чуть больше чем среднее время
вычисления (или время вычисления в самом плохом варианте для задач жёсткого
реального времени), Deadline равен относительному предельному сроку, а
Period равен промежутку времени. Таким образом, при планировании
\fBSCHED_DEADLINE\fP мы имеем:
.PP
.in +4n
.EX
принятие/пробуждение                    абсолютный предельный срок
     |    время начала                  |
     |        |                         |
     v        v                         v
\-\-\-\-\-x\-\-\-\-\-\-\-\-xooooooooooooooooo\-\-\-\-\-\-\-\-x\-\-\-\-\-\-\-\-x\-\-\-
              |<\-\- Runtime \-\-\-\-\-\-\->|
     |<\-\-\-\-\-\-\-\-\-\-\- Deadline \-\-\-\-\-\-\-\-\-\-\->|
     |<\-\-\-\-\-\-\-\-\-\-\-\-\-\- Period \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->|
.EE
.in
.PP
.\" FIXME It looks as though specifying sched_period as 0 means
.\" "make sched_period the same as sched_deadline".
.\" This needs to be documented.
Три параметра алгоритма с крайним сроком соответствуют полям
\fIsched_runtime\fP, \fIsched_deadline\fP и \fIsched_period\fP структуры
\fIsched_attr\fP; смотрите \fBsched_setattr\fP(2). Значения этих полей задаются в
наносекундах. Если \fIsched_period\fP равно 0, то его значение равно
\fIsched_deadline\fP.
.PP
Для ядра требуется соблюдение условия:
.PP
    sched_runtime <= sched_deadline <= sched_period
.PP
.\" See __checkparam_dl in kernel/sched/core.c
Также, в текущей реализации, значения всех параметров должны быть не менее
1024 (т. е., чуть более одной микросекунды, ограничено в реализации) и
меньше 2^63. При нарушении ограничений \fBsched_setattr\fP(2) завершается с
ошибкой \fBEINVAL\fP.
.PP
CBS гарантирует отсутствие влияния задача друг на друга, регулируя
(throttling) нити, которые пытаются превысить заданное им время выполнения
(Runtime).
.PP
Чтобы гарантировать выполнение алгоритма планирования крайнего срока, ядро
должно предотвращать ситуации, где установка \fBSCHED_DEADLINE\fP нитям не
выполнима (не может быть запланирована) для указанных ограничений. Для этого
ядро выполняет тест допустимости при назначении или изменении алгоритма
\fBSCHED_DEADLINE\fP и атрибутов. В данном тесте вычисляется, выполнимы ли
изменения; если нет, то \fBsched_setattr\fP(2) завершается с ошибкой \fBEBUSY\fP.
.PP
Например, для этого требуется (но не обязательно достаточно), чтобы общая
загруженность была меньше или равной общему количеству доступных ЦП, так как
каждая нить максимально может работать весь промежуток времени, то есть
загруженность нити равна её Runtime, поделённый на Period.
.PP
Чтобы удовлетворить гарантиям, которые даются, когда нити назначен алгоритм
\fBSCHED_DEADLINE\fP, нити с \fBSCHED_DEADLINE\fP имеют наивысший приоритет
(управляется пользователем) по сравнению с другими нитями в системе; если
нить с \fBSCHED_DEADLINE\fP запускается, то она вытеснит любую нить,
запланированную любым другим алгоритмом.
.PP
Вызов \fBfork\fP(2) в нити, запланированной \fBSCHED_DEADLINE\fP завершается
ошибкой \fBEAGAIN\fP, если у нити не установлен флаг reset\-on\-fork (смотрите
далее).
.PP
.\"
.\" FIXME Calling sched_getparam() on a SCHED_DEADLINE thread
.\" fails with EINVAL, but sched_getscheduler() succeeds.
.\" Is that intended? (Why?)
.\"
Нить с \fBSCHED_DEADLINE\fP, вызывающая \fBsched_yield\fP(2) приостановит текущее
задание и будет ждать начала нового промежутка времени.
.SS "SCHED_OTHER: планирование с разделение времени (по умолчанию в Linux)"
\fBSCHED_OTHER\fP можно использовать только с статическим приоритетом 0 (то
есть, нити, работающие по алгоритму реального времени, всегда имеют
приоритет над процессами с \fBSCHED_OTHER\fP). \fBSCHED_OTHER\fP — это стандартный
планировщик Linux с разделением времени, предназначенный для всех нитей, не
требующих специальных механизмов реального времени.
.PP
Для выполнения выбирается нить из списка со статическим приоритетом 0 на
основе \fIдинамического\fP приоритета, существующего только внутри этого
списка. Динамический приоритет основан на значении уступчивости (смотрите
ниже) и увеличивается с каждым квантом времени, при котором нить была готова
к работе, но ей было отказано в этом планировщиком. Таким образом время
равномерно распределяется между всеми нитями с алгоритмом \fBSCHED_OTHER\fP.
.PP
.\"
В дереве исходного кода ядра Linux алгоритм \fBSCHED_OTHER\fP на самом деле
называется \fBSCHED_NORMAL\fP.
.SS "Значение уступчивости"
Значение уступчивости — это атрибут, который можно использовать для влияния
на планировщик ЦП с целью сделать процесс более популярным (или наоборот)
при принятии решений о планировании выполнения. Он учитывается при
планировании процессов с \fBSCHED_OTHER\fP и \fBSCHED_BATCH\fP (смотрите
ниже). Значение уступчивости можно изменять с помощью \fBnice\fP(2),
\fBsetpriority\fP(2) или \fBsched_setattr\fP(2).
.PP
Согласно POSIX.1, значение уступчивости является атрибутом процесса; то есть
нити процесса должны иметь одинаковое значение уступчивости. Однако в Linux
значение уступчивости является атрибутом нити: разные нити одного процесса
могут иметь разные значения уступчивости.
.PP
.\" Linux before 1.3.36 had \-infinity..15.
.\" Since kernel 1.3.43, Linux has the range \-20..19.
Диапазон значений уступчивости различается в разных системах UNIX. В
современном Linux диапазон: \-20 (высокий приоритет) по +19 (низкий
приоритет). В других системах диапазон равен \-20..20. В самых первых версиях
ядра Linux (до Linux 2.0) диапазон равнялся \-бесконечность..15.
.PP
Степень влияния значения уступчивости на процессы с подобным \fBSCHED_OTHER\fP
в разных системах UNIX различна и не одинакова даже между версиями ядра
Linux.
.PP
С появлением планировщика CFS в ядре 2.6.23, в Linux стал применяться
алгоритм, учитывающий относительную разницу значений уступчивости более
полно. В текущей реализации каждое различие на единицу между значениями
уступчивости двух процессов приводит к умножению приоритета на 1.25, с
которым планировщик отдаёт предпочтение процессу с более высоким
приоритетом. Это приводит к тому, что самые низкие значения уступчивости
(+19) действительно получают очень мало времени ЦП независимо от того, есть
ли высокая загрузка системы, и по высоким значениям уступчивости (\-20)
даётся больше времени на ЦП приложениям, которым это нужно (например,
некоторым аудиоприложениям).
.PP
Для задания ограничения, до которого можно повышать значение уступчивости
непривилегированному процессу, в используется Linux ограничение ресурса
\fBRLIMIT_NICE\fP; смотрите \fBsetrlimit\fP(2).
.PP
.\"
Дополнительную информацию о значении уступчивости смотрите подразделы
свойств автогруппировки и группового планирования ниже.
.SS "SCHED_BATCH: планирование для пакетных процессов"
(начиная с Linux 2.6.16) \fBSCHED_BATCH\fP можно использовать только с
статическим приоритетом равным нулю. Этот алгоритм похож на \fBSCHED_OTHER\fP в
том, что он планирует выполнение нити на основе её динамического приоритета
(на основе значения nice). Различие в том, что в этом алгоритме планировщик
всегда предполагает, что нить, в основном, использует ЦП. Следовательно,
планировщик немного понизит вероятность её следующего пробуждения для того,
чтобы эта нить уступила другим при планировании.
.PP
.\" The following paragraph is drawn largely from the text that
.\" accompanied Ingo Molnar's patch for the implementation of
.\" SCHED_BATCH.
.\" commit b0a9499c3dd50d333e2aedb7e894873c58da3785
.\"
Этот алгоритм полезен при нагрузках не интерактивными задачами, но когда
нежелательно понижать их значение nice и для задач, которым требуется
предсказуемый алгоритм планирования без интерактивности, который приводит к
дополнительным вытеснениям (между задачами нагрузки).
.SS "SCHED_IDLE: планирование заданий с очень низким приоритетом"
(начиная с Linux 2.6.23)  \fBSCHED_IDLE\fP можно использовать только с
статическим приоритетом равным нулю; значение nice не учитывает в этом
алгоритме.
.PP
.\"
Данный алгоритм предназначен для выполнения заданий с чрезвычайно низким
приоритетом (даже ниже чем значение nice +19 в алгоритме \fBSCHED_OTHER\fP или
\fBSCHED_BATCH\fP).
.SS "Сброс алгоритма планирования у дочерних процессов"
В каждой нити есть флаг планирования reset\-on\-fork. Когда этот флаг
установлен, потомки, создаваемые \fBfork\fP(2), не наследуют привилегированные
алгоритмы планирования. Флаг reset\-on\-fork может быть задан так:
.IP * 3
Логическим сложением флага \fBSCHED_RESET_ON_FORK\fP с аргументом \fIpolicy\fP при
вызове \fBsched_setscheduler\fP(2) (начиная с Linux 2.6.32); или
.IP *
заданием флага \fBSCHED_FLAG_RESET_ON_FORK\fP в \fIattr.sched_flags\fP при вызове
\fBsched_setattr\fP(2).
.PP
Заметим, что константы, используемые в этих двух вызовам имеют разные
имена. Состояние флага reset\-on\-fork может быть получено аналогичным образом
с помощью \fBsched_getscheduler\fP(2) и \fBsched_getattr\fP(2).
.PP
Возможность reset\-on\-fork предназначена для приложений, проигрывающих
медиа\-файлы, и может использоваться для обхождения ограничения ресурса
\fBRLIMIT_RTTIME\fP (см. \fBgetrlimit\fP(2)), посредством создания нескольких
дочерних процессов.
.PP
Точнее говоря, если указан флаг reset\-on\-fork, то к новым потомкам
применяются следующие правила:
.IP * 3
Если вызывающая нить имеет алгоритм планирования \fBSCHED_FIFO\fP или
\fBSCHED_RR\fP, то у потомков алгоритм сбрасывается в \fBSCHED_OTHER\fP.
.IP *
Если у вызывающего процесса значение nice отрицательно, то у потомков
значение nice сбрасывается в ноль.
.PP
.\"
После установки флага reset\-on\-fork его можно сбросить только, если нить
имеет мандат \fBCAP_SYS_NICE\fP. Этот флаг выключается у потомков, созданных
через \fBfork\fP(2).
.SS "Привилегии и ограничения по ресурсам"
В ядрах Linux до версии 2.6.12, только привилегированные нити
(\fBCAP_SYS_NICE\fP) могли устанавливать ненулевое значение статического
приоритета (т.е. алгоритм планирования реального
времени). Непривилегированные нити могли только установить алгоритм
\fBSCHED_OTHER\fP, и это могло быть сделано только, если эффективный
пользовательский идентификатор вызывающего совпадал с реальным или
эффективным пользовательским идентификатором задаваемого нити (т.е., нити,
указываемой в \fIpid\fP).
.PP
Для задания или изменения \fBSCHED_DEADLINE\fP нить должна быть
привилегированной (\fBCAP_SYS_NICE\fP).
.PP
Начиная с Linux 2.6.12, ограничитель ресурса \fBRLIMIT_RTPRIO\fP определяет
максимум статического приоритета непривилегированной нити для алгоритмов
\fBSCHED_RR\fP и \fBSCHED_FIFO\fP. Правила для изменения алгоритма планирования и
приоритета:
.IP * 3
Если непривилегированная нить имеет ненулевое значение мягкого ограничения
\fBRLIMIT_RTPRIO\fP, то она может изменять свой алгоритм планирования и
приоритет, но при этом значение приоритета не может быть больше чем
максимальное значение её текущего приоритета и его мягкого ограничения
\fBRLIMIT_RTPRIO\fP.
.IP *
Если мягкое ограничение \fBRLIMIT_RTPRIO\fP равно 0, то разрешается только
снижать приоритет или переключиться на алгоритм выполнения не реального
времени.
.IP *
Согласно тем же самым правилам другая непривилегированная нить может также
сделать эти изменения, пока эффективный идентификатор пользователя нити,
производящей изменение, совпадает с реальным или эффективным идентификатором
пользователя изменяемой нити.
.IP *
.\" commit c02aa73b1d18e43cfd79c2f193b225e84ca497c8
Для политики \fBSCHED_IDLE\fP применяются специальные правила. В ядрах Linux до
версии 2.6.39, сменить политику работы непривилегированной нити нельзя,
независимо от значения её ограничителя ресурсов \fBRLIMIT_RTPRIO\fP. В ядрах
Linux начиная с версии 2.6.39, непривилегированная нить может переключиться
на политику \fBSCHED_BATCH\fP или \fBSCHED_OTHER\fP, если её значение уступчивости
находится в диапазоне, разрешённом ей ограничителем ресурсов \fBRLIMIT_NICE\fP
(см. \fBgetrlimit\fP(2)).
.PP
Для привилегированных (\fBCAP_SYS_NICE\fP) нитей ограничение \fBRLIMIT_RTPRIO\fP
игнорируется; как в старых ядрах, они могут произвольно менять алгоритм
планирования и приоритет. Подробней смотрите в \fBgetrlimit\fP(2) про
\fBRLIMIT_RTPRIO\fP.
.SS "Ограничение использование ЦП процессами реального времени и процессами с крайним сроком"
Неблокирующий бесконечный цикл в нити, запланированной алгоритмами
\fBSCHED_FIFO\fP, \fBSCHED_RR\fP или \fBSCHED_DEADLINE\fP потенциально может привести
к вечному блокированию остальных нитей. До Linux 2.6.25 был только один
способ предотвращения заморозки системы бесконтрольными процессами реального
времени — запуск (с консоли) оболочки с наивысшим статическим приоритетом,
большим чем тестируемое приложение. Это позволяло экстренно прибить
тестируемое приложение реального времени, которое не блокируется или
завершается как положено.
.PP
Начиная с Linux 2.6.25, есть другие способы работы с процессами реального
времени и процессами с крайним сроком. Один из них — использовать
ограничитель ресурса \fBRLIMIT_RTTIME\fP, задав потолок времени ЦП, которое
процесс реального времени может задействовать. Подробней смотрите в
\fBgetrlimit\fP(2).
.PP
Начиная с версии 2.6.25, в Linux также предоставляется два файла в \fI/proc\fP,
которые можно использовать для резервирования определённого количества
времени ЦП, используемое процессами нереального времени. Резервирование
некоторого количества ЦП подобным образом позволяет оставить время на том же
ЦП (скажем) оболочке root, через которую можно завершить неконтролируемый
процесс. В этих файлах значение времени указывается в микросекундах:
.TP 
\fI/proc/sys/kernel/sched_rt_period_us\fP
В данном файле задаётся планируемый промежуток времени, который равен 100%
полосы ЦП. Значение в этом файле может лежать в диапазоне от 1 до
\fBINT_MAX\fP, что даёт рабочий диапазон от 1 микросекунды до, приблизительно,
35 минут. Значение в файле по умолчанию равно 1000000 (1 секунда).
.TP 
\fI/proc/sys/kernel/sched_rt_runtime_us\fP
Значением в этом файле определяется насколько большой промежуток времени
может использоваться всеми процессами реального времени и процессами с
крайним сроком в системе. Диапазон значений: от \-1 до \fBINT_MAX\fP\-1. Значение
\-1 означает, что время выполнения равно промежутку времени; то есть нет
времени ЦП для приложений нереального времени (что соответствует поведению
Linux до версии ядра 2.6.25). Значение по умолчанию равно 950000 (0.95
секунды), означающее, что 5% времени ЦП зарезервировано для процессов,
планирование которых выполняется не по алгоритму реального времени или
алгоритму с крайним сроком.
.PP
.SS "Время ответа"
.\" as described in
.\" .BR request_irq (9).
Блокированная нить с высоким приоритетом, ожидающая ввода/вывода,
освобождает достаточно много процессорного времени до того, как снова начнёт
работать. Авторы драйверов устройств могут более эффективно использовать это
время, если воспользуются «медленным» обработчиком прерываний.
.SS Разное
Дочерние процессы наследуют алгоритм планирования и его параметры после
\fBfork\fP(2). Алгоритм планирования и параметры сохраняются при вызове
\fBexecve\fP(2).
.PP
.\"
Обычно, процессам реального времени необходимо блокировать память для того,
чтобы избежать задержек при страничном обмене. Это можно сделать при помощи
вызова \fBmlock\fP(2) или \fBmlockall\fP(2).
.SS "Свойство автогруппировки"
.\" commit 5091faa449ee0b7d73bc296a93bca9540fc51d0a
Начиная с Linux 2.6.38 в ядре появилось свойство, называемое
автогруппировкой; оно улучшает интерактивность рабочего окружения несмотря
на многопроцессную интенсивную нагрузку ЦП, такую как сборка ядра Linux
большим количеством параллельно собирающих процессов (т. е., командой
\fBmake\fP(1) с флагом \fB\-j\fP).
.PP
Данное свойств работает совместно с планировщиком CFS, и ядро должно быть
собрано с параметром \fBCONFIG_SCHED_AUTOGROUP\fP. В работающей системе
свойство можно включать и выключать через файл
\fI/proc/sys/kernel/sched_autogroup_enabled\fP; значение 0 выключает свойство,
а 1 — включает. Значение по умолчанию равно 1, если ядро не загружалось с
параметром \fInoautogroup\fP.
.PP
Новая автогруппа создаётся при создании нового сеанса с помощью
\fBsetsid\fP(2); например, это происходит при запуске нового окна
терминала. Новый процесс, созданный \fBfork\fP(2), наследует членство в
автогруппе родителя. Таким образом, все процессы в сеансе являются членами
одной автогруппы. Автогруппа автоматически уничтожается при завершении
последнего процесса в группе.
.PP
При включенной автогруппировке все члены автогруппы помещаются в в одну
«группу задач» планировщика ядра. Планировщик CFS использует алгоритм,
который уравнивает раздачу циклов ЦП между задачами группы. Преимущество
такого подхода заключается в улучшении интерактивности рабочего стола,
которую можно описать следующим примером.
.PP
.\" Mike Galbraith, 25 Nov 2016:
.\"     I'd say something more wishy-washy here, like cycles are
.\"     distributed fairly across groups and leave it at that, as your
.\"     detailed example is incorrect due to SMP fairness (which I don't
.\"     like much because [very unlikely] worst case scenario
.\"     renders a box sized group incapable of utilizing more that
.\"     a single CPU total).  For example, if a group of NR_CPUS
.\"     size competes with a singleton, load balancing will try to give
.\"     the singleton a full CPU of its very own.  If groups intersect for
.\"     whatever reason on say my quad lappy, distribution is 80/20 in
.\"     favor of the singleton.
Предположим, что есть две автогруппы, выполняющиеся на одном ЦП (т. е.,
используется система с одним ЦП или с помощью \fBtaskset\fP(1) все процессы
вытеснены на один ЦП в многопроцессорной системе). Первая группа содержит 10
привязанных к ЦП процессов, запущенных для сборки ядра \fImake\ \-j10\fP. Вторая
группа содержит один привязанный к ЦП процесс: видеопроигрыватель. Из\-за
автогруппировки в том, что каждая из групп получит половину циклов ЦП. То
есть, видеопроигрыватель получит 50% циклов ЦП, а не 9% циклов, что,
вероятно, привело бы к ухудшению воспроизведения. Ситуация в
многопроцессорных системах несколько сложнее, но результат тот же самый:
планировщик распределит циклы ЦП между группами задач и автогруппа с большим
количеством привязанных к ЦП процессов не истратит все циклы ЦП с ущербом
других задач, выполняемых системой.
.PP
Членство автогруппы процесса (группу задач) можно увидеть через файл
\fI/proc/[pid]/autogroup\fP:
.PP
.in +4n
.EX
$ \fBcat /proc/1/autogroup\fP
/autogroup\-1 nice 0
.EE
.in
.PP
.\" FIXME .
.\" Because of a bug introduced in Linux 4.7
.\" (commit 2159197d66770ec01f75c93fb11dc66df81fd45b made changes
.\" that exposed the fact that autogroup didn't call scale_load()),
.\" it happened that *all* values in this range caused a task group
.\" to be further disfavored by the scheduler, with \-20 resulting
.\" in the scheduler mildly disfavoring the task group and +19 greatly
.\" disfavoring it.
.\"
.\" A patch was posted on 23 Nov 2016
.\" ("sched/autogroup: Fix 64bit kernel nice adjustment";
.\" check later to see in which kernel version it lands.
Также этот файл можно использовать для изменения полосы пропускания ЦП,
выделенной автогруппе. Для этого в файл записывается диапазон
«уступчивости», задающий значение уступчивости автогруппы. Допускаемый
диапазон: от +19 (низкий приоритет) до \-20 (высокий приоритет) (запись через
\fBwrite\fP(2) значений вне это диапазона приводит к ошибке \fBEINVAL\fP).
.PP
Значение уступчивости автогруппы означает тоже самое что и значение
уступчивости процесса, но распространяется на циклы ЦП автогруппы в целом,
основываясь на относительных значениях уступчивости других автогрупп. Для
процесса внутри автогруппы количество циклов ЦП, которые он получит, равно
произведению значения уступчивости автогруппы (по сравнению с другими
автогруппами) и значению уступчивости процесса (по сравнению с другими
процессам в той же автогруппе).
.PP
Использование контроллера ЦП \fBcgroups\fP(7) для размещения процессов в cgroup
не равную корневой cgroup ЦП, отменяет эффект автогруппировки.
.PP
.\"
Свойство автогруппировки группирует только процессы, планируемые алгоритмами
не реального времени (\fBSCHED_OTHER\fP, \fBSCHED_BATCH\fP и \fBSCHED_IDLE\fP). Оно
не группирует процессы, планируемые алгоритмами реального времени и с
предельным сроком (deadline). Такие процессы планируются согласно правилам,
описанным ранее.
.SS "Значение уступчивости и групповое планирование"
При планировании процессов не реального времени (т. е., планируемых по
алгоритмам \fBSCHED_OTHER\fP, \fBSCHED_BATCH\fP и \fBSCHED_IDLE\fP), планировщик CFS
использует технику называемую «групповое планирование», если ядро было
собрано с параметром \fBCONFIG_FAIR_GROUP_SCHED\fP (обычно так и есть).
.PP
При групповом планировании нити планируются по «группам задач». Группы задач
имеют иерархические связи, берущие начало от начальной группы задач системы,
называемой «корневая группа задач». Группы задач формируются согласно
следующему:
.IP * 3
Все нити в cgroup ЦП образуют группу задач. Родитель этой группы задач
является группой задач соответствующей родительской cgroup.
.IP *
Если автогруппировка разрешена, то все нити, помещённые (неявно) в
автогруппу (т. е., одного сеанса, созданного \fBsetsid\fP(2)), образуют группу
задач. Таким образом, каждая новая автогруппа является отдельной группой
задач. Корневая группа задач является родителем всех этих автогрупп.
.IP *
Если автогруппировка разрешена, то корневая группа задач состоит из всех
процессов в корневой cgroup ЦП, которые не были неявно помещены в новую
автогруппу.
.IP *
Если автогруппировка запрещена, то корневая группа задач состоит из всех
процессов в корневой cgroup ЦП.
.IP *
Если групповое планирование было запрещено (т. е., ядро собрано без
параметра \fBCONFIG_FAIR_GROUP_SCHED\fP), то все процессы системы условно
помещаются в одну группу задач.
.PP
При групповом планировании значение уступчивости нити влияет на решение о
планировании \fIтолько относительно других нитей в той же группе задач\fP. Это
слегка удивляет с точки зрения обычной семантики значения уступчивости в
системах UNIX. В частности, если автогруппировка разрешена (по умолчанию во
многих дистрибутивах), то применение к процессу  \fBsetpriority\fP(2) или
\fBnice\fP(1) подействует только на планирование относительно других процессов,
выполняющихся в том же сеансе (обычно, в том же окне терминала).
.PP
.\" More succinctly: the nice(1) command is in many cases a no-op since
.\" Linux 2.6.38.
.\"
И наоборот, для двух процессов, которые (например) являются единственными
привязанными к ЦП процессами в в разных сеансах (например, различные окна
терминалов, в каждом задачи составляют разные автогруппы), \fIизменение
значения уступчивости процесса в одном из сеансов\fP \fIне повлияет\fP на
принятие решения планировщиком относительно процесса в другом
сеансе. Возможно, здесь полезным обходным решением будет использовать
команду, изменяющую значение уступчивости автогруппы \fIвсех\fP процессов в
сеансе терминала:
.PP
.in +4n
.EX
$ \fBecho 10 > /proc/self/autogroup\fP
.EE
.in
.SS "Возможности выполнения в реальном времени из оригинальной версии Linux"
.\" FIXME . Probably this text will need some minor tweaking
.\" ask Carsten Emde about this.
Начиная с версии ядра 2.6.18, Linux постепенно обрастает возможностями
выполнения в реальном времени, большая часть которых взята из раннего набора
заплат \fIrealtime\-preempt\fP. Пока заплатки не были полностью включены в
основное ядро, их нужно было устанавливать отдельно. Файлы заплаток
называются:
.PP
.in +4n
.EX
patch\-\fIверсия_ядра\fP\-rt\fIверсия_заплатки\fP
.EE
.in
.PP
и могут быть скачаны с
.UR http://www.kernel.org\:/pub\:/linux\:/kernel\:/projects\:/rt/
.UE .
.PP
Без заплаток и до их полного включения в оригинальное ядро, через параметры
ядра предлагается только три класса вытеснения: \fBCONFIG_PREEMPT_NONE\fP,
\fBCONFIG_PREEMPT_VOLUNTARY\fP и \fBCONFIG_PREEMPT_DESKTOP\fP, которые,
соответственно, не сокращают, частично сокращают и значительно сокращают
задержку планирования при наихудшем случае.
.PP
С заплатками и после их полного включения в оригинальное ядро, в параметрах
ядра появится новый пункт \fBCONFIG_PREEMPT_RT\fP. Если он будет выбран, то
Linux преобразуется в обычную операционную систему реального времени. После
этого для выполнения нити с настоящим приоритетом реального времени и
минимальной задержкой планирования в наихудшем случае используются алгоритмы
планирования FIFO и RR.
.SH ЗАМЕЧАНИЯ
Для ограничения групп процессов потребления ЦП можно использовать контроллер
ЦП \fBcgroups\fP(7).
.PP
Изначально стандартный Linux представлял собой операционную систему общего
назначения для выполнения как фоновых процессов, так и интерактивных
приложений, а также нетребовательных приложений реального времени
(приложений, которым желательно, чтобы задержки и интервалы времени
выдерживались). Хотя ядро Linux 2.6 позволяет вытеснение и новый планировщик
O(1) обеспечивает необходимое постоянство планирования и предсказуемое
независимое количество активных задач, настоящая работа в реальном времени
стала доступна начиная с версии ядра 2.6.17.
.SH "СМОТРИТЕ ТАКЖЕ"
.ad l
.nh
\fBchcpu\fP(1), \fBchrt\fP(1), \fBlscpu\fP(1), \fBps\fP(1), \fBtaskset\fP(1), \fBtop\fP(1),
\fBgetpriority\fP(2), \fBmlock\fP(2), \fBmlockall\fP(2), \fBmunlock\fP(2),
\fBmunlockall\fP(2), \fBnice\fP(2), \fBsched_get_priority_max\fP(2),
\fBsched_get_priority_min\fP(2), \fBsched_getaffinity\fP(2), \fBsched_getparam\fP(2),
\fBsched_getscheduler\fP(2), \fBsched_rr_get_interval\fP(2),
\fBsched_setaffinity\fP(2), \fBsched_setparam\fP(2), \fBsched_setscheduler\fP(2),
\fBsched_yield\fP(2), \fBsetpriority\fP(2), \fBpthread_getaffinity_np\fP(3),
\fBpthread_getschedparam\fP(3), \fBpthread_setaffinity_np\fP(3),
\fBsched_getcpu\fP(3), \fBcapabilities\fP(7), \fBcpuset\fP(7)
.ad
.PP
\fIProgramming for the real world \- POSIX.4\fP by Bill O.\& Gallmeister,
O'Reilly & Associates, Inc., ISBN 1\-56592\-074\-0.
.PP
Исходные файлы ядра Linux \fIDocumentation/scheduler/sched\-deadline.txt\fP,
\fIDocumentation/scheduler/sched\-rt\-group.txt\fP,
\fIDocumentation/scheduler/sched\-design\-CFS.txt\fP и
\fIDocumentation/scheduler/sched\-nice\-design.txt\fP
