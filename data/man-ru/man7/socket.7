.\" -*- mode: troff; coding: UTF-8 -*-
'\" t
.\" This man page is Copyright (C) 1999 Andi Kleen <ak@muc.de>.
.\" and copyright (c) 1999 Matthew Wilcox.
.\"
.\" %%%LICENSE_START(VERBATIM_ONE_PARA)
.\" Permission is granted to distribute possibly modified copies
.\" of this page provided the header is included verbatim,
.\" and in case of nontrivial modification author and date
.\" of the modification is added to the header.
.\" %%%LICENSE_END
.\"
.\" 2002-10-30, Michael Kerrisk, <mtk.manpages@gmail.com>
.\"	Added description of SO_ACCEPTCONN
.\" 2004-05-20, aeb, added SO_RCVTIMEO/SO_SNDTIMEO text.
.\" Modified, 27 May 2004, Michael Kerrisk <mtk.manpages@gmail.com>
.\"     Added notes on capability requirements
.\"	A few small grammar fixes
.\" 2010-06-13 Jan Engelhardt <jengelh@medozas.de>
.\"	Documented SO_DOMAIN and SO_PROTOCOL.
.\"
.\" FIXME
.\" The following are not yet documented:
.\"
.\" SO_PEERNAME (2.4?)
.\"	get only
.\"	Seems to do something similar to getpeername(), but then
.\"	why is it necessary / how does it differ?
.\"
.\" SO_TIMESTAMPNS (2.6.22)
.\"	Documentation/networking/timestamping.txt
.\"	commit 92f37fd2ee805aa77925c1e64fd56088b46094fc
.\"	Author: Eric Dumazet <dada1@cosmosbay.com>
.\"
.\" SO_TIMESTAMPING (2.6.30)
.\"	Documentation/networking/timestamping.txt
.\"	commit cb9eff097831007afb30d64373f29d99825d0068
.\"	Author: Patrick Ohly <patrick.ohly@intel.com>
.\"
.\"  SO_WIFI_STATUS (3.3)
.\"	commit 6e3e939f3b1bf8534b32ad09ff199d88800835a0
.\"	Author: Johannes Berg <johannes.berg@intel.com>
.\"	Also: SCM_WIFI_STATUS
.\"
.\" SO_NOFCS (3.4)
.\"	commit 3bdc0eba0b8b47797f4a76e377dd8360f317450f
.\"	Author: Ben Greear <greearb@candelatech.com>
.\"
.\"  SO_GET_FILTER (3.8)
.\"	commit a8fc92778080c845eaadc369a0ecf5699a03bef0
.\"	Author: Pavel Emelyanov <xemul@parallels.com>
.\"
.\" SO_SELECT_ERR_QUEUE (3.10)
.\"	commit 7d4c04fc170087119727119074e72445f2bb192b
.\"	Author: Keller, Jacob E <jacob.e.keller@intel.com>
.\"
.\" SO_MAX_PACING_RATE (3.13)
.\"	commit 62748f32d501f5d3712a7c372bbb92abc7c62bc7
.\"	Author: Eric Dumazet <edumazet@google.com>
.\"
.\" SO_BPF_EXTENSIONS (3.14)
.\"	commit ea02f9411d9faa3553ed09ce0ec9f00ceae9885e
.\"	Author: Michal Sekletar <msekleta@redhat.com>
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH SOCKET 7 2019\-08\-02 Linux "Руководство программиста Linux"
.SH ИМЯ
socket \- интерфейс сокетов Linux
.SH ОБЗОР
\fB#include <sys/socket.h>\fP
.PP
\fIsockfd\fP\fB = socket(int \fP\fIsocket_family\fP\fB, int \fP\fIsocket_type\fP\fB, int
\fP\fIprotocol\fP\fB);\fP
.SH ОПИСАНИЕ
В этой справочной странице описывается пользовательский интерфейс уровня
сетевых сокетов Linux. Совместимый с сокетами BSD, он предоставляет
унифицированный интерфейс между пользовательскими процессами и стеком
сетевых протоколов в ядре. Модули протоколов группируются по \fIсемействам
протоколов\fP, такими, как \fBAF_INET\fP, \fBAF_IPX\fP и \fBAF_PACKET\fP, и \fIтипам
сокетов\fP, такими, как \fBSOCK_STREAM\fP или \fBSOCK_DGRAM\fP. Более подробная
информация о семействах и типах приведена в \fBsocket\fP(2).
.SS "Функции уровня сокетов"
Эти функции используются пользовательскими процессами для отправки или
приёма пакетов и выполнения других операций над сокетами. Более подробная
информация приведена в соответствующих справочных страницах.
.PP
Вызов \fBsocket\fP(2) создаёт сокет, \fBconnect\fP(2) соединяет сокет с удалённым
сокетным адресом, \fBbind\fP(2) привязывает сокет к локальному адресу,
\fBlisten\fP(2) сообщает сокету, что должны приниматься новые соединения, а
\fBaccept\fP(2) используется для получения нового сокета для нового входящего
соединения. Вызов \fBsocketpair\fP(2) возвращает два соединённых анонимных
сокета (реализовано только для некоторых локальных семейств, например
\fBAF_UNIX\fP).
.PP
Вызовы \fBsend\fP(2), \fBsendto\fP(2) и \fBsendmsg\fP(2) отправляют данные в сокет, а
\fBrecv\fP(2), \fBrecvfrom\fP(2) и \fBrecvmsg\fP(2) принимают данные из
сокета. Вызовы \fBpoll\fP(2) и \fBselect\fP(2) ожидают поступления данных или
готовятся к передаче данных. Кроме того, для чтения и записи данных могут
использоваться стандартные операции ввода\-вывода: \fBwrite\fP(2), \fBwritev\fP(2),
\fBsendfile\fP(2), \fBread\fP(2) и \fBreadv\fP(2).
.PP
Вызов \fBgetsockname\fP(2) возвращает адрес локального сокета, а
\fBgetpeername\fP(2) возвращает адрес удалённого сокета. Вызовы
\fBgetsockopt\fP(2) и \fBsetsockopt\fP(2) используются для установки или
считывания параметров протокола или уровня сокетов. Вызов \fBioctl\fP(2) может
быть использован для установки или чтения некоторых других параметров.
.PP
Вызов \fBclose\fP(2) используется для закрытия сокета. Вызов \fBshutdown\fP(2)
закрывает части полнодуплексного сокетного соединения.
.PP
Перемещение (seeking), или вызовы \fBpread\fP(2) и \fBpwrite\fP(2) с ненулевой
позицией, для сокетов не поддерживается.
.PP
Для сокетов возможно создание неблокирующего ввода/вывода путём установки в
файловый дескриптор сокета флага \fBO_NONBLOCK\fP с помощью вызова
\fBfcntl\fP(2). При этом все блокировавшие раньше операции, будут возвращать
\fBEAGAIN\fP (операция должна быть повторена позднее); \fBconnect\fP(2) возвратит
ошибку \fBEINPROGRESS\fP. Пользователь может подождать наступления различных
событий через \fBpoll\fP(2) или \fBselect\fP(2).
.TS
tab(:) allbox;
c s s
l l l.
События ввода\-вывода
Событие:Флаг poll:Когда происходит
Чтение:POLLIN:T{
Поступили новые данные.
T}
Чтение:POLLIN:T{
Установка соединения выполнена
(для сокетов с установлением соединения)
T}
Чтение:POLLHUP:T{
Другая сторона инициировала запрос на разъединение.
T}
Чтение:POLLHUP:T{
Соединение разорвано (только для протоколов с установлением соединения).
Если производится запись в сокет, то также посылается
сигнал \fBSIGPIPE\fP.
T}
Запись:POLLOUT:T{
Сокет имеет достаточно места в буфере отправки для записи в него новых данных.
T}
Чтение/Запись:T{
POLLIN |
.br
POLLOUT
T}:T{
Исходящий
\fBconnect\fP(2)
завершён.
T}
Чтение/Запись:POLLERR:Произошла асинхронная ошибка.
Чтение/Запись:POLLHUP:Другая сторона закрыла (shut down) одно направление.
Исключение:POLLPRI:T{
Пришли неотложные данные.
После посылается
сигнал \fBSIGURG\fP.
T}
.\" FIXME . The following is not true currently:
.\" It is no I/O event when the connection
.\" is broken from the local end using
.\" .BR shutdown (2)
.\" or
.\" .BR close (2).
.TE
.PP
Альтернативе \fBpoll\fP(2) и \fBselect\fP(2) в ядре существует возможность
информировать приложение о событиях с помощью сигнала \fBSIGIO\fP. Для этого
необходимо установить с помощью \fBfcntl\fP(2) в файловом дескрипторе сокета
флаг \fBO_ASYNC\fP, а также назначить с помощью \fBsigaction\fP(2) корректный
обработчик сигнала \fBSIGIO\fP. Смотрите ниже раздел \fIСигналы\fP.
.SS "Структуры адреса сокета"
Каждый сокетный домен имеет свой формат сокетных адресов, выраженный в
отдельной адресной структуре. Каждая из этих структур начинается с
целочисленного поля «семейства» (с типом \fIsa_family_t\fP), в котором
указывается тип адресной структуры. Это позволяет различным системным
вызовам (например, \fBconnect\fP(2), \fBbind\fP(2), \fBaccept\fP(2),
\fBgetsockname\fP(2), \fBgetpeername\fP(2)), которые являются общими для всех
сокетов, определить домен конкретного сокетного адреса.
.PP
Для передачи сокетного адреса любого типа через программный интерфейс
сокетов служит тип \fIstruct sockaddr\fP. Целью данного типа является
приведение типов сокетных адресов определённого домена к «общему» типу, что
позволяет избежать предупреждений компилятора о несовпадении типов в вызовах
API сокетов.
.PP
Также, программный интерфейс сокетов предоставляет тип данных \fIstruct
sockaddr_storage\fP. Данный тип удобен для размещения всех поддерживаемых
структур сокетных адресов определённого домена; он достаточно большой и
имеет корректное выравнивание (в частности, он позволяет хранить сокетные
адреса IPv6). Для определения типа сокетного адреса, который хранится в
структуре, служит следующее поле:
.PP
.in +4n
.EX
    sa_family_t ss_family;
.EE
.in
.PP
Структура \fIsockaddr_storage\fP полезна для программ, которые должны работать
с сокетными адресами единообразно (например, в программах, использующих
одновременно сокетные адреса IPv4 и IPv6).
.SS "Параметры сокетов"
.\" FIXME .
.\" In the list below, the text used to describe argument types
.\" for each socket option should be more consistent
.\"
.\" SO_ACCEPTCONN is in POSIX.1-2001, and its origin is explained in
.\" W R Stevens, UNPv1
Следующие параметры сокета могут быть установлены с помощью \fBsetsockopt\fP(2)
или прочитаны с помощью \fBgetsockopt\fP(2) с уровнем сокета, равным
\fBSOL_SOCKET\fP для всех сокетов:
.TP 
\fBSO_ACCEPTCONN\fP
Определить, был или не был данный сокет помечен для прослушивания и приёма
соединений с помощью \fBlisten\fP(2). Возвращаемое значение 0 обозначает, что
это не прослушивающий сокет. Значение 1 обозначает, что это прослушивающий
сокет. Данный параметр сокета доступен только для чтения.
.TP 
\fBSO_ATTACH_FILTER\fP (начиная с Linux 2.2), \fBSO_ATTACH_BPF\fP (начиная с Linux 3.19)
Присоединить классическую (\fBSO_ATTACH_FILTER\fP) или расширенную
(\fBSO_ATTACH_BPF\fP) программу BPF к сокету, которая будет использоваться как
фильтр входящих пакетов. Пакет будет отброшен, если фильтрующая программа
возвращает ноль. Если фильтрующая программа возвращает ненулевое значение,
меньше длины данных пакета, то пакет будет обрезан до возвращаемой
длины. Если возвращаемое фильтром значение больше или равно длине данных
пакета, то пакет разрешён к обработке без изменений.
.IP
Для \fBSO_ATTACH_FILTER\fP аргументом является структура \fIsock_fprog\fP,
определяемая в \fI<linux/filter.h>\fP:
.IP
.in +4n
.EX
struct sock_fprog {
    unsigned short      len;
    struct sock_filter *filter;
};
.EE
.in
.IP
Для \fBSO_ATTACH_BPF\fP аргументом является файловый дескриптор, возвращаемый
системным вызовом \fBbpf\fP(2), он должен указывать на программу с типом
\fBBPF_PROG_TYPE_SOCKET_FILTER\fP.
.IP
Эти параметры могут быть назначены заданному сокету несколько раз, если
перед этим заменять фильтрующую программу. Для одного сокета могут
вызываться классическая и расширенная версии, но предыдущий фильтр всегда
будет заменён, так как для сокета допускается определять не более одного
фильтра.
.IP
Классический и расширенный BPF описаны в файле исходного кода ядра
\fIDocumentation/networking/filter.txt\fP.
.TP 
\fBSO_ATTACH_REUSEPORT_CBPF\fP, \fBSO_ATTACH_REUSEPORT_EBPF\fP
При использовании вместе с \fBSO_REUSEPORT\fP эти параметры позволяют
пользователю задавать классическую (\fBSO_ATTACH_REUSEPORT_CBPF\fP) или
расширенную (\fBSO_ATTACH_REUSEPORT_EBPF\fP) программу BPF, которая определяет
как пакеты назначаются сокетам в группе reuseport (то есть всем сокетам, у
которых установлен \fBSO_REUSEPORT\fP, и использующим один локальный адрес для
приёма пакетов).
.IP
Программа BPF должна возвращать индекс от 0 до N\-1, представляющий сокет,
который должен получить пакет (где N — количество сокетов в группе). Если
программа BPF возвращает некорректный индекс, то выбор сокета будет выполнен
с помощью простого механизма \fBSO_REUSEPORT\fP.
.IP
Сокеты нумеруются в порядке их добавления в группу (то есть, в порядке
вызовов \fBbind\fP(2) для сокетов UDP и в порядке вызовов \fBlisten\fP(2) для
сокетов TCP). Новые сокеты, добавляемые в группу reuseport, будут
наследовать программу BPF. Когда сокет удаляется из группы reuseport (с
помощью \fBclose\fP(2)), последний сокет в группе будет перемещён в позицию
закрытого сокета.
.IP
Эти параметры могут быть повторно назначены в любое время любому сокету в
группе для замены текущей программы BPF, используемой всеми сокетами в
группе.
.IP
Для \fBSO_ATTACH_REUSEPORT_CBPF\fP учитывается тот же тип аргумента как у
\fBSO_ATTACH_FILTER\fP, а для \fBSO_ATTACH_REUSEPORT_EBPF\fP учитывается тот же
тип аргумента как у \fBSO_ATTACH_BPF\fP.
.IP
Поддержка этого свойства для UDP доступна начиная с Linux 4.5; Поддержка
этого свойства для TCP доступна начиная с Linux 4.6.
.TP 
\fBSO_BINDTODEVICE\fP
Привязать сокет к определённому устройству, например, к «eth0», в
соответствии с переданным именем интерфейса. Если имя является пустой
строкой или длина параметра равна нулю, то привязка сокета к устройству
будет удалена. В качестве параметра передаётся оканчивающаяся null строка
переменной длины с именем интерфейса, максимальная длина которого не
превышает \fBIFNAMSIZ\fP. Если сокет привязан к интерфейсу, то сокетом
обрабатываются только пакеты этого интерфейса. Заметим, что это работает
только для некоторых типов сокетов, в частности, для сокетов \fBAF_INET\fP. Это
не поддерживается для сокетов пакетной передачи (для них используйте обычный
\fBbind\fP(2)).
.IP
До Linux 3.8, данный параметр сокета можно было устанавливать, но нельзя
прочитать с помощью \fBgetsockopt\fP(2). Начиная с Linux 3.8 он доступен для
чтения. Аргумент \fIoptlen\fP должен содержать размер буфера, способного
разместить имя устройства; рекомендуемое значение — \fBIFNAMSIZ\fP
байт. Реальная длина имени устройства возвращается обратно через аргумент
\fIoptlen\fP.
.TP 
\fBSO_BROADCAST\fP
Задать или считать флаг широковещания. Если он установлен, то через
датаграммные сокеты разрешено отправлять пакеты на широковещательный
адрес. Этот параметр не действует на потоковые сокеты.
.TP 
\fBSO_BSDCOMPAT\fP
Разрешить совместимость по ошибкам с BSD. Используется модулем протокола UDP
в Linux версии 2.0 и 2.2. Если включено, то полученные UDP\-сокетом ошибки
ICMP не будут передаваться пользовательской программе. В последний версиях
ядер поддержка этого параметра удалена: в Linux 2.4 он игнорируется, а в
Linux 2.6 при использовании в программе для него генерируется предупреждение
ядра (printk()). В Linux 2.0 также включён параметр совместимости по ошибкам
с BSD и для неструктурированных сокетов (произвольное изменение заголовка,
пропуск флага широковещательной передачи), но в Linux 2.2 это было удалено.
.TP 
\fBSO_DEBUG\fP
Включить отладку сокета. Разрешено только процессам с мандатом
\fBCAP_NET_ADMIN\fP или имеющим нулевой идентификатор эффективного
пользователя.
.TP 
\fBSO_DETACH_FILTER\fP (начиная с Linux 2.2), \fBSO_DETACH_BPF\fP (начиная с Linux 3.19)
Эти два параметра, синонимы, можно использовать для удаления классической
или расширенной программы BPF, присоединённой к сокету с помощью
\fBSO_ATTACH_FILTER\fP или \fBSO_ATTACH_BPF\fP. Значение параметра игнорируется.
.TP 
\fBSO_DOMAIN\fP (начиная с Linux 2.6.32)
Получить доменный сокет в виде целого числа; пример возвращаемого значения:
\fBAF_INET6\fP. Подробней смотрите в \fBsocket\fP(2). Этот параметр сокета
доступен только для чтения.
.TP 
\fBSO_ERROR\fP
Получить и очистить ожидающую обработки ошибку сокета. Этот параметр сокета
доступен только для чтения. Ожидает целое число.
.TP 
\fBSO_DONTROUTE\fP
Не выполнять отправку через шлюз, посылать только на машины, соединенные
напрямую. Тот же эффект может быть достигнут путём установки для сокета
флага \fBMSG_DONTROUTE\fP во время вызова \fBsend\fP(2). В качестве параметра
ожидается целочисленный логический флаг.
.TP 
\fBSO_INCOMING_CPU\fP (чтение, начиная с Linux 3.19; запись, начиная с Linux 4.4)
.\" getsockopt 2c8c56e15df3d4c2af3d656e44feb18789f75837
.\" setsockopt 70da268b569d32a9fddeea85dc18043de9d89f89
Изменяет или возвращает привязку сокета к ЦП. В качестве параметра ожидается
целочисленный логический флаг.
.IP
.in +4n
.EX
int cpu = 1;
setsockopt(fd, SOL_SOCKET, SO_INCOMING_CPU, &cpu, sizeof(cpu));
.EE
.in
.IP
.\"
.\" From an email conversation with Eric Dumazet:
.\" >> Note that setting the option is not supported if SO_REUSEPORT is used.
.\" >
.\" > Please define "not supported". Does this yield an API diagnostic?
.\" > If so, what is it?
.\" >
.\" >> Socket will be selected from an array, either by a hash or BPF program
.\" >> that has no access to this information.
.\" >
.\" > Sorry -- I'm lost here. How does this comment relate to the proposed
.\" > man page text above?
.\"
.\" Simply that :
.\"
.\" If an application uses both SO_INCOMING_CPU and SO_REUSEPORT, then
.\" SO_REUSEPORT logic, selecting the socket to receive the packet, ignores
.\" SO_INCOMING_CPU setting.
Так как все пакеты одного потока (т. е., все пакеты одной связки 4\-х
значений (4\-tuple)) поступают в одно очередь RX, которая связана с
определённым ЦП, обычно, это используется для привязки слушающего процесса к
очереди RX, чтобы входящий поток, обрабатываемый слушающим, был на том же
ЦП, который обслуживает очередь RX. Это предоставляет оптимальное поведение
NUMA и поддерживает кэши ЦП в актуальном состоянии.
.TP 
\fBSO_KEEPALIVE\fP
Включить отправку «поддерживающих» (keep\-alive) сообщений для сокетов,
ориентированных на соединение. Ожидается целочисленный логический флаг.
.TP 
\fBSO_LINGER\fP
Задать или считать параметр \fBSO_LINGER\fP. Аргументом является структура
\fIlinger\fP.
.IP
.in +4n
.EX
struct linger {
    int l_onoff;    /* задержка активна */
    int l_linger;   /* величина задержки в секундах */
};
.EE
.in
.IP
Если этот параметр установлен, то \fBclose\fP(2) или \fBshutdown\fP(2) не вернут
управление до тех пор, пока не будут отправлены все сообщения в очереди
сокета или до истечения времени задержки (linger). В противном случае вызовы
вернут управление немедленно и закрытие будет произведено в фоновом
режиме. Если сокет закрывается как часть вызова \fBexit\fP(2), то задержка
всегда происходит в фоновом режиме.
.TP 
\fBSO_LOCK_FILTER\fP
.\" commit d59577b6ffd313d0ab3be39cb1ab47e29bdc9182
Если указан, то это запрещает изменять фильтры, связанные с сокетом. К
фильтрам относятся любые, добавленные с помощью параметров сокета
\fBSO_ATTACH_FILTER\fP \fBSO_ATTACH_BPF\fP \fBSO_ATTACH_REUSEPORT_CBPF\fP и
\fBSO_ATTACH_REUSEPORT_EBPF\fP.
.IP
Обычно, он используется так: настраивается неструктурированный сокет
привилегированного процесса (операция требует мандата \fBCAP_NET_RAW\fP),
применяется ограничивающий фильтр, назначается параметр \fBSO_LOCK_FILTER\fP, а
затем сбрасываются привилегии или файловый дескриптор сокета передаётся
непривилегированного процессу через доменный сокет UNIX.
.IP
После установки параметра \fBSO_LOCK_FILTER\fP, все попытки изменить, удалить
присоединённый к сокету фильтр или отключить с помощью параметра
\fBSO_LOCK_FILTER\fP, будут завершаться с ошибкой \fBEPERM\fP.
.TP 
\fBSO_MARK\fP (начиная с Linux 2.6.25)
.\" commit 4a19ec5800fc3bb64e2d87c4d9fdd9e636086fe0
.\" and    914a9ab386a288d0f22252fc268ecbc048cdcbd5
Устанавливать метку на каждый пакет, отправленный через сокет (похоже на
цель netfilter MARK, но для сокетов). Изменение метки можно использовать для
маршрутизации на основе меток не задействуя netfilter или для фильтрации
пакетов. Для установки этого параметра требуется мандат \fBCAP_NET_ADMIN\fP.
.TP 
\fBSO_OOBINLINE\fP
.\" don't document it because it can do too much harm.
.\".B SO_NO_CHECK
.\"     The kernel has support for the SO_NO_CHECK socket
.\"     option (boolean: 0 == default, calculate checksum on xmit,
.\"     1 == do not calculate checksum on xmit).
.\" Additional note from Andi Kleen on SO_NO_CHECK (2010-08-30)
.\"     On Linux UDP checksums are essentially free and there's no reason
.\"     to turn them off and it would disable another safety line.
.\"     That is why I didn't document the option.
Если включён этот параметр, то внепоточные данные помещаются непосредственно
во входной поток данных. В противном случае внепоточные данные передаются
только, если во время приёма установлен флаг \fBMSG_OOB\fP.
.TP 
\fBSO_PASSCRED\fP
Включить или выключить приём управляющего сообщения
\fBSCM_CREDENTIALS\fP. Подробней смотрите в \fBunix\fP(7).
.TP 
\fBSO_PASSSEC\fP
Включить или выключить приём управляющего сообщения
\fBSCM_SECURITY\fP. Подробней смотрите в \fBunix\fP(7).
.TP 
\fBSO_PEEK_OFF\fP (начиная с Linux 3.4)
.\" commit ef64a54f6e558155b4f149bb10666b9e914b6c54
Этот параметр, который пока поддерживается только для сокетов \fBunix\fP(7),
устанавливает значение «смещения выборки» (peek offset) для системного
вызова \fBrecv(2)\fP, когда он используется с флагом \fBMSG_PEEK\fP.
.IP
Если этому параметру присваивается отрицательное значение (равен \-1 для всех
новых сокетов), то действует обычное правило: \fBrecv(2)\fP с флагом
\fBMSG_PEEK\fP выбирает данные из начала (front) очереди.
.IP
Если этому параметру присваивается положительное значение или ноль, то
следующая выборка данных из очереди сокета произойдёт по байтовому смещению,
определяемому значением этого параметра. В то же время, «смещение выборки»
будет увеличено на количество байт, выбранных из очереди, то есть
последовательные операции выборки возвращают следующие данные из очереди.
.IP
Если данные удалены из начала очереди с помощью вызова \fBrecv\fP(2) (или
подобного) без флага \fBMSG_PEEK\fP, то «смещение выборки» будет уменьшено на
количество удалённых байт. Другими словами, приём данных без флага
\fBMSG_PEEK\fP корректирует «смещение выборки»  относительно поддерживаемого
относительного положения данных в очереди, и последующая выборка возвратит
данные, которые были бы получены, если бы данные не удалялись.
.IP
Для датаграммных сокетов, если «смещение выборки» указывает в середину
пакета, то возвращаемые данные маркируются флагом \fBMSG_TRUNC\fP.
.IP
В следующем примере показано использование \fBSO_PEEK_OFF\fP. Предположим, в
очереди потокового сокета есть входные данные:
.IP
    aabbccddeeff
.IP
Следующая последовательность вызовов \fBrecv\fP(2) выполнила бы то, что описано
в комментариях:
.IP
.in +4n
.EX
int ov = 4;        // установка смещения выборки равной 4
setsockopt(fd, SOL_SOCKET, SO_PEEK_OFF, &ov, sizeof(ov));

recv(fd, buf, 2, MSG_PEEK);  // выборка «cc»; смещение 6
recv(fd, buf, 2, MSG_PEEK);  // выборка «dd»; смещение 8
recv(fd, buf, 2, 0);         // выборка «aa»; смещение 6
recv(fd, buf, 2, MSG_PEEK);  // выборка «ee»; смещение 8
.EE
.in
.TP 
\fBSO_PEERCRED\fP
Возвращает учётные данные (credentials) ответного процесса, подключённого к
сокету. Дополнительную информацию смотрите в \fBunix\fP(7).
.TP 
\fBSO_PRIORITY\fP
.\" For
.\" .BR ip (7),
.\" this also sets the IP type-of-service (TOS) field for outgoing packets.
Установить определяемый протоколом приоритет для всех пакетов, отправляемых
из этого сокета. Linux использует это значение для управления сетевыми
очередями: пакеты с более высоким приоритетом могут быть обработаны раньше
(в зависимости от выбранного для устройства способа постановки в
очередь). Установка значения приоритета не из диапазона 0 до 6 требует
мандата \fBCAP_NET_ADMIN\fP.
.TP 
\fBSO_PROTOCOL\fP (начиная с Linux 2.6.32)
Получить протокол сокета в виде целого числа; пример возвращаемого значения:
\fBIPPROTO_SCTP\fP. Подробней смотрите в \fBsocket\fP(2). Этот параметр сокета
доступен только для чтения.
.TP 
\fBSO_RCVBUF\fP
.\" Most (all?) other implementations do not do this -- MTK, Dec 05
.\" The following thread on LMKL is quite informative:
.\" getsockopt/setsockopt with SO_RCVBUF and SO_SNDBUF "non-standard" behavior
.\" 17 July 2012
.\" http://thread.gmane.org/gmane.linux.kernel/1328935
Задать или получить максимальный размер буфера приёма сокета (в
байтах). Ядро удваивает это значение (для пространства под учёт ресурсов
(bookkeeping overhead)) при установке этого параметра с помощью
\fBsetsockopt\fP(2), и это удвоенное значение возвращается
\fBgetsockopt\fP(2). Значение по умолчанию устанавливается через файл
\fI/proc/sys/net/core/rmem_default\fP, а максимальное возможное значение
устанавливается через файл \fI/proc/sys/net/core/rmem_max\fP. Минимальное
(удвоенное) значение для этого параметра равно 256.
.TP 
\fBSO_RCVBUFFORCE\fP (начиная с Linux 2.6.14)
С помощью этого параметра сокета привилегированный (\fBCAP_NET_ADMIN\fP)
процесс может выполнить ту же работу, что и с помощью \fBSO_RCVBUF\fP, но
возможно превысить ограничение \fIrmem_max\fP.
.TP 
\fBSO_RCVLOWAT\fP и \fBSO_SNDLOWAT\fP
Задать минимальное количество байт в буфере до которого уровень сокета будет
отправлять данные протоколу (\fBSO_SNDLOWAT\fP) или получать их от пользователя
(\fBSO_RCVLOWAT\fP). Начальное значение этих двух элементов равно 1. Для
\fBSO_SNDLOWAT\fP значение в Linux изменить нельзя (\fBsetsockopt\fP(2) завершает
выполнение с ошибкой \fBENOPROTOOPT\fP). Значение для \fBSO_RCVLOWAT\fP можно
изменить начиная с Linux версии 2.4.
.IP
.\" commit c7004482e8dcb7c3c72666395cfa98a216a4fb70
.\" See http://marc.theaimsgroup.com/?l=linux-kernel&m=111049368106984&w=2
.\" Tested on kernel 2.6.14 -- mtk, 30 Nov 05
До Linux 2.6.28 \fBselect\fP(2), \fBpoll\fP(2) и \fBepoll\fP(7) не учитывают
настройку \fBSO_RCVLOWAT\fP, и помечают сокет как доступный для чтения даже
когда доступен только 1 байт данных. Последующее чтение из сокета будет
заблокировано до тех пор, пока не будет доступно \fBSO_RCVLOWAT\fP байт.
.TP 
\fBSO_RCVTIMEO\fP и \fBSO_SNDTIMEO\fP
.\" Not implemented in 2.0.
.\" Implemented in 2.1.11 for getsockopt: always return a zero struct.
.\" Implemented in 2.3.41 for setsockopt, and actually used.
.\" in fact to EAGAIN
Задать время ожидания (при отправке или приёме) до генерации сообщения об
ошибке. Аргументом является структура \fIstruct timeval\fP. Если вводящая или
выводящая функция блокируется на этот период времени, и данные был
отправлены или получены, то возвращаемое значение этой функции будет равно
количеству переданных данных; если данные не проходили и время ожидания
истекло, то возвращается \-1 и \fIerrno\fP устанавливается в \fBEAGAIN\fP,
\fBEWOULDBLOCK\fP или \fBEINPROGRESS\fP (для \fBconnect\fP(2)) — также как, если был
сокет был заблокирован. Если время ожидания установлено в 0 (по умолчанию),
то операция не будет ждать. Время ожидания учитывается только в системных
вызовах, которые выполняют ввод\-вывод из сокета (например, \fBread\fP(2),
\fBrecvmsg\fP(2), \fBsend\fP(2), \fBsendmsg\fP(2)); время ожидания не учитывается в
\fBselect\fP(2), \fBpoll\fP(2), \fBepoll_wait\fP(2) и подобных.
.TP 
\fBSO_REUSEADDR\fP
.\"	commit c617f398edd4db2b8567a28e899a88f8f574798d
.\"	https://lwn.net/Articles/542629/
Указать, что правила проверки адресов, передаваемых с помощью вызова
\fBbind\fP(2), должны позволять повторное использование локальных адресов. В
случае с сокетами \fBAF_INET\fP это означает, что сокет может быть привязан
(bind), за исключением случаев, когда активному слушающему сокету присвоен
адрес. Если слушающий сокет привязан к \fBINADDR_ANY\fP с определённым портом,
то к этому порту невозможно будет привязать любой локальный
адрес. Аргументом является целочисленный логический флаг.
.TP 
\fBSO_REUSEPORT\fP (начиная с Linux 3.9)
Разрешить многократную привязку сокета \fBAF_INET\fP или \fBAF_INET6\fP к
одинаковому адресу сокета. Данный параметр должен быть указан на каждом
сокете (включая первый сокет) до вызова \fBbind\fP(2). Чтобы предотвратить
захват порта  все привязки процессов к одному адресу должны иметь один
эффективный UID. Данный параметр можно применять к сокетам TCP и UDP.
.IP
Для сокетов TCP данный параметр позволяет \fBaccept\fP(2) распределить нагрузку
в многонитевом сервере, назначая разные слушатели сокета в каждой нити. Это
улучшает распределение нагрузки по сравнении с обычными методами, например с
одной принимающей нитью \fBaccept\fP(2), которая распределяет соединения, или с
несколькими нитями, которые конкурируют за \fBaccept\fP(2) единого сокета.
.IP
Для сокетов UDP использование данного параметра может улучшить распределение
входящих датаграмм по нескольким процессам (или нитям) по сравнении с
обычным методом с несколькими процессами, которые конкурируют при приёме
датаграмм из единого сокета.
.TP 
\fBSO_RXQ_OVFL\fP (начиная с Linux 2.6.33)
.\" commit 3b885787ea4112eaa80945999ea0901bf742707f
Указывает, что к принятым skbs должно быть прикреплено вспомогательное
сообщение (cmsg) с беззнаковым 32\-битным значением, которое обозначает
количество пакетов, отброшенных сокетом с момента его создания.
.TP 
\fBSO_SNDBUF\fP
.\" Most (all?) other implementations do not do this -- MTK, Dec 05
.\" See also the comment to SO_RCVBUF (17 Jul 2012 LKML mail)
Задать или считать максимальный размер буфера отправки сокета (в
байтах). Ядро удваивает это значение (для пространства под учёт ресурсов
(bookkeeping overhead)) при установке этого параметра с помощью
\fBsetsockopt\fP(2), и это удвоенное значение возвращается
\fBgetsockopt\fP(2). Значение по умолчанию устанавливается через файл
\fI/proc/sys/net/core/wmem_default\fP, а максимальное возможное значение
устанавливается через файл \fI/proc/sys/net/core/wmem_max\fP. Минимальное
(удвоенное) значение для этого параметра равно 2048.
.TP 
\fBSO_SNDBUFFORCE\fP (начиная Linux 2.6.14)
С помощью этого параметра сокета привилегированный (\fBCAP_NET_ADMIN\fP)
процесс может выполнить ту же работу, что и с помощью \fBSO_SNDBUF\fP, но
возможно превысить ограничение \fIwmem_max\fP.
.TP 
\fBSO_TIMESTAMP\fP
Включить или выключить приём управляющего сообщения
\fBSO_TIMESTAMP\fP. Управляющее сообщение метки времени посылается с уровнем
\fBSOL_SOCKET\fP, а поле \fIcmsg_data\fP выражено структурой \fIstruct timeval\fP,
обозначающей время приёма последнего пакета, переданного пользователю в этом
вызове. Подробней об управляющих сообщениях смотрите в \fBcmsg\fP(3).
.TP 
\fBSO_TYPE\fP
Получить тип сокета в виде целого числа (например, \fBSOCK_STREAM\fP). Этот
параметр сокета доступен только для чтения.
.TP 
\fBSO_BUSY_POLL\fP (начиная с Linux 3.11)
Задаёт приблизительный интервал в микросекундах для задержки опроса при
блокирующем приёме при отсутствии данных. Увеличение этого значения требует
мандата \fBCAP_NET_ADMIN\fP. Значение по умолчанию данного параметра
управляется через файл \fI/proc/sys/net/core/busy_read\fP.
.IP
Значение в файле \fI/proc/sys/net/core/busy_poll\fP определяет как долго
\fBselect\fP(2) и \fBpoll\fP(2) задержат опрос, если они работают с сокетами с
установленным \fBSO_BUSY_POLL\fP и отсутствуют события для извещения.
.IP
В обоих случаях опрос с задержкой (busy polling) будет завершён только,
когда сокет примет все данные из сетевого устройства, которое поддерживает
этот параметр.
.IP
Хотя опрос с задержкой может уменьшить время ожидания в некоторых
приложениях, этим нужно пользоваться с осторожностью, так как его
использование увеличит нагрузку на ЦП и энергопотребление.
.SS Сигналы
При записи в сокет, ориентированный на соединение, который был выключен
(shutdown) локальной или удалённой стороной, записывающему процессу
посылается сигнал \fBSIGPIPE\fP и возвращается \fBEPIPE\fP. Сигнал не посылается,
если вызов записи был сделан с флагом \fBMSG_NOSIGNAL\fP.
.PP
Если был произведён вызов \fBfcntl\fP(2) с \fBFIOSETOWN\fP или \fBioctl\fP(2) с
\fBSIOCSPGRP\fP, то при появлении событий ввода/вывода посылается сигнал
\fBSIGIO\fP. Для определения сокета, в котором произошло событие, в обработчике
можно воспользоваться вызовом \fBpoll\fP(2) или \fBselect\fP(2). Альтернативным
способом (в Linux 2.2) является установка сигнала реального времени с
помощью вызова \fBfcntl\fP(2) с \fBF_SETSIG\fP; будет вызван обработчик сигнала
реального времени и в его структуре \fIsiginfo_t\fP поле \fIsi_fd\fP будет
содержать значение файлового дескриптора. Дополнительная информация
приведена в \fBfcntl\fP(2).
.PP
.\" .SS Ancillary messages
В некоторых случаях (например, при наличии доступа нескольких процессов к
одному сокету) условие, вызвавшее \fBSIGIO\fP, может исчезнуть на момент
обработки процессом сигнала. Если это происходит, то процесс должен
подождать сигнала ещё какое\-то время, так как Linux снова пошлёт его позже.
.SS "Интерфейсы /proc"
Основные сетевые параметры сокета доступны через файлы в каталоге
\fI/proc/sys/net/core/\fP.
.TP 
\fIrmem_default\fP
устанавливаемый по умолчанию размер буфера приёма сокета (в байтах)
.TP 
\fIrmem_max\fP
максимальный размер буфера приёма сокета (в байтах), который может
установить пользователь с помощью параметра сокета \fBSO_RCVBUF\fP
.TP 
\fIwmem_default\fP
устанавливаемый по умолчанию размер буфера отправки сокета (в байтах)
.TP 
\fIwmem_max\fP
максимальный размер буфера отправки сокета (в байтах), который может
установить пользователь с помощью параметра сокета \fBSO_SNDBUF\fP
.TP 
\fImessage_cost\fP и \fImessage_burst\fP
фильтр корзины токенов, используемый для ограничения нагрузки сети
предупреждающими сообщениями, вызванными внешними сетевыми событиями
.TP 
\fInetdev_max_backlog\fP
максимальное количество пакетов в глобальной входящей очереди
.TP 
\fIoptmem_max\fP
.\" netdev_fastroute is not documented because it is experimental
максимальная длина вспомогательных данных и управляющих данных пользователя,
таких, как iovec (для каждого сокета)
.SS "Вызовы ioctl"
Следующие операции доступны через \fBioctl\fP(2):
.PP
.in +4n
.EX
\fIerror\fP\fB = ioctl(\fP\fIip_socket\fP\fB, \fP\fIioctl_type\fP\fB, \fP\fI&value_result\fP\fB);\fP
.EE
.in
.TP 
\fBSIOCGSTAMP\fP
.\"
Возвращает структуру \fIstruct timeval\fP с меткой времени принятого последнего
пакета, переданного пользователю. Это полезно для точного вычисления
времени. Описание \fIstruct timeval\fP приведено в \fBsetitimer\fP(2). Данный
ioctl нужно использовать только, если для сокета не задан параметр
\fBSO_TIMESTAMP\fP. В противном случае возвращается метка времени последнего
пакета, который был получен в то время, когда не был установлен
\fBSO_TIMESTAMP\fP, или возвращается ошибка, если такой пакет вообще никогда не
принимался (т.е. \fBioctl\fP(2) возвращает \-1 и устанавливает \fIerrno\fP равной
\fBENOENT\fP).
.TP 
\fBSIOCSPGRP\fP
Назначает процесс или группу процессов, которым будут посылаться сигналы
\fBSIGIO\fP или \fBSIGURG\fP при появлении возможности ввода\-вывода или при
появлении срочных данных. Аргумент является указателем на
\fIpid_t\fP. Дополнительная информация приведена в описании на \fBF_SETOWN\fP в
\fBfcntl\fP(2).
.TP 
\fBFIOASYNC\fP
Изменяет флаг \fBO_ASYNC\fP для включения или отключения асинхронного режима
ввода/вывода сокета. В асинхронном режиме при появлении событий ввода/вывода
посылается сигнал \fBSIGIO\fP или сигнал, установленный с помощью \fBF_SETSIG\fP.
.IP
.\"
Аргументом является целочисленный логический флаг. Данная операция
аналогична вызову \fBfcntl\fP(2) с установленным флагом \fBO_ASYNC\fP.
.TP 
\fBSIOCGPGRP\fP
Возвращает процесс или группу процессов, получающих сигналы \fBSIGIO\fP или
\fBSIGURG\fP. Если такой процесс не задан, то возвращается нулевое значение.
.PP
Возможные операции \fBfcntl\fP(2):
.TP 
\fBFIOGETOWN\fP
То же, что и вызов \fBioctl\fP(2) \fBSIOCGPGRP\fP.
.TP 
\fBFIOSETOWN\fP
То же, что и вызов \fBioctl\fP(2) \fBSIOCSPGRP\fP.
.SH ВЕРСИИ
Параметр \fBSO_BINDTODEVICE\fP появился в Linux 2.0.30. Параметр \fBSO_PASSCRED\fP
появился в Linux 2.2. Интерфейсы \fI/proc\fP появились в Linux 2.2. Параметры
\fBSO_RCVTIMEO\fP и \fBSO_SNDTIMEO\fP начали поддерживаться в Linux 2.3.41. До
этого, времена ожидания были жёстко прописаны в настройках протокола и
недоступны для чтения или записи.
.SH ЗАМЕЧАНИЯ
В Linux предполагается, что половина буфера приёма/передачи используется для
размещения внутренних структур ядра; поэтому соответствующие файлы \fI/proc\fP
в два раза больше, чем кажутся.
.PP
.\" .SH AUTHORS
.\" This man page was written by Andi Kleen.
В Linux разрешено повторное использование порта с параметром \fBSO_REUSEADDR\fP
только, когда этот параметр установлен и в программе, уже выполнившей
\fBbind\fP(2) и в программе, которая хочет использовать порт. Такое поведение
отличается от некоторых реализаций (например, FreeBSD), в которых только
последняя программа должна устанавливать параметр \fBSO_REUSEADDR\fP. Обычно,
это отличие незаметно, так как, например, в серверных программах всегда
устанавливают этот параметр.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBwireshark\fP(1), \fBbpf\fP(2), \fBconnect\fP(2), \fBgetsockopt\fP(2),
\fBsetsockopt\fP(2), \fBsocket\fP(2), \fBpcap\fP(3), \fBaddress_families\fP(7),
\fBcapabilities\fP(7), \fBddp\fP(7), \fBip\fP(7), \fBpacket\fP(7), \fBtcp\fP(7), \fBudp\fP(7),
\fBunix\fP(7), \fBtcpdump\fP(8)
