.\" -*- mode: troff; coding: UTF-8 -*-
.\"
.\" Copyright (C) 2014 Red Hat, Inc. All Rights Reserved.
.\" Written by David Howells (dhowells@redhat.com)
.\"
.\" %%%LICENSE_START(GPLv2+_SW_ONEPARA)
.\" This program is free software; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License
.\" as published by the Free Software Foundation; either version
.\" 2 of the License, or (at your option) any later version.
.\" %%%LICENSE_END
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH PERSISTENT\-KEYRING 7 2017\-03\-13 Linux "Руководство программиста Linux"
.SH ИМЯ
persistent\-keyring \- пользовательская постоянная связка ключей
.SH ОПИСАНИЕ
Постоянная связка ключей — это связка, используемая для привязки от имени
пользователя. Для каждого UID ядро создаёт отдельную постоянную связку
ключей, которая используется всеми нитями, принадлежащими этому
UID. Постоянная связка ключей имеет имя (описание) в виде
\fI_persistent.<UID>\fP, \fI<UID>\fP — ID пользователя
соответствующего пользователя.
.PP
.\" FIXME The meaning of the preceding sentence isn't clear. What is meant?
Прямой доступ к постоянной связке ключей невозможен, даже процессам с
подходящим UID. Вместо этого сначала она должна быть прицеплена к одной из
связок ключей процесса, до этого связка ключей может получить доступ к
постоянной связке ключей согласно правам своего владельца. Эта связь
создаётся с помощью функции \fBkeyctl_get_persistent\fP(3).
.PP
Если постоянная связка ключей не существует на момент вызова операции
\fBkeyctl_get_persistent\fP(3), то она автоматически создаётся.
.PP
Каждый раз при выполнении операции \fBkeyctl_get_persistent\fP(3) срок действия
постоянного  ключа сбрасывается в значение:
.PP
    /proc/sys/kernel/keys/persistent_keyring_expiry
.PP
По истечению срока действия постоянная связка ключей удаляется и все ссылки
на неё затем удаляются сборщиком мусора. После этого ключ будет пересоздан
при следующем вызове \fBkeyctl_get_persistent\fP(3).
.PP
В постоянной связке ключей напрямую невозможно искать с помощью
\fBrequest_key\fP(2); в ней можно искать только, если она прицеплена к одной из
связок ключей, по которой выполняется \fBrequest_key\fP(2).
.PP
Постоянная связка ключей не зависит от \fBclone\fP(2), \fBfork\fP(2), \fBvfork\fP(2),
\fBexecve\fP(2) и \fB_exit\fP(2). Она существует до истечения срока действия
таймера, после чего удаляется сборщиком мусора. Это позволяет связке ключей
хранить ключи дольше жизни ядерной записи соответствующего UID (удаление
которой приводит к уничтожению \fBuser\-keyring\fP(7) и
\fBuser\-session\-keyring\fP(7)). Таким образом, постоянную связку ключей можно
использовать для хранения токенов аутентификации для процессов, которые
выполняются без взаимодействия с пользователем, например программы,
выполняемые \fBcron\fP(8).
.PP
.\"
Постоянная связка ключей используется для хранения объектов, для UID,
которые сами имеют ограниченный срок жизни (например, токены kerberos). Если
такие токены больше не используются (т. е., связка ключей недоступна), то
срок действия постоянной связки ключей позволяет автоматически удалять
соответствующие ей объекты.
.SS "Специальные операции"
Библиотека \fIkeyutils\fP для работы с постоянными связками ключей
предоставляет функцию \fBkeyctl_get_persistent\fP(3) (эта функция является
интерфейсом к операции \fBkeyctl\fP(2)  \fBKEYCTL_GET_PERSISTENT\fP). Данная
операция позволяет вызывающей нити получить постоянную связку ключей,
соответствующую её UID или, если нить имеет мандат \fBCAP_SETUID\fP, то
постоянная связка ключей соответствует какому\-то другому UID в этом же
пространстве имён пользователя.
.SH ЗАМЕЧАНИЯ
Каждое пространство имён пользователя имеет свою связку ключей с именем
\&\fI.persistent_register\fP, в которой содержатся ссылки на все постоянные ключи
в этом пространстве имён (связку ключей \fI.persistent_register\fP можно
увидеть при чтении в пространстве имён содержимого файла \fI/proc/keys\fP для
UID 0). Операция \fBkeyctl_get_persistent\fP(3) ищет ключ с именем в виде
\fI_persistent.<UID>\fP в этой связке ключей, создаёт ключ, если он не
существует и прицепляет его в связку ключей.
.SH "СМОТРИТЕ ТАКЖЕ"
.ad l
.nh
\fBkeyctl\fP(1), \fBkeyctl\fP(3), \fBkeyctl_get_persistent\fP(3), \fBkeyrings\fP(7),
\fBprocess\-keyring\fP(7), \fBsession\-keyring\fP(7), \fBthread\-keyring\fP(7),
\fBuser\-keyring\fP(7), \fBuser\-session\-keyring\fP(7)
