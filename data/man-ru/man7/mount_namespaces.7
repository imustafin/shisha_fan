.\" -*- mode: troff; coding: UTF-8 -*-
.\" Copyright (c) 2016, 2019 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH MOUNT_NAMESPACES 7 2019\-08\-02 Linux "Руководство программиста Linux"
.SH ИМЯ
mount_namespaces \- обзор пространств имён монтирования в Linux
.SH ОПИСАНИЕ
Обзор пространств имён смотрите в \fBnamespaces\fP(7).
.PP
Пространства имён монтирования позволяют изолировать список точек
монтирования, видимый процессами в каждом экземпляре пространства имён. То
есть, процессы в каждом из экземпляров пространства имён монтирования будут
видеть разные иерархии в одном и том же каталоге.
.PP
Данные файлов \fI/proc/[pid]/mounts\fP, \fI/proc/[pid]/mountinfo\fP и
\fI/proc/[pid]/mountstats\fP (описаны в \fBproc\fP(5)) соответствуют пространству
имён монтирования, в котором расположен процесс с PID \fI[pid]\fP (для всех
процессов, которые расположены в одном пространстве имён монтирования,
данные в этих файлах одинаковы).
.PP
.\"
.\" ============================================================
.\"
Когда процесс создаёт новое пространство имён монтирования с помощью
\fBclone\fP(2) или \fBunshare\fP(2)  с флагом \fBCLONE_NEWNS\fP список точек
монтирования для нового пространства имён представляет собой \fIкопию\fP списка
точек монтирования вызывающего. Последующие изменения списка точек
монтирования (\fBmount\fP(2) и \fBumount\fP(2)) в любом пространстве имён
монтирования не влияют (по умолчанию) на список точек монтирования, видимый
из другого пространства имён (но смотрите далее описание общих поддеревьев).
.SS "Ограничения у пространств имён монтирования"
Отметим следующие моменты относительно пространств имён монтирования:
.IP * 3
Владельцем пространства имён монтирования является владелец
пользовательского пространство имён. Пространство имён монтирования, чей
владелец пользовательского пространства имён отличается от владельца
пользовательского пространства имён родительского пространства имён
монтирования, считается менее привилегированным пространством имён
монтирования.
.IP *
При создании менее привилегированного пространства имён монтирования
количество общих точек монтирования сокращаются до списка подчинённых точек
монтирования (про общие и подчинённые точки монтирования смотрите
далее). Это гарантирует, что отображения, выполняемые в менее
привилегированном пространстве имён монтирования, не распространятся в более
привилегированные пространства имён монтирования.
.IP *
.\" FIXME .
.\"	What does "come as a single unit from more privileged mount" mean?
Точки монтирования, которые появились как единый блок из более
привилегированного монтирования, объединяются и не могут быть разделены в
менее привилегированном пространстве имён монтирования (операция
\fBunshare\fP(2) \fBCLONE_NEWNS\fP переносит все точки монтирования из исходного
пространства имён монтирования единым блоком и рекурсивные монтирования,
которые передаются в нескольких пространствах имён монтирования, также
единым блоком).
.IP *
.\" commit 9566d6742852c527bf5af38af5cbb878dad75705
.\" Author: Eric W. Biederman <ebiederm@xmission.com>
.\" Date:   Mon Jul 28 17:26:07 2014 -0700
.\"
.\"      mnt: Correct permission checks in do_remount
.\"
Значения флагов \fBMS_RDONLY\fP, \fBMS_NOSUID\fP, \fBMS_NOEXEC\fP у \fBmount\fP(2) и
флагов «atime» (\fBMS_NOATIME\fP, \fBMS_NODIRATIME\fP, \fBMS_RELATIME\fP) блокируются
при передаче из более привилегированного в менее привилегированное
пространство имён монтирования, и не могут быть изменены в менее
привилегированном пространстве имён монтирования.
.IP *
.\" (As of 3.18-rc1 (in Al Viro's 2014-08-30 vfs.git#for-next tree))
Файл или каталог, являющийся точкой монтирования в одном пространстве имён,
и не являющийся в другом, может быть переименован, отсоединён (unlinked) или
удалён (\fBrmdir\fP(2)) в пространстве имён монтирования, в котором он не
является точкой монтирования (выполняются обычные проверки прав доступа).При
этом точка монтирования удаляется в пространстве имён монтирования, в
котором она была точкой монтирования.
.IP
.\" mtk: The change was in Linux 3.18, I think, with this commit:
.\"     commit 8ed936b5671bfb33d89bc60bdcc7cf0470ba52fe
.\"     Author: Eric W. Biederman <ebiederman@twitter.com>
.\"     Date:   Tue Oct 1 18:33:48 2013 -0700
.\"
.\"         vfs: Lazily remove mounts on unlinked files and directories.
.\"
Раньше (до Linux 3.18), попытка переименовать, отсоединить или удалить файл
или каталог, который являлся точкой монтирования в другом пространстве имён
монтирования, приводила к ошибке \fBEBUSY\fP. Такое поведение вызывало
технические проблемы в работе (например, NFS) и позволяло выполнять атаку
отказа в обслуживании более привилегированных пользователей (т. е., не
давало обновлять отдельные файлы посредством монтирования поверх их).
.SH "ОБЩИЕ ПОДДЕРЕВЬЯ"
После завершения реализации пространств имён монтирования опыт использования
показал, что полученная изоляция, в некоторых случаях, слишком
велика. Например, чтобы только что смонтированный оптический диск сделать
доступным в во всех пространствах имён, требуется операция монтирования в
каждом пространстве имён. Для этого случаях и других в Linux 2.6.15 были
добавлены общие поддеревья. Это свойство предоставляет автоматическое,
управляемое распространение \fIсобытий\fP монтирования и размонтирования в
пространствах имён (или, точнее, между членами \fIравноправной группы\fP,
которые обмениваются событиями между собой).
.PP
Каждая точка монтирования помечается (в \fBmount\fP(2)) одним из следующих
\fIтипов распространения\fP:
.TP 
\fBMS_SHARED\fP
События такой точки монтирования являются общими с остальными членами
равноправной группы. События монтирования и размонтирования этой точки сразу
же распространяются на другие точки монтирования, являющиеся членами
равноправной группы. То есть монтирование или размонтирование автоматически
происходит и у всех остальных точек монтирования в равноправной группе. И
наоборот, события монтирования и размонтирования, возникшие у точек
монтирования равноправной группы, будут распространены и на эту точку
монтирования.
.TP 
\fBMS_PRIVATE\fP
Данная точка монтирования индивидуальна; у неё нет равноправной
группы. События монтирования и размонтирования не распространяются от этой
точки и на эту точку.
.TP 
\fBMS_SLAVE\fP
События монтирования и размонтирования распространяются на эту точку
монтирования из (главной) общей равноправной группы. События монтирования и
размонтирования этой точки не распространяются на членов группы.
.IP
Заметим, что точка монтирования может быть подчинённой одной равноправной
группе и в тоже время может распространять события в другую группу, где она
является членом (точнее, одна равноправная группа может быть подчинённой
другой равноправной группе).
.TP 
\fBMS_UNBINDABLE\fP
Данный тип подобен индивидуальной точке монтирования, но дополнительно такая
точка монтирования не может быть привязана (bind). Попытка привязать эту
точку монтирования (\fBmount\fP(2) с флагом \fBMS_BIND\fP) завершится ошибкой.
.IP
При рекурсивной привязке (\fBmount\fP(2) с флагами \fBMS_BIND\fP и \fBMS_REC\fP)
поддерева каталога все привязки внутри поддерева автоматически удаляются
(т. е., не копируются) при копировании этого поддерева для создания целевого
поддерева.
.PP
Описание типа распространения, назначаемого на новое монтирование, смотрите
в ЗАМЕЧАНИЯХ.
.PP
Тип распространения имеется у каждой точки монтирования; некоторые точки
монтирования могут быть помечены как общие (каждая общая точка монтирования
является членом определённой равноправной группы), а некоторые как
индивидуальные (или подчинённые или непривязываемые).
.PP
Заметим, что тип распространения монтирования определяет, будет ли
монтирование или размонтирование распространяться точки монтирования,
находящиеся \fIна одну ступень ниже\fP точки, где возникло событие. То есть,
тип распространения не влияет на распространение событий для внуков и в
дальнейшем удаляемых потомков точки монтирования. Это случается, если сама
точка монтирования размонтируется из\-за действия типа распространения
который, в сущности, влияние \fIродительской\fP точки монтирования.
.PP
Члены добавляются в \fIравноправную группу\fP, если точка монтирования
помечается как общая, или:
.IP * 3
точка монтирования копируется при создании нового пространства имён
монтирования
.IP *
создаётся новая привязка из точки монтирования
.PP
В обоих случаях новая точка монтирования присоединяется к равноправной
группе, в которую входит существующая точка монтирования.
.PP
Новая равноправная группа также создаётся, если дочерняя точка монтирования
создана под существующей точкой монтирования, помеченной как общая. В этом
случае, новая дочерняя точка монтирования также помечается как общая и
получаемая равноправная группа состоит из всех точек монтирования, которые
дублируются в равноправных группах родительской точки монтирования.
.PP
Точка монтирования перестаёт быть членом равноправной группы, когда
происходит её явное размонтирование или неявное из\-за удаления пространства
имён монтирования (из\-за отсутствия участвующих процессов).
.PP
Тип распространения точек монтирования в пространстве имён монтирования
может узнать через «необязательные поля» в файле \fI/proc/[pid]/mountinfo\fP
(описание файла смотрите в \fBproc\fP(5)). В необязательных полях этого файла
могут появляться следующие метки:
.TP 
\fIshared:X\fP
Эта точка монтирования является общей в равноправной группе \fIX\fP. Каждая
равноправная группа имеет автоматически генерируемый ядром уникальный
идентификатор, и у всех точек монтирования одной равноправной группы здесь
будет одинаковый идентификатор (эти идентификаторы начинаются с 1 и могут
повторно использоваться, когда в равноправной группе не останется членов).
.TP 
\fImaster:X\fP
Эта точка монтирования является подчинённой общей равноправной группе \fIX\fP.
.TP 
\fIpropagate_from:X\fP (начиная с Linux 2.6.26)
.\" commit 97e7e0f71d6d948c25f11f0a33878d9356d9579e
Эта точка монтирования является подчинённой и принимает события от общей
равноправной группы \fIX\fP. Данная метка всегда появляется вместе с меткой
\fImaster:X\fP. Здесь \fIX\fP это ближайшая главенствующая равноправная группа из
корневого каталога процесса. Если \fIX\fP является непосредственным владельцем
точки монтирования, или в том же корне нет ближайшей главенствующей
равноправной группы, то существует только поле \fImaster:X\fP, и поле
\fIpropagate_from:X\fP отсутствует. Подробности смотрите ниже.
.TP 
\fIunbindable\fP
Точка монтирования является непривязываемой.
.PP
Если нет ни одной из вышеперечисленных меток, то точка монтирования является
индивидуальной.
.SS "Пример MS_SHARED и MS_PRIVATE"
Предположим, что на терминале в первоначальном пространстве имён
монтирования мы помечаем одну точку монтирования как общую, а другую — как
индивидуальную, и затем смотрим точки монтирования в
\fI/proc/self/mountinfo\fP:
.PP
.in +4n
.EX
sh1# \fBmount \-\-make\-shared /mntS\fP
sh1# \fBmount \-\-make\-private /mntP\fP
sh1# \fBcat /proc/self/mountinfo | grep \(aq/mnt\(aq | sed \(aqs/ \- .*//\(aq\fP
77 61 8:17 / /mntS rw,relatime shared:1
83 61 8:15 / /mntP rw,relatime
.EE
.in
.PP
Из вывода \fI/proc/self/mountinfo\fP мы видим, что \fI/mntS\fP является общей
точкой монтирования в равноправной группе 1, и что \fI/mntP\fP не имеет
необязательных меток, то есть это индивидуальная точка монтирования. Первые
два поля в каждой записи этого файла содержат уникальный идентификатор этой
точки монтирования и идентификатор точки монтирования родительской точки
монтирования. Далее в файле мы видим, что родительская точка монтирования
\fI/mntS\fP и \fI/mntP\fP является корневым каталогом, \fI/\fP, которая смонтирована
как индивидуальная:
.PP
.in +4n
.EX
sh1# \fBcat /proc/self/mountinfo | awk \(aq$1 == 61\(aq | sed \(aqs/ \- .*//\(aq\fP
61 0 8:2 / / rw,relatime
.EE
.in
.PP
На втором терминале мы создаём новое пространство имён монтирования, в
котором запускаем вторую оболочку, и смотрим точки монтирования:
.PP
.in +4n
.EX
$ \fBPS1=\(aqsh2# \(aq sudo unshare \-m \-\-propagation unchanged sh\fP
sh2# \fBcat /proc/self/mountinfo | grep \(aq/mnt\(aq | sed \(aqs/ \- .*//\(aq\fP
222 145 8:17 / /mntS rw,relatime shared:1
225 145 8:15 / /mntP rw,relatime
.EE
.in
.PP
.\" Since util-linux 2.27
Новое пространство имён монтирования получает копию точек монтирования из
начального пространства имён монтирования. Эти новые точки монтирования
имеют тот же тип распространения, но другие уникальные идентификаторы
монтирования (при создании нового пространства имён монтирования передача
параметра \fI\-\-propagation\ unchanged\fP программе \fBunshare\fP(1) не даёт
помечать все точки монтирования как индивидуальные (что делается по
умолчанию)).
.PP
Далее на втором терминале мы создаём подмонтирования в каталоге  \fI/mntS\fP и
\fI/mntP\fP и смотрим что получилось:
.PP
.in +4n
.EX
sh2# \fBmkdir /mntS/a\fP
sh2# \fBmount /dev/sdb6 /mntS/a\fP
sh2# \fBmkdir /mntP/b\fP
sh2# \fBmount /dev/sdb7 /mntP/b\fP
sh2# \fBcat /proc/self/mountinfo | grep \(aq/mnt\(aq | sed \(aqs/ \- .*//\(aq\fP
222 145 8:17 / /mntS rw,relatime shared:1
225 145 8:15 / /mntP rw,relatime
178 222 8:22 / /mntS/a rw,relatime shared:2
230 225 8:23 / /mntP/b rw,relatime
.EE
.in
.PP
Из показанного выше мы видим, что \fI/mntS/a\fP была создана как общая
(унаследовала от родительской точки монтирования), а \fI/mntP/b\fP — как
индивидуальная точка монтирования.
.PP
Если вернуться на первый терминал и и ещё раз посмотреть параметры, то можно
увидеть, что новая точка монтирования, созданная в общей точке монтирования
\fI/mntS\fP, передалась в свою равноправную группу монтирования (в начальном
пространстве имён монтирования), а новая точка монтирования, созданная в
индивидуальной точке монтирования \fI/mntP\fP, нет:
.PP
.in +4n
.EX
sh1# \fBcat /proc/self/mountinfo | grep \(aq/mnt\(aq | sed \(aqs/ \- .*//\(aq\fP
77 61 8:17 / /mntS rw,relatime shared:1
83 61 8:15 / /mntP rw,relatime
179 77 8:22 / /mntS/a rw,relatime shared:2
.EE
.in
.\"
.SS "Пример MS_SLAVE"
Создание подчинённой точки монтирования позволяет ей принимать
распространяемые события монтирования и размонтирования из главной общей
равноправной группы, но запрещает распространять события в эту главную
группу. Это полезно, если требуется, скажем, принимать событие монтирования
оптического диска в главной общей равноправной группе (в другом пространстве
имён монтирования), но не нужно, чтобы события монтирования и
размонтирования в подчинённой точке монтирования передавались в другие
пространства имён.
.PP
Для демонстрации следствия подчинённости сначала создадим две общие точки
монтирования в начальном пространстве имён монтирования:
.PP
.in +4n
.EX
sh1# \fBmount \-\-make\-shared /mntX\fP
sh1# \fBmount \-\-make\-shared /mntY\fP
sh1# \fBcat /proc/self/mountinfo | grep \(aq/mnt\(aq | sed \(aqs/ \- .*//\(aq\fP
132 83 8:23 / /mntX rw,relatime shared:1
133 83 8:22 / /mntY rw,relatime shared:2
.EE
.in
.PP
На втором терминале создадим новое пространство имён монтирования и
посмотрим точки монтирования:
.PP
.in +4n
.EX
sh2# \fBunshare \-m \-\-propagation unchanged sh\fP
sh2# \fBcat /proc/self/mountinfo | grep \(aq/mnt\(aq | sed \(aqs/ \- .*//\(aq\fP
168 167 8:23 / /mntX rw,relatime shared:1
169 167 8:22 / /mntY rw,relatime shared:2
.EE
.in
.PP
Далее в новом пространстве имён монтирования пометим одну из точек
монтирования как подчинённую:
.PP
.in +4n
.EX
sh2# \fBmount \-\-make\-slave /mntY\fP
sh2# \fBcat /proc/self/mountinfo | grep \(aq/mnt\(aq | sed \(aqs/ \- .*//\(aq\fP
168 167 8:23 / /mntX rw,relatime shared:1
169 167 8:22 / /mntY rw,relatime master:2
.EE
.in
.PP
Из показанного выше видно, что \fI/mntY\fP теперь подчинённая точка
монтирования, которая принимать распространяемые события от общей
равноправной группы с ID 2.
.PP
Далее в новом пространстве имён создадим подмонтирования в \fI/mntX\fP и
\fI/mntY\fP:
.PP
.in +4n
.EX
sh2# \fBmkdir /mntX/a\fP
sh2# \fBmount /dev/sda3 /mntX/a\fP
sh2# \fBmkdir /mntY/b\fP
sh2# \fBmount /dev/sda5 /mntY/b\fP
.EE
.in
.PP
Если посмотреть состояние точек монтирования в новом пространстве имён
монтирования можно увидеть, что \fI/mntX/a\fP создана как новая общая точка
монтирования (наследует «общность» от родительской точки монтирования), а
\fI/mntY/b\fP создана как индивидуальная точка монтирования:
.PP
.in +4n
.EX
sh2# \fBcat /proc/self/mountinfo | grep \(aq/mnt\(aq | sed \(aqs/ \- .*//\(aq\fP
168 167 8:23 / /mntX rw,relatime shared:1
169 167 8:22 / /mntY rw,relatime master:2
173 168 8:3 / /mntX/a rw,relatime shared:3
175 169 8:5 / /mntY/b rw,relatime
.EE
.in
.PP
Если вернуться на первый терминал (в начальное пространство имён
монтирования), то можно увидеть, что точка монтирования \fI/mntX/a\fP
передалась в свою равноправную группу (общую с \fI/mntX\fP), а точка
монтирования \fI/mntY/b\fP нет:
.PP
.in +4n
.EX
sh1# \fBcat /proc/self/mountinfo | grep \(aq/mnt\(aq | sed \(aqs/ \- .*//\(aq\fP
132 83 8:23 / /mntX rw,relatime shared:1
133 83 8:22 / /mntY rw,relatime shared:2
174 132 8:3 / /mntX/a rw,relatime shared:3
.EE
.in
.PP
Теперь создадим новую точку монтирования в \fI/mntY\fP в первом терминале:
.PP
.in +4n
.EX
sh1# \fBmkdir /mntY/c\fP
sh1# \fBmount /dev/sda1 /mntY/c\fP
sh1# \fBcat /proc/self/mountinfo | grep '/mnt' | sed 's/ \- .*//'\fP
132 83 8:23 / /mntX rw,relatime shared:1
133 83 8:22 / /mntY rw,relatime shared:2
174 132 8:3 / /mntX/a rw,relatime shared:3
178 133 8:1 / /mntY/c rw,relatime shared:4
.EE
.in
.PP
Если посмотреть точки монтирования во втором пространстве имён монтирования,
то можно увидеть, что на этот раз новая точка монтирования передалась в
подчинённую точку монтирования и что эта новая точка монтирования сама
является подчинённой (равноправной группе 4):
.PP
.in +4n
.EX
sh2# \fBcat /proc/self/mountinfo | grep \(aq/mnt\(aq | sed \(aqs/ \- .*//\(aq\fP
168 167 8:23 / /mntX rw,relatime shared:1
169 167 8:22 / /mntY rw,relatime master:2
173 168 8:3 / /mntX/a rw,relatime shared:3
175 169 8:5 / /mntY/b rw,relatime
179 169 8:1 / /mntY/c rw,relatime master:4
.EE
.in
.\"
.SS "Пример MS_UNBINDABLE"
Одним из основных назначений непривязываемых точек монтирования является
решение проблемы «взрыва точек монтирования» — повторяющееся выполнение
привязки точки монтирования поддерева верхнего уровня в точках монтирования
нижнего уровня. Эта проблема показана в сеансе далее.
.PP
Предположим, что имеется система с следующими точками монтирования:
.PP
.in +4n
.EX
# \fBmount | awk \(aq{print $1, $2, $3}\(aq\fP
/dev/sda1 on /
/dev/sdb6 on /mntX
/dev/sdb7 on /mntY
.EE
.in
.PP
Предположим, что нужно рекурсивно привязать точки монтирования корневого
каталога в нескольких пользовательских домашних каталогах. Сделаем это для
первого пользователя и посмотрим точки монтирования:
.PP
.in +4n
.EX
# \fBmount \-\-rbind / /home/cecilia/\fP
# \fBmount | awk \(aq{print $1, $2, $3}\(aq\fP
/dev/sda1 on /
/dev/sdb6 on /mntX
/dev/sdb7 on /mntY
/dev/sda1 on /home/cecilia
/dev/sdb6 on /home/cecilia/mntX
/dev/sdb7 on /home/cecilia/mntY
.EE
.in
.PP
Повторяя эту операцию для второго пользователя сталкиваемся с проблемой
взрывного роста:
.PP
.in +4n
.EX
# \fBmount \-\-rbind / /home/henry\fP
# \fBmount | awk \(aq{print $1, $2, $3}\(aq\fP
/dev/sda1 on /
/dev/sdb6 on /mntX
/dev/sdb7 on /mntY
/dev/sda1 on /home/cecilia
/dev/sdb6 on /home/cecilia/mntX
/dev/sdb7 on /home/cecilia/mntY
/dev/sda1 on /home/henry
/dev/sdb6 on /home/henry/mntX
/dev/sdb7 on /home/henry/mntY
/dev/sda1 on /home/henry/home/cecilia
/dev/sdb6 on /home/henry/home/cecilia/mntX
/dev/sdb7 on /home/henry/home/cecilia/mntY
.EE
.in
.PP
В \fI/home/henry\fP рекурсивно добавились не только точки монтирования \fI/mntX\fP
и \fI/mntY\fP, но и рекурсивные точки монтирования этих каталогов,
смонтированных в \fI/home/cecilia\fP, который мы создали на предыдущем
шаге. Далее повторяя процесс для третьего пользователя, станет очевидно, что
взрывной рост происходит экспоненциально:
.PP
.in +4n
.EX
# \fBmount \-\-rbind / /home/otto\fP
# \fBmount | awk \(aq{print $1, $2, $3}\(aq\fP
/dev/sda1 on /
/dev/sdb6 on /mntX
/dev/sdb7 on /mntY
/dev/sda1 on /home/cecilia
/dev/sdb6 on /home/cecilia/mntX
/dev/sdb7 on /home/cecilia/mntY
/dev/sda1 on /home/henry
/dev/sdb6 on /home/henry/mntX
/dev/sdb7 on /home/henry/mntY
/dev/sda1 on /home/henry/home/cecilia
/dev/sdb6 on /home/henry/home/cecilia/mntX
/dev/sdb7 on /home/henry/home/cecilia/mntY
/dev/sda1 on /home/otto
/dev/sdb6 on /home/otto/mntX
/dev/sdb7 on /home/otto/mntY
/dev/sda1 on /home/otto/home/cecilia
/dev/sdb6 on /home/otto/home/cecilia/mntX
/dev/sdb7 on /home/otto/home/cecilia/mntY
/dev/sda1 on /home/otto/home/henry
/dev/sdb6 on /home/otto/home/henry/mntX
/dev/sdb7 on /home/otto/home/henry/mntY
/dev/sda1 on /home/otto/home/henry/home/cecilia
/dev/sdb6 on /home/otto/home/henry/home/cecilia/mntX
/dev/sdb7 on /home/otto/home/henry/home/cecilia/mntY
.EE
.in
.PP
Проблемы взрывного роста монтирования в показанном сценарии можно избежать,
если делать каждое новое монтирование непривязываемым. В этом случае
рекурсивное монтирование корневого каталоге не копирует непривязываемые
точки монтирования. Сделаем такое монтирование для первого пользователя:
.PP
.in +4n
.EX
# \fBmount \-\-rbind \-\-make\-unbindable / /home/cecilia\fP
.EE
.in
.PP
Перед тем как продолжить, посмотрим, что непривязываемые точки монтирования
действительно нельзя привязать:
.PP
.in +4n
.EX
# \fBmkdir /mntZ\fP
# \fBmount \-\-bind /home/cecilia /mntZ\fP
mount: wrong fs type, bad option, bad superblock on /home/cecilia,
       missing codepage or helper program, or other error

       В некоторых случаях полезная информация может быть
       найдена в syslog \- попробуйте dmesg | tail или что\-то
       в этом роде.
.EE
.in
.PP
Теперь создадим непривязываемое рекурсивное монтирования для остальных
пользователей:
.PP
.in +4n
.EX
# \fBmount \-\-rbind \-\-make\-unbindable / /home/henry\fP
# \fBmount \-\-rbind \-\-make\-unbindable / /home/otto\fP
.EE
.in
.PP
Если посмотреть список точек монтирования, то можно увидеть, что взрывного
роста не произошло, так как непривязываемые точки монтирования не
скопировались в каждый пользовательский каталог:
.PP
.in +4n
.EX
# \fBmount | awk \(aq{print $1, $2, $3}\(aq\fP
/dev/sda1 on /
/dev/sdb6 on /mntX
/dev/sdb7 on /mntY
/dev/sda1 on /home/cecilia
/dev/sdb6 on /home/cecilia/mntX
/dev/sdb7 on /home/cecilia/mntY
/dev/sda1 on /home/henry
/dev/sdb6 on /home/henry/mntX
/dev/sdb7 on /home/henry/mntY
/dev/sda1 on /home/otto
/dev/sdb6 on /home/otto/mntX
/dev/sdb7 on /home/otto/mntY
.EE
.in
.\"
.SS "Переходы типов распространения"
В следующей таблице показано как влияет применение нового типа
распространения (т. е., \fImount \-\-make\-xxxx\fP) на текущий тип распространения
точки монтирования. Строки соответствуют существующим типам распространения,
а столбцы — заданию нового типа распространения. Из\-за нехватки места
«индивидуальная» тип сокращён до «инд», а «непривязываемая» до «неприв».
.TS
lb2 lb2 lb2 lb2 lb1
lb l l l l l.
	сделать\-общим	сделать\-подчинён	сделать\-инд	сделать\-неприв
общий	общий	общий/инд [1]	инд	неприв
подчинён	подчинён+общий	подчинён [2]	инд	неприв
подчинён+общий	подчинён+общий	подчинён	инд	неприв
инд	общий	инд [2]	инд	неприв
неприв	общий	неприв [2]	инд	неприв
.TE
.sp 1
Замечания к таблице:
.IP [1] 4
Если общая точка монтирования смонтирована только в её равноправной группе,
то изменение её типа на подчинённый автоматически делает её индивидуальной.
.IP [2]
.\"
Подчинение не общей точки монтирования не влияет на монтирование.
.SS "Семантика привязывания (MS_BIND)"
Предположим, что выполняется следующая команда:
.PP
.in +4n
.EX
mount \-\-bind A/a B/b
.EE
.in
.PP
Здесь \fIA\fP — исходная точка монтирования, \fIB\fP — целевая точка монтирования,
\fIa\fP — подкаталог в точке монтирования \fIA\fP и \fIb\fP — подкаталог в точке
монтирования \fIB\fP. Тип распространения получаемой точки, \fIB/b\fP, зависит от
типов распространения точек монтирования \fIA\fP и \fIB\fP, и рассчитывается по
следующей таблице:
.PP
.TS
lb2 lb1 lb2 lb2 lb2 lb0
lb2 lb1 lb2 lb2 lb2 lb0
lb lb l l l l l.
			исход(A)
		общий	инд	подчинён	неприв
_
цель(B)	общий    |	общий	общий	подчинён+общий	некорректно
	не_общий |	общий	инд	подчинён	некорректно
.TE
.sp 1
Заметим, что рекурсивное привязывание поддерева имеет такую же семантику как
в операции привязывания каждой точки монтирования в поддереве
(непривязываемые точки монтирования автоматически убираются из целевой точки
монтирования).
.PP
.\"
Дополнительную информацию смотрите в файле
\fIDocumentation/filesystems/sharedsubtree.txt\fP дерева исходного кода ядра.
.SS "Семантика перемещения (MS_MOVE)"
Предположим, что выполняется следующая команда:
.PP
.in +4n
.EX
mount \-\-move A B/b
.EE
.in
.PP
Здесь \fIA\fP — исходная точка монтирования, \fIB\fP — целевая точка монтирования
и \fIb\fP — подкаталог в точке монтирования \fIB\fP. Тип распространения
получаемой точки, \fIB/b\fP, зависит от типов распространения точек
монтирования \fIA\fP и \fIB\fP, и рассчитывается по следующей таблице:
.PP
.TS
lb2 lb1 lb2 lb2 lb2 lb0
lb2 lb1 lb2 lb2 lb2 lb0
lb lb l l l l l.
			исход(A)
		общий	инд	подчинён	неприв
_
цель(B)	общий    |	общий	общий	подчинён+общий	некорректно
	не_общий |	общий	инд	подчинён	неприв
.TE
.sp 1
Замечание: перемещение точки монтирования, располагающейся ниже общей точки,
некорректно.
.PP
.\"
Дополнительную информацию смотрите в файле
\fIDocumentation/filesystems/sharedsubtree.txt\fP дерева исходного кода ядра.
.SS "Семантики монтирования"
Предположим, что для создания точки монтирования используется следующая
команда:
.PP
.in +4n
.EX
mount устройство B/b
.EE
.in
.PP
.\"
Здесь \fIB\fP — целевая точка монтирования и \fIb\fP — подкаталог в точке
монтирования \fIB\fP. Тип распространения получаемой точки, \fIB/b\fP, получается
таким же как при привязывании, где тип распространения исходной точки
монтирования всегда равен индивидуальному.
.SS "Семантики размонтирования"
Предположим, что для размонтирования точки используется следующая команда:
.PP
.in +4n
.EX
unmount A
.EE
.in
.PP
.\"
Здесь \fIA\fP точка монтирования на \fIB/b\fP, где \fIB\fP — родительская точка
монтирования и \fIb\fP — подкаталог в точке монтирования \fIB\fP. Если \fBB\fP имеет
общий тип распространения, то все последние монтирования в \fIb\fP, получающие
события от точки монтирования \fIB\fP и не имеющие подмонтирований внутри,
будут размонтированы.
.SS "Метка /proc/[pid]/mountinfo propagate_from"
Метка \fIpropagate_from:X\fP появляется в необязательных полях записи
\fI/proc/[pid]/mountinfo\fP в случаях, когда процесс не может видеть
непосредственного мастера (т. е., путь к мастеру недоступен из корневого
каталога файловой системы) и поэтому не может определить цепочку
распространения между точками монтирования, которые он может видеть.
.PP
В следующем примере сначала создаётся двусвязная цепочка мастер\-подчинённый
между точками монтирования \fI/mnt\fP, \fI/tmp/etc\fP и \fI/mnt/tmp/etc\fP. Затем
используется команда \fBchroot\fP(1), чтобы сделать точку монтирования
\fI/tmp/etc\fP недоступной из корневого каталога, что создаёт ситуацию, где
мастер для \fI/mnt/tmp/etc\fP недоступен из (нового) корневого каталога
процесса.
.PP
Сначала привяжем корневой каталог в \fI/mnt\fP, а затем привяжем \fI/proc\fP в
\fI/mnt/proc\fP, чтобы после этого в правильном месте chroot\-окружения для
\fBchroot\fP(1) осталась доступной файловая система \fBproc\fP(5).
.PP
.in +4n
.EX
# \fBmkdir \-p /mnt/proc\fP
# \fBmount \-\-bind / /mnt\fP
# \fBmount \-\-bind /proc /mnt/proc\fP
.EE
.in
.PP
Теперь убедимся, что точка монтирования \fI/mnt\fP является общей в новой
равноправной группе (без членов):
.PP
.in +4n
.EX
# \fBmount \-\-make\-private /mnt\fP  # Изолировать от любой предыдущей группы
# \fBmount \-\-make\-shared /mnt\fP
# \fBcat /proc/self/mountinfo | grep \(aq/mnt\(aq | sed \(aqs/ \- .*//\(aq\fP
239 61 8:2 / /mnt ... shared:102
248 239 0:4 / /mnt/proc ... shared:5
.EE
.in
.PP
Теперь привяжем \fI/mnt/etc\fP к \fI/tmp/etc\fP:
.PP
.in +4n
.EX
# \fBmkdir \-p /tmp/etc\fP
# \fBmount \-\-bind /mnt/etc /tmp/etc\fP
# \fBcat /proc/self/mountinfo | egrep \(aq/mnt|/tmp/\(aq | sed \(aqs/ \- .*//\(aq\fP
239 61 8:2 / /mnt ... shared:102
248 239 0:4 / /mnt/proc ... shared:5
267 40 8:2 /etc /tmp/etc ... shared:102
.EE
.in
.PP
Первоначально, эти две точки монтирования были в одной равноправной группе,
но мы сделали \fI/tmp/etc\fP подчинённой \fI/mnt/etc\fP, а затем сделали
\fI/tmp/etc\fP общей, так чтобы она могла распространять события следующему
подчинённому в цепочке:
.PP
.in +4n
.EX
# \fBmount \-\-make\-slave /tmp/etc\fP
# \fBmount \-\-make\-shared /tmp/etc\fP
# \fBcat /proc/self/mountinfo | egrep \(aq/mnt|/tmp/\(aq | sed \(aqs/ \- .*//\(aq\fP
239 61 8:2 / /mnt ... shared:102
248 239 0:4 / /mnt/proc ... shared:5
267 40 8:2 /etc /tmp/etc ... shared:105 master:102
.EE
.in
.PP
Затем мы привязали \fI/tmp/etc\fP в \fI/mnt/tmp/etc\fP. Опять же, две точки
монтирования первоначально были в одной равноправной группе, но позднее мы
сделали \fI/mnt/tmp/etc\fP подчинённой \fI/tmp/etc\fP:
.PP
.in +4n
.EX
# \fBmkdir \-p /mnt/tmp/etc\fP
# \fBmount \-\-bind /tmp/etc /mnt/tmp/etc\fP
# \fBmount \-\-make\-slave /mnt/tmp/etc\fP
# \fBcat /proc/self/mountinfo | egrep \(aq/mnt|/tmp/\(aq | sed \(aqs/ \- .*//\(aq\fP
239 61 8:2 / /mnt ... shared:102
248 239 0:4 / /mnt/proc ... shared:5
267 40 8:2 /etc /tmp/etc ... shared:105 master:102
273 239 8:2 /etc /mnt/tmp/etc ... master:105
.EE
.in
.PP
Из показанного выше можно видеть, что \fI/mnt\fP является главной для
подчинённой \fI/tmp/etc\fP, которая, в свою очередь, является главной для
подчинённой \fI/mnt/tmp/etc\fP.
.PP
Теперь выполним \fBchroot\fP(1) в каталог \fI/mnt\fP, который делает точку
монтирования с ID 267 недоступной из (нового корневого каталога:
.PP
.in +4n
.EX
# \fBchroot /mnt\fP
.EE
.in
.PP
Если мы проверим состояние точек монтирования внутри окружения chroot, то
увидим следующее:
.PP
.in +4n
.EX
# \fBcat /proc/self/mountinfo | sed \(aqs/ \- .*//\(aq\fP
239 61 8:2 / / ... shared:102
248 239 0:4 / /proc ... shared:5
273 239 8:2 /etc /tmp/etc ... master:105 propagate_from:102
.EE
.in
.PP
.\"
Здесь мы видим, что точка монтирования с ID 273 является подчинённой для
главной, которая входит в равноправную группу 105. Точка монтирования этой
главной недоступна и поэтому появилась метка \fIpropagate_from\fP,
показывающая, что идентификатор ближайшей ведущей равноправной группы
(т. е., ближайшая достижимая точка монтирования в подчинённой цепи) равен
102 (соответствует точке монтирования \fI/mnt\fP до выполнения \fBchroot\fP(1)).
.SH ВЕРСИИ
Пространство имён монтирования впервые появилось в Linux 2.4.19.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
.\"
Пространства имён есть только в Linux.
.SH ЗАМЕЧАНИЯ
Тип распространения, назначаемый новой точке монтирования, зависит от типа
распространения родительской точки монтирования. Если точка монтирования
имеет родителя (т. е., является не корневой точкой монтирования) и тип
распространения родителя — \fBMS_SHARED\fP, то тип распространения новой точки
монтирования будет также \fBMS_SHARED\fP. В противном случае типом новой точки
монтирования будет \fBMS_PRIVATE\fP.
.PP
Несмотря на то, что тип распространения по умолчанию для новой точки
монтирования во многих случаях равен \fBMS_PRIVATE\fP, обычно, тип \fBMS_SHARED\fP
полезнее. По этой причине, при запуске системы \fBsystemd\fP(1) автоматически
перемонтирует все точки монтирования как \fBMS_SHARED\fP. Таким образом, в
современных системах типом распространения по умолчанию практически является
\fBMS_SHARED\fP.
.PP
При создании пространства имён монтирования с помощью \fBunshare\fP(1) чаще
всего требуется создать полную изоляцию точек монтирования в новом
пространстве имён, и \fBunshare\fP(1) (начиная с \fIutil\-linux\fP версии 2.27)
отменяет изменения \fBsystemd\fP(1), делая все точки монтирования
индивидуальными в новом пространстве имён. То есть \fBunshare\fP(1) в новом
пространстве имён монтирования выполняет эквивалент следующего:
.PP
.in +4n
.EX
mount \-\-make\-rprivate /
.EE
.in
.PP
Чтобы этого не происходило в \fBunshare\fP(1) можно использовать параметр
\fI\-\-propagation\ unchanged\fP.
.PP
Описание типов распространения при перемещении точек монтирования
(\fBMS_MOVE\fP) и создании привязок монтирования (\fBMS_BIND\fP) смотрите в
\fIDocumentation/filesystems/sharedsubtree.txt\fP.
.SH ПРИМЕР
Смотрите \fBpivot_root\fP(2).
.SH "СМОТРИТЕ ТАКЖЕ"
\fBunshare\fP(1), \fBclone\fP(2), \fBmount\fP(2), \fBpivot_root\fP(2), \fBsetns\fP(2),
\fBumount\fP(2), \fBunshare\fP(2), \fBproc\fP(5), \fBnamespaces\fP(7),
\fBuser_namespaces\fP(7), \fBfindmnt\fP(8), \fBpivot_root\fP(8)
.PP
Файл \fIDocumentation/filesystems/sharedsubtree.txt\fP в дереве исходного кода
ядра Linux.
