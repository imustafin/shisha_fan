.\" -*- mode: troff; coding: UTF-8 -*-
.\" Copyright (c) 1998 Andries Brouwer
.\"
.\" %%%LICENSE_START(GPLv2+_DOC_FULL)
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, see
.\" <http://www.gnu.org/licenses/>.
.\" %%%LICENSE_END
.\"
.\" 2003-08-24 fix for / by John Kristoff + joey
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH GLOB 7 2016\-10\-08 Linux "Руководство программиста Linux"
.SH ИМЯ
glob \- шаблоны полных имён файлов
.SH ОПИСАНИЕ
Давным\-давно, во времена UNIX\ V6, существовала программа \fI/etc/glob\fP,
которая могла раскрывать шаблоны подстановки. Очень скоро она стала
встроенной функцией командной оболочки.
.PP
В наши дни существует библиотечная функция \fBglob\fP(3), которая выполняет эту
задачу для пользовательских программ.
.PP
Следующие правила приведены в соответствии со стандартом POSIX.2, 3.13.
.SS "Тип шаблона"
Строка считается шаблоном подстановки, если содержит в себе один из символов
\(aq?\(aq, \(aq*\(aq или \(aq[\(aq. Globbing — это операция, которая
раскрывает шаблон подстановки в список имён путей, соответствующих данному
шаблону. Соответствие определяется следующими правилами:
.PP
\(aq?\(aq (без учета кавычек) соответствует любому одному символу.
.PP
\(aq*\(aq (без учета кавычек) соответствует любой строке, включая пустую
строку.
.PP
\fBКлассы символов\fP
.PP
Выражение «\fI[...]\fP», где первый символ после открывающей \(aq[\(aq \- не
равен \(aq!\(aq, соответствует одному символу, который может быть любым
символом из набора, находящегося внутри скобок. Строка внутри скобок не
может быть пустой, таким образом, \(aq]\(aq также может находиться внутри
скобок и выступать в качестве первого символа (то есть «\fI[][!]\fP» будет
соответствовать трем символам \(aq[\(aq, \(aq]\(aq и \(aq!\(aq).
.PP
\fBДиапазоны\fP
.PP
Два символа, разделённые \(aq\-\(aq, образуют особое выражение — диапазон (то
есть «\fI[A\-Fa\-f0\-9]\fP» будет эквивалентен записи
«\fI[ABCDEFabcdef0123456789]\fP»). Сюда также может входить и сам \(aq\-\(aq в
качестве начального или конечного символа (то есть «\fI[]\-]\fP» будет
соответствовать только двум символам \- \(aq]\(aq и \(aq\-\(aq, а «\fI[\-\-0]\fP» —
трем символам: \(aq\-\(aq, \(aq.\(aq, \(aq0\(aq, так как \(aq/\(aq не может
быть использован).
.PP
\fBРазность множеств\fP
.PP
Выражение «\fI[!...]\fP» соответствует одному любому символу, который не входит
в множество, получаемое путем удаления первого  \(aq!\(aq (то есть
«\fI[!]a\-]\fP» будет соответствовать любому одному символу за исключением
\(aq]\(aq, \(aqa\(aq и \(aq\-\(aq).
.PP
Специальное значение \(aq?\(aq, \(aq*\(aq и \(aq[\(aq может быть
аннулировано путём экранирования их обратной косой чертой или, в случае,
когда они являются частью оболочки командной строки, путём заключения их в
кавычки. Внутри квадратных скобок эти символы не имеют специального
значения. Таким образом, «\fI[[?*\e]\fP» совпадает с четырьмя символами
\(aq[\(aq, \(aq?\(aq, \(aq*\(aq и \(aq\e\(aq.
.SS "Полные составные пути"
Раскрытие (globbing) применяется к каждой части полного составного имени
файла отдельно. Символ \(aq/\(aq в полном имени файла не может совпадать с
шаблоном \(aq?\(aq или \(aq*\(aq, а только с диапазоном подобным
«\fI[.\-0]\fP». Диапазон не может включать в себя символ \(aq/\(aq, поскольку
это будет считаться синтаксической ошибкой (в POSIX требуется, чтобы
синтаксически некорректные шаблоны не изменялись).
.PP
Если имя файла начинается с \(aq.\(aq, то этот символ должен быть
обязательно указан в шаблоне (таким образом, \fIrm\ *\fP не удалит .profile, а
\fItar\ c\ *\fP заархивирует не все файлы; лучше использовать \fItar\ c\ .\fP).
.SS "Пустые списки"
Выше было приведено простое и замечательное правило из оригинального
определения UNIX: «раскрытие шаблона — это операция, преобразующая шаблон в
список соответствующих ему полных имён файлов». Оно допускает существование
шаблона, соответствующего пустому списку, например:
.PP
.nf
    xv \-wait 0 *.gif *.jpg
.fi
.PP
где, возможно, файлы *.gif на самом деле отсутствуют (и это не
ошибка). Несмотря на это, в POSIX требуется, чтобы шаблон, синтаксически
неправильный или раскрывающийся в пустой список путей к файлам, оставался
без изменений. В \fIbash\fP можно принудительно включить классическое поведение
с помощью команды:
.PP
.\" In Bash v1, by setting allow_null_glob_expansion=true
    shopt \-s nullglob
.PP
Подобная проблема может проявиться вновь. Например, там, где в старых
сценариях использовалось
.PP
.nf
    rm \`find . \-name "*~"\`
.fi
.PP
в новых сценариях используется
.PP
.nf
    rm \-f nosuchfile \`find . \-name "*~"\`
.fi
.PP
для избежания сообщений об ошибках \fIrm\fP, вызванного с пустым списком
аргументов.
.SH ЗАМЕЧАНИЯ
.SS "Регулярные выражения"
Заметим, что шаблоны не являются регулярными выражениями, хотя и
похожи. Во\-первых, они используются для выявления совпадений в именах
файлов, а не в тексте. Во\-вторых, используются разные соглашения: например,
регулярное выражение \(aq*\(aq означает ноль или более копий предшествующему
символу.
.PP
Теперь, когда в квадратных скобках у регулярных выражений для отрицания
используется \(aq^\(aq, в POSIX оговаривается, что эффект шаблона
«\fI[^...]\fP» не определён.
.SS "Классы символов и интернационализация"
Изначально диапазоны были определены для символов ASCII, так что «\fI[\ \-%]\fP»
соответствует «\fI[\ !"#$%]\fP», а «\fI[a\-z]\fP» соответствует «любому символу
нижнего регистра». В некоторых реализациях UNIX это обобщено так, что
диапазон X\-Y соответствует всем символам, коды которых находятся между X и
Y. Однако, это требует знания способа кодирования символов в локальной
системе и, более того, не удобно, если последовательность сортировки для
локального алфавита отличается от последовательности кодов символов. Поэтому
в POSIX значительно расширено обозначение квадратных скобок как для шаблонов
файлов, так и для регулярных выражений. Выше встретилось три типа выражений
в скобках: отрицание (i), указанный явно символ (ii) и диапазон (iii). В
POSIX диапазоны определены в более удобном с точки зрения
интернационализации виде, а также добавлены три новых типа:
.PP
(iii) Диапазоны X\-Y включают в себя все символы, находящиеся между X и Y
(включительно) в соответствии с текущей последовательностью сортировки,
определённой в категории \fBLC_COLLATE\fP текущей локали.
.PP
(iv) Именованные классы символов, такие, как:
.PP
.nf
[:alnum:]  [:alpha:]  [:blank:]  [:cntrl:]
[:digit:]  [:graph:]  [:lower:]  [:print:]
[:punct:]  [:space:]  [:upper:]  [:xdigit:]
.fi
.PP
Благодаря им можно указать значение «\fI[[:lower:]]\fP» вместо «\fI[a\-z]\fP», и
это будет работать для Дании, где в алфавите есть три буквы, стоящие после
«z». Эти классы символов определяются категорией \fBLC_CTYPE\fP текущей локали.
.PP
(v) Сортировочные символы, такие, как «\fI[.ch.]\fP» или «\fI[.a\-acute.]\fP»,
строка которых, лежащая между «\fI[.\fP» и «\fI.]\fP», является элементом
сортировки, определённым для текущей локали. Заметим, что это может быть
многосимвольный элемент.
.PP
(vi) Классы эквивалентности, такие, как «\fI[=a=]\fP», где строка между «\fI[=\fP»
и «\fI=]\fP» является любым элементом сортировки из своего класса
эквивалентности, определённого в текущей локали. Например, «\fI[[=a=]]\fP»
может быть эквивалентно «\fI[a\('a\(`a\(:a\(^a]\fP», то есть
«\fI[a[.a\-acute.][.a\-grave.][.a\-umlaut.][.a\-circumflex.]]\fP».
.SH "СМОТРИТЕ ТАКЖЕ"
\fBsh\fP(1), \fBfnmatch\fP(3), \fBglob\fP(3), \fBlocale\fP(7), \fBregex\fP(7)
