.\" -*- mode: troff; coding: UTF-8 -*-
.\"
.\" Copyright (C) 2014 Red Hat, Inc. All Rights Reserved.
.\" Written by David Howells (dhowells@redhat.com)
.\" and Copyright (C) 2016 Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" %%%LICENSE_START(GPLv2+_SW_ONEPARA)
.\" This program is free software; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License
.\" as published by the Free Software Foundation; either version
.\" 2 of the License, or (at your option) any later version.
.\" %%%LICENSE_END
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH KEYRINGS 7 2017\-09\-15 Linux "Руководство программиста Linux"
.SH ИМЯ
keyrings \- средство управления и хранения ключей в ядре
.SH ОПИСАНИЕ
Средство управления ключами Linux позволяет различным компонентам ядра
хранить или кэшировать охраняемые безопасности, ключи аутентификации, ключи
шифрования и другие данные в ядре.
.PP
Через системные вызовы пользовательские программы могут управлять этими
объектами, а также использовать это средство для своих собственных целей;
смотрите \fBadd_key\fP(2), \fBrequest_key\fP(2) и \fBkeyctl\fP(2).
.PP
.\"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Для работы с данными предоставляется библиотека и пользовательские
программы. Подробности смотрите в \fBkeyctl\fP(1), \fBkeyctl\fP(3) и
\fBkeyutils\fP(7).
.SS Ключи
Ключ имеет следующие атрибуты:
.TP 
Серийный номер (ID)
Уникальное целое число, используется в системных вызовах для ссылки на ключ.
.TP 
Тип
Тип ключа определяет какие данные можно хранить в ключе, как будет
обрабатываться содержимое ключа и как будут использованы полезные (payload)
данные.
.IP
Доступно несколько типов ключей общего назначения, а также специальные типы,
определённые компонентами ядра.
.TP 
Описание (имя)
Описание ключа — пригодная для печати строка, которая используется в условии
поиска ключа (вместе с типом), а также как отображаемое имя. При поиске
описание может совпадать как полностью так и частично.
.TP 
Полезные данные (payload)
Полезные данные это то, что хранит ключ. Обычно, они указываются при
создании ключа, но возможно, что для завершения создания ядро сделает запрос
в пользовательское пространство, если ключ был неизвестен ядру до
запроса. Подробности смотрите в \fBrequest_key\fP(2).
.IP
Полезные данные ключа можно читать и изменять, если это поддерживается типом
ключа и у вызывающего есть права.
.TP 
Права доступа
Как и у файлов, каждый ключ содержит ID пользователя\-владельца, ID
группы\-владельца и метку безопасности. Также каждый ключ имеет набор прав
доступа, хотя и больший чем у обычного файла UNIX, и, дополнительно к ним,
категорию — владельца (possessor) — не являющейся обычным пользователем,
группой и остальными (смотрите \fIВладение\fP ниже).
.IP
Заметим, что на ключи действуют квоты, так как для них требуется
невытесняемая память ядра. Квота списывается с пользовательского ID
владельца.
.TP 
Срок действия
Каждый ключ имеет срок действия. Когда срок заканчивается, ключ помечается
как просроченный и доступ к нему завершается ошибкой \fBEKEYEXPIRED\fP. Если
его не удалить, изменить или заменить, то после заданного количества времени
просроченный ключ автоматически удаляется (сборка мусора) вместе со всеми
ссылками на него и попытка доступа к ключу завершается ошибкой \fBENOKEY\fP.
.TP 
Число ссылок
.\"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
У каждого ключа есть счётчик ссылок. На ключи ссылаются из связок ключей,
принадлежащих активным на данный момент пользователям и из мандатов
процесса. Когда счётчик ссылок становится равным нулю, ключ планируется для
сборки мусора.
.SS "Типы ключей"
Ядро предоставляет несколько основных типов ключей:
.TP 
\fI"keyring"\fP
'\" Note that keyrings use different fields in struct key in order to store
'\" their data - index_key instead of type/description and name_link/keys
'\" instead of payload.
Связки ключей — это специальные ключи, которые хранят набор ссылок на другие
ключи (включая другие связки ключей), так же как каталоги хранят ссылки на
файлы. Основное предназначение связки ключей — не дать другим ключам попасть
в мусор по причине того, что они нигде не используются.
.IP
Связки ключей с описаниями (именами), которые начинаются с точки
(\(aq.\(aq), зарезервированы для использования реализацией.
.TP 
\fI"user"\fP
Тип ключа общего назначения. Ключ полностью находится в памяти
ядра. Полезные данные можно читать и изменять из пользовательских
приложений.
.IP
Полезные данные ключей этого типа представляют собой данные произвольной
структуры (blob) размером до 32767 байт.
.IP
Для имени можно использовать любую корректную строку, хотя предпочтительно
начинать его с отделяемого двоеточием префикса, представляющего службу,
которой интересен ключ (пример: \fI"afs:mykey"\fP).
.TP 
\fI"logon"\fP (начиная с Linux 3.3)
.\" commit 9f6ed2ca257fa8650b876377833e6f14e272848b
Данный тип ключа почти такой же как \fI"user"\fP, но не предоставляет чтения
(т. е., операции \fBkeyctl\fP(2)  \fBKEYCTL_READ\fP), и поэтому полезные данные
ключа недоступны из пользовательского пространства. Он подходит для хранения
пары имя пользователя\-пароль, которые должны быть недоступны из
пользовательского пространства.
.IP
Описание ключа \fI"logon"\fP \fIдолжно начинатьсяс непустого отделённого
двоеточием префиса\fP; его назначение — обозначить службу, которой принадлежит
ключ (заметим, что это отличается от ключей типа \fI"user"\fP, у которых
префикс считается необязательным).
.TP 
\fI"big_key"\fP (начиная с Linux 3.13)
.\" commit ab3c3587f8cda9083209a61dbe3a4407d3cada10
Данный тип ключа подобен \fI"user"\fP, но может содержать полезные данные
размером до 1\ МиБ. Он полезен для хранения таких данных как кэш билетов
Kerberos.
.IP
.\" commit 13100a72f40f5748a04017e0ab3df4cf27c809ef
Данные полезной нагрузки может сохраняться в файловой системе tmpfs, а не в
памяти ядра, если размер данных превышает накладные расходы на хранение
данных в файловой системе (хранение данных в файловой системе требует
выделения места в ядре под структуры файловой системы. Размер этих структур
определяется размером границы, после которой используется хранение в
tmpfs). Начиная с Linux 4.8, данные полезной нагрузки при хранении в tmpfs
шифруются и, таким образом, не записываются в пространство подкачки в не
шифрованном виде.
.PP
Существуют также другие специальные типы ключей, но здесь они не описаны,
так как не предназначены для использования в обычном пользовательском
пространстве.
.PP
.\"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Имена связок ключей, которые начинаются с точки (\(aq.\(aq), зарезервированы
для использования реализацией.
.SS "Связки ключей"
Как упоминалось ранее, связки ключей являются специальным типом ключей,
которые содержат ссылки на другие ключи (которые могут включать другие
связки ключей). Ключи могут быть связаны с несколькими связками
ключей. Связки ключей могут считаться аналогом каталогов UNIX, где в каждом
каталоге содержится набор жёстких ссылок на файлы.
.PP
Операции (системные вызовы) применяемые только к связкам ключей:
.IP Добавление
Ключ может добавляться в связку ключей системным вызовом, создающим
ключи. Это предотвращает немедленное удаление нового ключа после того, как
системный вызов удаляет свою последнюю ссылку на ключ.
.IP Присоединение
В связку ключей может быть добавлена ссылка, которая указывает на уже
известный ключ, при этом контролируется отсутствие ссылок на саму связку.
.IP Отсоединение
Ссылка может быть удалена из связки ключей. При удалении последней ссылки на
ключ, он планируется к удалению сборщиком мусора.
.IP Очистка
Из связки ключей могут удаляться все ссылки.
.IP Поиск
Связка ключей может считаться корнем дерева или поддерева в котором связки
ключей считаются ветвями, а обычные ключи — листьями. В таком дереве может
выполнять поиск ключа по типу и описанию.
.PP
.\"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Подробности смотрите в \fBkeyctl_clear\fP(3), \fBkeyctl_link\fP(3),
\fBkeyctl_search\fP(3) и \fBkeyctl_unlink\fP(3).
.SS "Закрепляющие ключи"
Если ключ не используется ядром, чтобы не быть удалённым сборщиком мусора,
он должен быть закреплён для сохранения положительного значения своего
счётчика ссылок.
.PP
Для закрепления ключей используются связки ключей: каждая связь представляет
ссылку на ключ. Заметим, что сами связки ключей — тоже ключи и требуют
закрепления, чтобы не быть удалёнными сборщиком мусора.
.PP
В ядре доступно несколько закрепляющих связок ключей. Заметим, что некоторые
из них будут созданы только в момент первого обращения.
.TP 
Связки ключей процесса
Мандаты процесса являются связками ключей со специальной семантикой. Эти
связки ключей существуют пока существуют мандаты, то есть, обычно, пока
существует процесс.
.IP
Существует три связки ключей с различными правилами наследования/общего
пользования: \fBsession\-keyring\fP(7) (наследуется и используется всеми
дочерними процессами), \fBprocess\-keyring\fP(7) (используется всеми нитями
процесса) и \fBthread\-keyring\fP(7) (доступна только определённой нити).
.IP
Альтернативой использованию реальных ID связок ключей в вызовах
\fBadd_key\fP(2), \fBkeyctl\fP(2) и \fBrequest_key\fP(2) можно указывать значения
специальных связок ключей \fBKEY_SPEC_SESSION_KEYRING\fP,
\fBKEY_SPEC_PROCESS_KEYRING\fP и \fBKEY_SPEC_THREAD_KEYRING\fP, которые ссылаются
на экземпляры ключей, принадлежащие вызывающему.
.TP 
Пользовательские связки ключей
Для каждого UID, известного ядру, имеется запись, содержащая две связки
ключей: \fBuser\-keyring\fP(7) и \fBuser\-session\-keyring\fP(7). Они существуют пока
в ядре существует запись UID.
.IP
Альтернативой использованию реальных ID связок ключей в вызовах
\fBadd_key\fP(2), \fBkeyctl\fP(2) и \fBrequest_key\fP(2) можно указывать значения
специальных связок ключей \fBKEY_SPEC_USER_KEYRING\fP и
\fBKEY_SPEC_USER_SESSION_KEYRING\fP, которые ссылаются на экземпляры ключей,
принадлежащие вызывающему.
.IP
Ссылка на пользовательскую связку ключей помещается в связку ключей нового
сеанса с помощью \fBpam_keyinit\fP(8) в момент начала нового сеанса входа.
.TP 
Постоянные связки ключей
Для каждого UID системы доступна \fBpersistent\-keyring\fP(7). Она может
существовать и после окончания жизни записи UID, упомянутой ранее, но её
срок службы устанавливается таким образом, чтобы она автоматически очищалась
после указанного времени. Постоянные связки ключей позволяют, например,
сценариям \fBcron\fP(8) использовать мандаты, остающиеся в постоянной связке
ключей после выхода пользователя.
.IP
Заметим, что срок службы постоянной связки ключей сбрасывается каждый раз
после запроса постоянной связки ключей.
.TP 
Специальные связки ключей
Существуют специальные связки ключей, принадлежащие ядру, которые могут
хранить закрепляющие ключи для специальных целей. Например, \fIsystem
keyring\fP используется для хранения ключей шифрования для модуля сличения
подписи.
.IP
Эти специальные связки ключей, обычно, закрыты для прямого изменения из
пользовательского пространства.
.PP
.\"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Первоначально планировавшиеся «групповые связки ключей» для хранения ключей,
связанных с каждым GID, известным ядру, пока не реализованы, и, вероятно, не
будут. Тем не менее, для этой связки ключей определена константа
\fBKEY_SPEC_GROUP_KEYRING\fP.
.SS "Владение (possession)"
Концепция владения важна для понимания модели безопасности связки
ключей. Владеет ли нить ключом определяется следующими правилами:
.IP (1) 4
Ключ или связка ключей, на которую у вызывающего нет права \fIпоиска\fP,
игнорируется во всех последующих правилах.
.IP (2)
Нить непосредственно владеет своими \fBsession\-keyring\fP(7),
\fBprocess\-keyring\fP(7) и \fBthread\-keyring\fP(7), так как на эти связки ключей
есть ссылка из её мандатов.
.IP (3)
Если связкой ключей кто\-то владеет, то он владеет всеми ключами в связке.
.IP (4)
Если ключ в связке связан сам с собой в связке, то правило (3) применяется
рекурсивно.
.IP (5)
Если процесс вызван из ядра для создания ключа (смотрите \fBrequest_key\fP(2)),
то оно также владеет связкой ключей вызвавшего как в правиле (1) если бы он
был вызывающим.
.PP
Заметим, что владение не является фундаментальным свойством ключа и
вычисляется каждый раз при необходимости.
.PP
Механизм владения разработан для того, что бы программы с set\-user\-ID,
запускаемые, например, из оболочки, имели доступ к пользовательским
ключам.Права предоставляются владельцу ключа, в то время как доступ к ключам
по UID и GID ключа не дают такого доступа.
.PP
.\"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Когда создаётся связка ключей сеанса, \fBpam_keyinit\fP(8) добавляет связь с
\fBuser\-keyring\fP(7), то есть по умолчанию даёт право владения
пользовательской связкой ключей и всем её содержимым.
.SS "Права доступа"
Каждый ключ имеет следующие атрибуты, относящиеся к безопасности:
.IP * 3
Пользовательский идентификатор владельца
.IP *
Идентификатор группы, которой разрешён доступ к ключу
.IP *
Метка безопасности
.IP *
Маска доступа
.PP
Маска доступа содержит четыре набора прав. Первые три набора
взаимоисключающие. Только по одному из них выполняются определённые
проверки. Есть три набора прав, в порядке уменьшения приоритета:
.IP \fIпользователь\fP
Набор предоставляемых прав, если пользовательский ID ключа совпадает с
пользовательским ID вызывающего из файловой системы.
.IP \fIгруппа\fP
Набор предоставляемых прав, если пользовательский ID ключа не совпадает и
групповой ID ключа совпадает с GID вызывающего из файловой системы или одним
из GID его дополнительных групп.
.IP \fIостальные\fP
Набор предоставляемых прав, если не совпадает ни пользовательский ID, ни
групповой ID ключа.
.PP
Четвёртый набор прав:
.IP \fIвладелец\fP
Набор предоставляемых прав, если определено, что ключом владеет вызывающий.
.PP
Полный набор прав на ключ представляет собой объединение одного из первых
трёх наборов и четвёртого набор, если для ключа задано владение.
.PP
Набор прав, который может быть предоставлен каждой из четырёх масок:
.TP 
\fIпросмотр\fP
Для чтения доступны атрибуты ключа. К ним относятся тип, описание и права
доступа (кроме метки безопасности).
.TP 
\fIчтение\fP
Для ключа: можно читать полезные данные ключа. Для связки ключей: можно
читать список серийных номеров (ключей), с которыми связка ключей имеет
связь.
.TP 
\fIзапись\fP
Можно изменять полезные данные и отзывать ключ. Для связки ключей: можно
добавлять и удалять связи из связки ключей, а также полностью очищать связку
ключей (удаление всех связей).
.TP 
\fIпоиск\fP
Для ключа (или связки ключей): ключ можно найти поиском. Для связки ключей:
можно найти ключи и связки ключей, связанные в связку ключей.
.TP 
\fIсвязь\fP
Из связки ключей можно установить связь с ключом. Для начальной связи с
ключом, устанавливаемой при создании ключа, этого не требуется.
.TP 
\fIустановка атрибутов\fP
Можно изменять атрибуты владения и метку безопасности, задавать срок
действия ключа и отзывать ключ.
.PP
Кроме прав, доступ к ключа также быть заблокирован любым активным модулем
безопасности Linux(LSM), если это прописано в его политике. Ключу LSM может
назначить метку безопасности или другой атрибут; эту метку можно получить с
помощью \fBkeyctl_get_security\fP(3).
.PP
.\"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Подробности смотрите в \fBkeyctl_chown\fP(3), \fBkeyctl_describe\fP(3),
\fBkeyctl_get_security\fP(3), \fBkeyctl_setperm\fP(3) и \fBselinux\fP(8).
.SS "Поиск ключей"
Одним из основных свойств управления ключами Linux является возможность
поиска ключей, хранимых процессом. Системный вызов \fBrequest_key\fP(2)
является основным методом для приложений пользовательского пространства для
поиска ключа (для использования ключей во внутренних компонентах у ядра есть
что\-то похожее).
.PP
Алгоритм поиска работает так:
.IP (1) 4
Связки ключей процесса просматривается в следующем порядке:
\fBthread\-keyring\fP(7) нити, если существует, \fBprocess\-keyring\fP(7), если
существует, а затем \fBsession\-keyring\fP(7), если существует или
\fBuser\-session\-keyring\fP(7), если существует.
.IP (2)
Если вызывающий является процессом, который был вызван механизмом верхнего
вызова 9upcall) \fBrequest_key\fP(2), то связки ключей первоначального
вызывающего также будут просматриваться \fBrequest_key\fP(2).
.IP (3)
Поиск в дереве связки ключей выполняется «сначала вширь»: в каждой связка
ключей просматривается до первого совпадения, затем просматриваются связки
ключей, на которые ссылается эта связка ключей.
.IP (4)
Если найденный ключ действителен, то поиск завершается и возвращается этот
ключ.
.IP (5)
Если найденный ключ находится в состоянии ошибки, то это состояние ошибки
запоминается и поиск продолжается.
.IP (6)
Если действительный ключ не найден, то возвращается первое запомненное
состояние ошибки; в противном случае возвращается ошибка \fBENOKEY\fP.
.PP
Также можно проводить поиск в определённой связке ключей, в этом случае
выполняются только шаги с (3) по (6).
.PP
.\"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Подробности смотрите в \fBrequest_key\fP(2) и \fBkeyctl_search\fP(3).
.SS "Создание ключа по требованию"
Если ключ невозможно найти, то \fBrequest_key\fP(2), если указан аргумент
\fIcallout_info\fP, создаст новый ключ и затем сделает вызов в пользовательское
пространство для его инициализации. Это позволяет создавать ключи только при
необходимости.
.PP
Как правило, при этом ядро создаёт новый процесс с выполняемой программой
\fBrequest\-key\fP(8), которая, в свою очередь, запустит соответствующий
обработчик в соответствии со своими настройками.
.PP
Обработчику передаётся специальный ключ авторизации, который позволяет
только этому обработчику инициализировать новый ключ. Он также используется
для разрешения поиска, выполняемого программой\-обработчиком, в связках
ключах запрашивающего.
.PP
.\"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Подробности смотрите в \fBrequest_key\fP(2), \fBkeyctl_assume_authority\fP(3),
\fBkeyctl_instantiate\fP(3), \fBkeyctl_negate\fP(3), \fBkeyctl_reject\fP(3),
\fBrequest\-key\fP(8) и \fBrequest\-key.conf\fP(5).
.SS "Файлы в /proc"
Ядро предоставляет в \fI/proc\fP различные файлы, через которые отображается
информацию о ключах и определяются ограничения на использование ключей.
.TP 
\fI/proc/keys\fP (начиная с Linux 2.6.10)
.\" David Howells, Dec 2016 linux-man@:
.\" This [The thread need not possess the key for it to be visible in
.\" this file.] is correct.  See proc_keys_show() in security/keys/proc.c:
.\"
.\"	rc = key_task_permission(key_ref, ctx.cred, KEY_NEED_VIEW);
.\"	if (rc < 0)
.\"		return 0;
.\"
.\"Possibly it shouldn't be, but for now it is.
.\"
Этот файл отображает список ключей, на которые у читающей нити есть право
\fIпросмотра\fP, предоставляя различную информацию о каждом ключе. От нити не
требуется владения ключом, чтобы он был видим в этом файле.
.IP
В этот список включаются только те ключи, на которые у читающего процесса
есть право \fIпросмотра\fP (независимо от того, владеет он ими или
нет). Проверки безопасности LSM также выполняются и могут отфильтровать
какие\-то ключи, которые процесс не авторизован просматривать.
.IP
Пример содержимого этого файла (колонки пронумерованы для ссылок далее):
.IP
.in 0n
.EX
  (1)     (2)     (3)(4)    (5)     (6)   (7)   (8)        (9)
009a2028 I\-\-Q\-\-\-   1 perm 3f010000  1000  1000 user     krb_ccache:primary: 12
1806c4ba I\-\-Q\-\-\-   1 perm 3f010000  1000  1000 keyring  _pid: 2
25d3a08f I\-\-Q\-\-\-   1 perm 1f3f0000  1000 65534 keyring  _uid_ses.1000: 1
28576bd8 I\-\-Q\-\-\-   3 perm 3f010000  1000  1000 keyring  _krb: 1
2c546d21 I\-\-Q\-\-\- 190 perm 3f030000  1000  1000 keyring  _ses: 2
30a4e0be I\-\-\-\-\-\-   4   2d 1f030000  1000 65534 keyring  _persistent.1000: 1
32100fab I\-\-Q\-\-\-   4 perm 1f3f0000  1000 65534 keyring  _uid.1000: 2
32a387ea I\-\-Q\-\-\-   1 perm 3f010000  1000  1000 keyring  _pid: 2
3ce56aea I\-\-Q\-\-\-   5 perm 3f030000  1000  1000 keyring  _ses: 1
.EE
.in
.IP
Поля каждой строки в этом файле имеют следующее назначение:
.RS
.TP 
Идентификатор (1)
Идентификатор (серийный номер) ключа (шестнадцатеричное число).
.TP 
Флаги (2)
Набор флагов, описывающих состояние ключа:
.RS
.IP I 4
.\" KEY_FLAG_INSTANTIATED
Ключ инициализирован.
.IP R
.\" KEY_FLAG_REVOKED
Ключ отозван.
.IP D
.\" KEY_FLAG_DEAD
.\" unregister_key_type() in the kernel source
Ключ бездействующий (dead, т. .е, имеет незарегистрированный тип ключа. Ключ
может ненадолго находиться в этом состоянии при сборе мусора).
.IP Q
.\" KEY_FLAG_IN_QUOTA
Ключ обеспечивает пользовательские квоты.
.IP U
.\" KEY_FLAG_USER_CONSTRUCT
Ключ в состоянии создания через обратный вызов в пользовательское
пространство; смотрите \fBrequest\-key\fP(2).
.IP N
.\" KEY_FLAG_NEGATIVE
Ключ инициализирован негативно.
.IP i
.\" KEY_FLAG_INVALIDATED
Ключ признан недействительным.
.RE
.TP 
Использование (3)
Счётчик количества структур мандатов ядра, которые привязали (pinning) ключ
(приблизительный: количество нитей и открытых файловых ссылок, ссылающихся
на этот ключ).
.TP 
Время ожидания (4)
Количество времени до истечения срока действия ключа, выражается в
человеко\-читаемой форме (недели, дни, часы, минуты и секунды). Строка
\fIperm\fP здесь означает, что ключ постоянный (бессрочный). Строка \fIexpd\fP
означает, что срок действия ключа уже истёк, но ключ ещё не удалён сборщиком
мусора.
.TP 
Права доступа (5)
Права доступа к ключу, выражается в виде четырёх шестнадцатеричных байт
содержащий, слева направо, владельца, пользователя, группу и права
остальных. Внутри каждого байта значения битов прав следующие:
.IP
.PD 0
.RS 12
.TP 
0x01
\fIпросмотр\fP
.TP 
Ox02
\fIчтение\fP
.TP 
0x04
\fIзапись\fP
.TP 
0x08
\fIпоиск\fP
.TP 
0x10
\fIсвязь\fP
.TP 
0x20
\fIустановка атрибутов\fP
.RE
.PD
.TP 
UID (6)
Пользовательский идентификатор владельца ключа.
.TP 
GID (7)
Идентификатор группы ключа. Значение \-1 здесь означает, что у ключа нет
идентификатора группы; это может быть при определённых обстоятельствах когда
ключ создаётся ядром.
.TP 
Тип (8)
Тип ключа (пользовательский, связка и т. п.)
.TP 
Описание (9)
Описание ключа (название). Это поле содержит смысловую информацию о
ключе. Для большинства типов оно имеет форму
.IP
     имя[: дополнительная информация]
.IP
Подполе \fIимя\fP это описание ключа (название). Необязательное поле
\fIдополнительная информация\fP содержит некую расширенную информацию о
ключе. Информация здесь зависит от типа ключа:
.RS
.TP  4
\fI"user"\fP и \fI"logon"\fP
Размер полезных данных ключа в байтах (десятичное число).
.TP 
\fI"keyring"\fP
Количество ключей привязанных в связку ключей или строка \fIempty\fP, если в
связке нет ключей.
.TP 
\fI"big_key"\fP
Размер полезных данных в байтах, указывается или за строкой \fI[file]\fP, если
полезные данные ключа превышают порог и хранятся в (вытесняемой на диск)
файловой системе \fBtmpfs\fP(5), или за строкой \fI[buff]\fP, если ключ слишком
мал и хранится в памяти ядра.
.RE
.IP
Для типа ключа \fI".request_key_auth"\fP (ключ авторизации; смотрите
\fBrequest_key\fP(2)) поле описания имеет вид, показанный в этом примере:
.IP
    key:c9a9b19 pid:28880 ci:10
.IP
Значения трёх подполей:
.RS
.TP  5
\fIkey\fP
Шестнадцатеричный идентификатор ключа, инициализируемый в запрашивающей
программе.
.TP 
\fIpid\fP
Значение PID запрашивающей программы.
.TP 
\fIci\fP
Размер исходящих данных (callout data), которые должны быть размещены в
запрашиваемом ключе (т. е., размер полезных данных, связанных с ключом
авторизации).
.RE
.RE
.TP 
\fI/proc/key\-users\fP (начиная с Linux 2.6.10)
В этом файле содержится различная информация по каждому пользовательскому
ID, который имеет хотя бы один ключ в системе. Пример данных из этого файла:
.IP
.in +4n
.EX
   0:    10 9/9 2/1000000 22/25000000
  42:     9 9/9 8/200 106/20000
1000:    11 11/11 10/200 271/20000
.EE
.in
.IP
Поля каждой строки имеют следующее назначение:
.RS
.TP 
\fIuid\fP
Пользовательский идентификатор.
.TP 
\fIusage\fP
Внутренний счётчик использования в ядре для структуры ядра с записями
пользовательских ключей.
.TP 
\fInkeys\fP/\fInikeys\fP
Общее количество ключей, принадлежащих пользователю, и количество
инициализированных среди этих ключей.
.TP 
\fIqnkeys\fP/\fImaxkeys\fP
Количество ключей, принадлежащих пользователю, и максимальное количество
ключей, которое может принадлежать пользователю.
.TP 
\fIqnbytes\fP/\fImaxbytes\fP
Количество байт, использованных под полезные данные в ключах, принадлежащих
пользователю, и верхний предел размера полезных данных в ключах этого
пользователя.
.RE
.TP 
\fI/proc/sys/kernel/keys/gc_delay\fP (начиная с Linux 2.6.32)
.\" commit 5d135440faf7db8d566de0c6fab36b16cf9cfc3b
Значением в этом файле определяется интервал в секундах, после которого
отозванные и просроченные ключи будут удалены как мусор. Целью назначения
этого интервала является создание временного окна, в течении которого
пользовательское пространство может видеть ошибку (\fBEKEYREVOKED\fP и
\fBEKEYEXPIRED\fP, соответственно), которая указывает что случилось с ключом.
.IP
Значение по умолчанию равно 300 (т. е., 5 минут).
.TP 
\fI/proc/sys/kernel/keys/persistent_keyring_expiry\fP (начиная с Linux 3.13)
.\" commit f36f8c75ae2e7d4da34f4c908cebdb4aa42c977e
В этом файле указывается интервал в секундах, в который таймер срока
годности постоянных связок ключей сбрасывается каждый раз при доступен к
связке ключей (через операцию \fBkeyctl_get_persistent\fP(3) или \fBkeyctl\fP(2)
\fBKEYCTL_GET_PERSISTENT\fP).
.IP
Значение по умолчанию равно 259200 (т. е., 3 дня).
.PP
Следующие файлы (которые могут изменяться привилегированными процессами)
используются задания квот на количестве ключей и байт данных, которые могут
храниться в полезных данных ключей:
.TP 
\fI/proc/sys/kernel/keys/maxbytes\fP (начиная с Linux 2.6.26)
.\" commit 0b77f5bfb45c13e1e5142374f9d6ca75292252a4
.\" Previously: KEYQUOTA_MAX_BYTES      10000
Максимальное количество байт данных, которое непривилегированный
пользователь может держать в полезных данных принадлежащих ему ключей.
.IP
Значение по умолчанию равно 20000.
.TP 
\fI/proc/sys/kernel/keys/maxkeys\fP (начиная с Linux 2.6.26)
.\" commit 0b77f5bfb45c13e1e5142374f9d6ca75292252a4
.\" Previously: KEYQUOTA_MAX_KEYS       100
Максимальное количество ключей, которое может принадлежать
непривилегированному пользователю.
.IP
Значение по умолчанию равно 200.
.TP 
\fI/proc/sys/kernel/keys/root_maxbytes\fP (начиная с Linux 2.6.26)
Максимальное количество байт данных, которое привилегированный пользователь
(с UID 0 в корневом пространстве имён пользователя) может держать в полезных
данных принадлежащих ему ключей.
.IP
.\"738c5d190f6540539a04baf36ce21d46b5da04bd
.\" commit 0b77f5bfb45c13e1e5142374f9d6ca75292252a4
Значение по умолчанию равно 25000000 (20000 до Linux 3.17).
.TP 
\fI/proc/sys/kernel/keys/root_maxkeys\fP (начиная с Linux 2.6.26)
.\" commit 0b77f5bfb45c13e1e5142374f9d6ca75292252a4
Максимальное количество ключей, которое может принадлежать
привилегированному (с UID 0 в корневом пространстве имён пользователя)
пользователю.
.IP
.\"738c5d190f6540539a04baf36ce21d46b5da04bd
Значение по умолчанию равно 1000000 (200 до Linux 3.17).
.PP
.\"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
При использовании связок ключей обратите внимание, что на каждую связь в
связке ключей тратится 4 байта из полезных данных связки ключей.
.SS Пользователи
Система управления ключами Linux содержит некоторое количество пользователей
и свойств, но не ограничивается только ими.
.PP
Ядерные пользователи этого свойства:
.TP 
Сетевые файловые системы — DNS
Ядро использует механизм внешнего вызова (upcall), предоставляемый ключами,
из пользовательского пространства для выполнения поиска в DNS и кэширования
результатов.
.TP 
AF_RXRPC и kAFS — аутентификация
Сетевой протокол AF_RXRPC и ядерная файловая система AFS использует ключи
для хранения билетов, необходимых для работы с безопасным и шифрованным
трафиком. Позднее эти билеты ищутся сетевыми операциями AF_RXRPC и
операциями файловой системы kAFS.
.TP 
NFS — отображение идентификаторов пользователей
Файловая система NFS используется ключи для хранения отображений
идентификаторов сторонних пользователей в идентификаторы локальных
пользователей.
.TP 
CIFS — пароль
Файловая система CIFS используется ключи для хранения паролей доступа к
удалённым общим ресурсам.
.TP 
Поверка модуля
Процесс сборки ядра может криптографически подписывать модули. В последствии
эта подпись проверяется при загрузке модуля.
.PP
Пользователи пространства пользователя этого свойства:
.TP 
Хранилище ключей Kerberos
.\"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Средство MIT Kerberos 5 (libkrb5) может использовать ключи для хранения
токенов аутентификации, которые при задании времени могут автоматически
очищаться после последнего обращения пользователя, но оставаться даже после
выхода пользователя для того, чтобы их можно было использовать из сценариев
\fBcron\fP(8).
.SH "СМОТРИТЕ ТАКЖЕ"
.ad l
.nh
\fBkeyctl\fP(1), \fBadd_key\fP(2), \fBkeyctl\fP(2), \fBrequest_key\fP(2), \fBkeyctl\fP(3),
\fBkeyutils\fP(7), \fBpersistent\-keyring\fP(7), \fBprocess\-keyring\fP(7),
\fBsession\-keyring\fP(7), \fBthread\-keyring\fP(7), \fBuser\-keyring\fP(7),
\fBuser\-session\-keyring\fP(7), \fBpam_keyinit\fP(8), \fBrequest\-key\fP(8)
.PP
Файл дерева исходного кода ядра \fIDocumentation/crypto/asymmetric\-keys.txt\fP
и все в каталоге \fIDocumentation/security/keys\fP (или, до Linux 4.13, файл
\fIDocumentation/security/keys.txt\fP).
