.\" -*- mode: troff; coding: UTF-8 -*-
.\" This man page is Copyright (C) 1999 Andi Kleen <ak@muc.de>.
.\"
.\" %%%LICENSE_START(VERBATIM_ONE_PARA)
.\" Permission is granted to distribute possibly modified copies
.\" of this page provided the header is included verbatim,
.\" and in case of nontrivial modification author and date
.\" of the modification is added to the header.
.\" %%%LICENSE_END
.\"
.\" $Id: packet.7,v 1.13 2000/08/14 08:03:45 ak Exp $
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH PACKET 7 2017\-09\-15 Linux "Руководство программиста Linux"
.SH ИМЯ
packet \- пакетный интерфейс на уровне устройства
.SH ОБЗОР
.nf
\fB#include <sys/socket.h>\fP
\fB#include <linux/if_packet.h>\fP
\fB#include <net/ethernet.h> /* протоколы L2 */\fP
.PP
\fBpacket_socket = socket(AF_PACKET, int \fP\fIsocket_type\fP\fB, int \fP\fIprotocol\fP\fB);\fP
.fi
.SH ОПИСАНИЕ
Пакетные сокеты используются для приёма и передачи неструктурированных
пакетов на уровне драйвера устройства (второй уровень OSI). Они позволяют
пользователю реализовывать модули протоколов в пользовательском пространстве
поверх физического уровня.
.PP
Значением \fIsocket_type\fP может быть \fBSOCK_RAW\fP — для неструктурированных
пакетов, содержащих заголовок уровня связи, или \fBSOCK_DGRAM\fP — для
подготовленных (cooked) пакетов без заголовка уровня связи. Информация
заголовка уровня связи имеет общий формат и предоставляется структурой
\fIsockaddr_ll\fP. В \fIprotocol\fP содержится номер протокола согласно IEEE 802.3
в сетевом порядке байт. Список допустимых протоколов можно найти в
заголовочном файле \fI<linux/if_ether.h>\fP. Если значение протокола
равно \fBhtons(ETH_P_ALL)\fP, то принимаются все протоколы. Все входящие пакеты
с этим типом протокола будут переданы в пакетный сокет до их передачи
протоколам, реализуемым в ядре.
.PP
Для создания пакетного сокета процесс должен иметь мандат \fBCAP_NET_RAW\fP в
пользовательском пространстве имён, определяемом по его сетевому
пространству имён.
.PP
Пакеты \fBSOCK_RAW\fP передаются в и из драйвера устройства без каких\-либо
изменений в данных пакета. При получении пакета, адрес по\-прежнему
анализируется и передаётся в стандартной адресной структуре
\fIsockaddr_ll\fP. При отправке пакета, выделенный пользователем буфер должен
содержать заголовок физического уровня. Этот пакет затем ставится без
изменений в очередь сетевого драйвера интерфейса, определяемого адресом
назначения. Некоторые драйверы устройств всегда добавляют другой
заголовок. Пакеты \fBSOCK_RAW\fP похожи, но не совместимы с устаревшими
\fBAF_INET/SOCK_PACKET\fP из Linux 2.0.
.PP
При типе \fBSOCK_DGRAM\fP обработка происходит на чуть более высоком
уровне. Физический заголовок удаляется перед передачей пакета
пользователю. Пакеты, посылаемые через пакетный сокет \fBSOCK_DGRAM\fP, перед
постановкой в очередь получают подходящий заголовок физического уровня на
основе информации из адреса назначения в \fIsockaddr_ll\fP.
.PP
По умолчанию, все пакеты заданного типа протокола передаются в пакетный
сокет. Для получения пакетов только из определённого интерфейса используйте
\fBbind\fP(2), задав адрес в \fIstruct sockaddr_ll\fP для привязки пакетного
сокета к интерфейсу. Поля, используемые для привязывания: \fIsll_family\fP
(должно быть равно \fBAF_PACKET\fP), \fIsll_protocol\fP и \fIsll_ifindex\fP.
.PP
Операция \fBconnect\fP(2) не поддерживается для пакетных сокетов.
.PP
Если в \fBrecvmsg\fP(2), \fBrecv\fP(2) или \fBrecvfrom\fP(2) передаётся флаг
\fBMSG_TRUNC\fP, то возвращается реальная длина пакета в канале, даже если
значение длиннее буфера.
.SS "Типы адресов"
Структура \fIsockaddr_ll\fP описывает независимый от устройства адрес на
физическом уровне.
.PP
.in +4n
.EX
struct sockaddr_ll {
    unsigned short sll_family;   /* всегда равно AF_PACKET */
    unsigned short sll_protocol; /* протокол физического уровня */
    int            sll_ifindex;  /* номер интерфейса */
    unsigned short sll_hatype;   /* тип аппаратного ARP */
    unsigned char  sll_pkttype;  /* тип пакета */
    unsigned char  sll_halen;    /* длина адреса */
    unsigned char  sll_addr[8];  /* адрес на физическом уровне */
};
.EE
.in
.PP
Поля этой структуры имеют следующее назначение:
.IP * 3
Поле \fIsll_protocol\fP содержит стандартные типы протокола ethernet в сетевом
порядке байт; значения определены в заголовочном файле
\fI<linux/if_ether.h>\fP. Это значение по умолчанию для протокола
сокета.
.IP *
Поле \fIsll_ifindex\fP содержит индекс интерфейса (смотрите \fBnetdevice\fP(7)); 0
означает любой интерфейс (допустимо только для привязывания). Поле
\fIsll_hatype\fP содержит тип ARP; значения хранятся в заголовочном файле
\fI<linux/if_arp.h>\fP.
.IP *
В поле \fIsll_pkttype\fP содержится тип пакета. Допустимые типы: \fBPACKET_HOST\fP
— пакет предназначен локальному узлу, \fBPACKET_BROADCAST\fP —
широковещательный пакет физического уровня, \fBPACKET_MULTICAST\fP — пакет,
посланный на групповой (multicast) адрес физического уровня,
\fBPACKET_OTHERHOST\fP — пакет предназначен не тому узлу, где он пойман
драйвером устройства в неразборчивом режиме, \fBPACKET_OUTGOING\fP — пакет,
поступивший от локального узла и завёрнутый обратно в пакетный сокет. Эти
типы имеют смысл только для принятых пакетов.
.IP *
В полях \fIsll_addr\fP и \fIsll_halen\fP содержится адрес физического уровня
(например, IEEE 802.3) и его длина. Конкретный смысл зависит от устройства.
.PP
Когда вы посылаете пакеты, достаточно указать \fIsll_family\fP, \fIsll_addr\fP,
\fIsll_halen\fP, \fIsll_ifindex\fP и \fIsll_protocol\fP. Остальные поля должны
равняться 0. Поля \fIsll_hatype\fP и \fIsll_pkttype\fP заполняются в получаемых
пакетах для вашей информированности.
.SS "Параметры сокета"
Параметры пакетных сокетов настраиваются вызовом \fBsetsockopt\fP(2) с уровнем
\fBSOL_PACKET\fP.
.TP 
\fBPACKET_ADD_MEMBERSHIP\fP
.PD 0
.TP 
\fBPACKET_DROP_MEMBERSHIP\fP
.PD
Пакетные сокеты можно использовать для настройки неразборчивого режима и
групповой рассылки на физическом уровне. Параметр \fBPACKET_ADD_MEMBERSHIP\fP
добавляет привязку, \fBPACKET_DROP_MEMBERSHIP\fP отменяет её. Для обоих в
качестве аргумента передаётся структура \fIpacket_mreq\fP:
.IP
.in +4n
.EX
struct packet_mreq {
    int            mr_ifindex;    /* индекс интерфейса */
    unsigned short mr_type;       /* действие */
    unsigned short mr_alen;       /* длина адреса */
    unsigned char  mr_address[8]; /* адрес физ\-кого уровня */
};
.EE
.in
.IP
В \fImr_ifindex\fP содержится индекс интерфейса, состояние которого нужно
изменить. В поле \fImr_type\fP указывается какое действие нужно
выполнить. Значение \fBPACKET_MR_PROMISC\fP включает приём всех пакетов из
общего носителя (часто называется «неразборчивый режим»),
\fBPACKET_MR_MULTICAST\fP привязывает сокет к групповой рассылке физического
уровня, задаваемой в \fImr_address\fP и \fImr_alen\fP, а \fBPACKET_MR_ALLMULTI\fP
заставляет сокет принимать все пакеты групповых рассылок, поступающих на
интерфейс.
.IP
Также, для тех же целей можно использовать обычные ioctl \fBSIOCSIFFLAGS\fP,
\fBSIOCADDMULTI\fP, \fBSIOCDELMULTI\fP.
.TP 
\fBPACKET_AUXDATA\fP (начиная с Linux 2.6.21)
.\" commit 8dc4194474159660d7f37c495e3fc3f10d0db8cc
Если включён этот двоичный параметр, то пакетный сокет передаёт структуру
метаданных вместе с каждым пакетом в управляющем поле
\fBrecvmsg\fP(2). Структуру можно прочитать с помощью \fBcmsg\fP(3). Она
определена как:
.IP
.in +4n
.EX
struct tpacket_auxdata {
    __u32 tp_status;
    __u32 tp_len;      /* длина пакета */
    __u32 tp_snaplen;  /* захваченная длина */
    __u16 tp_mac;
    __u16 tp_net;
    __u16 tp_vlan_tci;
    __u16 tp_padding;
};
.EE
.in
.TP 
\fBPACKET_FANOUT\fP (начиная с Linux 3.1)
.\" commit dc99f600698dcac69b8f56dda9a8a00d645c5ffc
Для масштабирования обработки на несколько нитей, пакетные сокеты можно
объединять в разветвлённую группу (fanout group). В этом режиме каждый
подходящий пакет ставится в очередь только одного сокета в группе. Сокет
добавляется в разветвлённую группу вызовом \fBsetsockopt\fP(2) с уровнем
\fBSOL_PACKET\fP и параметром \fBPACKET_FANOUT\fP. Каждое сетевое пространство
имён может включать до 65536 независимых групп. Сокет выбирает группу по
закодированному ID в первых 16 битах целочисленного значения
параметра. Первый пакетный сокет, подключаемый к группе неявно её
создаёт. Для успешного подключения к существующей группе все дальнейшие
пакетные сокеты должны иметь тот же протокол, настройки устройства, режим
разветвления и флаги (смотрите далее). Пакетные сокеты могут покинуть группу
только при закрытия сокета. Группа удаляется после закрытия последнего
сокета.
.IP
Для разветвления поддерживается несколько алгоритмов распределения трафика
по сокетам:
.RS
.IP * 3
Режим по умолчанию \fBPACKET_FANOUT_HASH\fP посылает пакеты из одного потока в
один и тот же сокет для обеспечения упорядочивания по потоку. Для каждого
пакета выбирается сокет, получаемый из хэша потока пакетов, взятого по
модулю количества сокетов в группе, где хэш потока — это хэш адреса сетевого
уровня и необязательных полей портов транспортного уровня.
.IP *
Режим балансировки нагрузки \fBPACKET_FANOUT_LB\fP реализует карусельный
алгоритм.
.IP *
В режиме \fBPACKET_FANOUT_CPU\fP выбираются сокеты исходя из ЦП, на который
поступил пакет.
.IP *
В режиме \fBPACKET_FANOUT_ROLLOVER\fP все данные обрабатываются одним сокетом,
следующий задействуется, если текущий занят (backlogged).
.IP *
В режиме \fBPACKET_FANOUT_RND\fP сокет выбирается согласно генератору
псевдослучайных чисел.
.IP *
.\" commit 2d36097d26b5991d71a2cf4a20c1a158f0f1bfcd
В режиме \fBPACKET_FANOUT_QM\fP (доступен, начиная с Linux 3.14)  сокет
выбирается с помощью записанного queue_mapping из полученной skb.
.RE
.IP
Режимы разветвления могут учитывать дополнительные параметры. Фрагментация
IP приводит к тому, что пакеты одного потока имеют разные хэши потоков. Если
установлен флаг \fBPACKET_FANOUT_FLAG_DEFRAG\fP, то пакеты будут
дефрагментироваться перед применением разветвления, что позволит сохранить
порядок даже в этом случае. Параметры режима разветвления задаются во вторых
16 битах целочисленного значения параметра. Флаг
\fBPACKET_FANOUT_FLAG_ROLLOVER\fP включает механизм перекатывания в качестве
запасного: если первоначальный алгоритм разветвления выбрал занятый сокет,
то пакет переходит на следующий доступный.
.TP 
\fBPACKET_LOSS\fP (с \fBPACKET_TX_RING\fP)
Когда в кольце передачи обнаруживается некорректный пакет, то по умолчанию
его состояние в \fItp_status\fP сбрасывается в \fBTP_STATUS_WRONG_FORMAT\fP и
происходит немедленная отмена передачи. Некорректный пакет блокирует как
свою отправку, так и всех следующих пакетов в очереди. Ошибка в формате
должна быть исправлена, соответствующий \fItp_status\fP сброшен в значение
\fBTP_STATUS_SEND_REQUEST\fP, а передача перезапущена с помощью
\fBsend\fP(2). Однако, если задан параметр \fBPACKET_LOSS\fP, то все некорректные
пакеты будут пропускаться, их \fItp_status\fP сбрасываться в
\fBTP_STATUS_AVAILABLE\fP и процесс передачи продолжаться.
.TP 
\fBPACKET_RESERVE\fP (с \fBPACKET_RX_RING\fP)
По умолчанию, в кольцо приёма пакетов сразу за пакетом записывается
структура метаданных и заполнитель для выравнивания. Этот целочисленный
параметр резервирует дополнительное свободное место.
.TP 
\fBPACKET_RX_RING\fP
Включает создание отображаемого в памяти кольцевого буфера асинхронного
приёма пакетов. Пакетный сокет резервирует непрерывную область в адресном
пространстве приложения, размечает её как массив пакетных слотов и
последовательно копирует пакеты (не более \fItp_snaplen\fP) в слоты. В начале
каждого пакета помещается структура метаданных, похожая на
\fItpacket_auxdata\fP. В поле протокола кодируется смещение данных от начала
заголовка метаданных. В \fItp_net\fP хранится смещение сетевого уровня. Если
тип пакетного сокета — \fBSOCK_DGRAM\fP, то это делается и для \fItp_mac\fP. Если
тип — \fBSOCK_RAW\fP, то в этом поле хранится смещение на кадр канального
уровня. Пакетный сокет и приложение обмениваются началом и концом кольца
через поле \fItp_status\fP. Пакетному сокету принадлежат все слоты со значением
\fItp_status\fP равным \fBTP_STATUS_KERNEL\fP. После заполнения слота, изменяется
состояние слота и права на него передаются приложению. При нормальной работе
в новом значении \fItp_status\fP, как минимум, установлен бит
\fBTP_STATUS_USER\fP, что показывает, что принятый пакет был сохранён. Когда
приложение заканчивает обработку пакета, оно передаёт права на слот обратно
сокету посредством установки \fItp_status\fP в значение \fBTP_STATUS_KERNEL\fP.
.IP
Для пакетных сокетов реализовано несколько вариантов пакетных
колец. Информацию о реализации можно найти в файле
\fIDocumentation/networking/packet_mmap.txt\fP из дерева исходного кода ядра
Linux.
.TP 
\fBPACKET_STATISTICS\fP
Возвращает статистику по пакетному сокету в виде структуры
.IP
.in +4n
.EX
struct tpacket_stats {
    unsigned int tp_packets;  /* общее количество пакетов */
    unsigned int tp_drops;    /* кол\-во отброшенных пакетов */
};
.EE
.in
.IP
При получении статистики сбрасываются внутренние счётчики. Если используется
вариант кольца \fBTPACKET_V3\fP, то статистика имеет другую структуру.
.TP 
\fBPACKET_TIMESTAMP\fP (с \fBPACKET_RX_RING\fP; начиная с Linux 2.6.36)
.\" commit 614f60fa9d73a9e8fdff3df83381907fea7c5649
В кольце приёма пакетов всегда сохраняется метка времени в заголовке
метаданных. По умолчанию, это метка генерируется ПО при копировании пакета в
кольцо. Данный целочисленный параметр задаёт тип метки времени. Кроме
значения по умолчанию, поддерживается два аппаратных формата, описанных в
файле \fIDocumentation/networking/timestamping.txt\fP из дерева исходного кода
ядра Linux.
.TP 
\fBPACKET_TX_RING\fP (начиная с Linux 2.6.31)
.\" commit 69e3c75f4d541a6eb151b3ef91f34033cb3ad6e1
Включает создание отображаемого в памяти кольцевого буфера передачи
пакетов. Этот параметр подобен \fBPACKET_RX_RING\fP и имеет те же
аргументы. Приложение записывает пакеты в слоты со значением \fItp_status\fP
равным \fBTP_STATUS_AVAILABLE\fP и планирует их для передачи делая значение
\fItp_status\fP равным \fBTP_STATUS_SEND_REQUEST\fP. Когда пакеты готовы к
передаче, приложение вызывает \fBsend\fP(2) или его вариант. Поля \fIbuf\fP и
\fIlen\fP в этом вызове игнорируются. Если передаётся адрес с помощью
\fBsendto\fP(2) или \fBsendmsg\fP(2), то он заменяет сокетное значение по
умолчанию. При успешной передаче сокет сбрасывает значение \fItp_status\fP в
\fBTP_STATUS_AVAILABLE\fP. При ошибке передача немедленно прерывается, если не
задан \fBPACKET_LOSS\fP.
.TP 
\fBPACKET_VERSION\fP (с \fBPACKET_RX_RING\fP; начиная с Linux 2.6.27)
.\" commit bbd6ef87c544d88c30e4b762b1b61ef267a7d279
По умолчанию, \fBPACKET_RX_RING\fP создаёт кольцо приёма пакетов по варианту
\fBTPACKET_V1\fP. Для создания другого варианта, задайте желаемый, указав
целочисленное значение в этом параметре перед созданием кольца.
.TP 
\fBPACKET_QDISC_BYPASS\fP (начиная с Linux 3.14)
.\" commit d346a3fae3ff1d99f5d0c819bf86edf9094a26a1
По умолчанию, пакеты, посылаемые через пакетные сокеты, проходят через
уровень ядра qdisc (управление трафиком), что правильно в подавляющем
большинстве случаев. Для программно\-аппаратных комплексов, использующих
пакетные фильтры для затопления сети — например, для тестирования устройств
под нагрузкой, подобно тому, как это делает pktgen — этот уровень можно не
задействовать, установив целочисленной параметр в 1. Побочным эффектом будет
отмена пакетной буферизации на уровне qdisc, что приведёт к увеличению
отброшенных пакетов при занятости передающих очередей сетевого устройства;
поэтому, пользуйтесь с осторожностью.
.SS "Вызовы ioctl"
.\" FIXME Document SIOCGSTAMPNS
Вызов \fBSIOCGSTAMP\fP можно использовать для получения метки времени
последнего полученного пакета. Аргументом является \fIstruct timeval\fP.
.PP
Также, для пакетных сокетов работают все стандартные ioctl, определённые в
\fBnetdevice\fP(7) и \fBsocket\fP(7).
.SS "Обработка ошибок"
Пакетные сокеты не выполняют обработку ошибок, кроме ошибок, которые
возникают при передаче пакета драйверу устройства. В них не заложен принцип
ожидания ошибки.
.SH ОШИБКИ
.TP 
\fBEADDRNOTAVAIL\fP
Передан неизвестный адрес групповой рассылки.
.TP 
\fBEFAULT\fP
Пользователь передал неправильный адрес памяти.
.TP 
\fBEINVAL\fP
Неверный аргумент.
.TP 
\fBEMSGSIZE\fP
Пакет больше, чем интерфейс MTU.
.TP 
\fBENETDOWN\fP
Интерфейс не поднят.
.TP 
\fBENOBUFS\fP
Недостаточно памяти для размещения пакета.
.TP 
\fBENODEV\fP
В адресе интерфейса указано неизвестное имя устройства или индекс
интерфейса.
.TP 
\fBENOENT\fP
Пакет не принят.
.TP 
\fBENOTCONN\fP
Не передан адрес интерфейса.
.TP 
\fBENXIO\fP
В адресе интерфейса содержится некорректный индекс интерфейса.
.TP 
\fBEPERM\fP
У пользователя недостаточно прав для выполнения этой операции.
.PP
Также, драйвером низкого уровня могут генерироваться другие ошибки.
.SH ВЕРСИИ
\fBAF_PACKET\fP появился в Linux 2.2. В ранних версиях Linux поддерживался
только \fBSOCK_PACKET\fP.
.PP
.SH ЗАМЕЧАНИЯ
Для переносимых программ предлагается использовать \fBAF_PACKET\fP в
\fBpcap\fP(3), хотя это покрывает не весь набор возможностей \fBAF_PACKET\fP.
.PP
Пакетные сокеты \fBSOCK_DGRAM\fP не пытаются создать или разобрать заголовок
IEEE 802.2 LLC из кадров IEEE 802.3. Если для отправки в качестве протокола
указан \fBETH_P_802_3\fP, то ядро создаёт кадр 802.3 и заполняет поле длины;
пользователь передаёт заголовок LLC в пакете уже полностью
заполненным. Входящие пакеты 802.3 не уплотняются по полям протокола
DSAP/SSAP; вместо этого они передаются пользователю как протокол
\fBETH_P_802_2\fP с начальным заголовком LLC. То есть невозможно выполнить
привязку к \fBETH_P_802_3\fP; вместо этого выполняйте привязку к \fBETH_P_802_2\fP
и выполняйте протокольное  уплотнение самостоятельно. По умолчанию, отправка
происходит в стандартной упаковке Ethernet DIX с заполненным полем
протокола.
.PP
Пакетные сокеты недоступны (not subject) во входной и выходной цепочках
межсетевого экрана.
.SS Совместимость
В Linux 2.0 единственным способом получить пакетный сокет является вызов:
.PP
    socket(AF_INET, SOCK_PACKET, протокол)
.PP
Он всё ещё поддерживается, но устарел и настоятельно не
рекомендуется. Основным отличием между методами — для указания интерфейса
через \fBSOCK_PACKET\fP используется старая \fIstruct sockaddr_pkt\fP, которая не
предоставляет независимого физического уровня.
.PP
.in +4n
.EX
struct sockaddr_pkt {
    unsigned short spkt_family;
    unsigned char  spkt_device[14];
    unsigned short spkt_protocol;
};
.EE
.in
.PP
В \fIspkt_family\fP содержится тип устройства, в \fIspkt_protocol\fP — тип
протокола IEEE 802.3, определённый в \fI<sys/if_ether.h>\fP, а в
\fIspkt_device\fP — имя устройства в виде строки с null в конце, например,
eth0.
.PP
Эта структура устарела и не должна использоваться в новом коде.
.SH ДЕФЕКТЫ
Способ обработки IEEE 802.2/803.3 LLC не считается за дефектный.
.PP
Не описаны сокетные фильтры.
.PP
.\" .SH CREDITS
.\" This man page was written by Andi Kleen with help from Matthew Wilcox.
.\" AF_PACKET in Linux 2.2 was implemented
.\" by Alexey Kuznetsov, based on code by Alan Cox and others.
Расширение \fBMSG_TRUNC\fP \fBrecvmsg\fP(2) является неудачным решением и должно
быть заменено на управляющее сообщение. Пока нет способа получить
первоначальный адрес назначения пакетов через \fBSOCK_DGRAM\fP.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBsocket\fP(2), \fBpcap\fP(3), \fBcapabilities\fP(7), \fBip\fP(7), \fBraw\fP(7),
\fBsocket\fP(7)
.PP
В RFC\ 894 описана упаковка стандартного IP Ethernet. В RFC\ 1700 описана
упаковка IP IEEE 802.3.
.PP
Заголовочный файл \fI<linux/if_ether.h>\fP содержит протоколы
физического уровня.
.PP
Дерево исходного кода ядра Linux. В \fI/Documentation/networking/filter.txt\fP
описано как к пакетным сокетам применять Berkeley Packet Filters. В
\fI/tools/testing/selftests/net/psock_tpacket.c\fP содержится пример исходного
кода для всех доступных версий \fBPACKET_RX_RING\fP и \fBPACKET_TX_RING\fP.
