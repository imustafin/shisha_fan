.\" -*- mode: troff; coding: UTF-8 -*-
.\" Copyright (c) 2008 Silicon Graphics, Inc.
.\"
.\" Author: Paul Jackson (http://oss.sgi.com/projects/cpusets)
.\"
.\" %%%LICENSE_START(GPLv2_MISC)
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License
.\" version 2 as published by the Free Software Foundation.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, see
.\" <http://www.gnu.org/licenses/>.
.\" %%%LICENSE_END
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH CPUSET 7 2017\-09\-15 Linux "Руководство программиста Linux"
.SH ИМЯ
cpuset \- наборы для ограничения процессов по процессору и памяти
.SH ОПИСАНИЕ
Файловая система процессорного набора (cpuset) — это псевдо\-файловый
интерфейс для механизма ядра процессорного набора, который используется для
управления распределением процессов по процессорам и памяти. Обычно, он
монтируется в \fI/dev/cpuset\fP.
.PP
В системах, у которых ядра скомпилированы с поддержкой процессорного набора,
все процессы прикрепляются к процессорному набору, и процессорные наборы
всегда существуют. Если система поддерживает процессорные наборы, то в файле
\fI/proc/filesystems\fP будет запись \fBnodev cpuset\fP. Смонтировав файловую
систему процессорного набора (смотрите раздел \fBПРИМЕР\fP далее),
администратор может настроить процессорный набор в системе для управления
размещением процессов по процессорам и памяти. По умолчанию, если настройки
процессорного набора в системе не изменялись, и если файловая система
процессорного набора даже не смонтирована, то механизм процессорного набора,
хотя и имеется, но никак не влияет на работу системы.
.PP
В процессорном наборе задаёт список ЦП и узлов памяти.
.PP
К ЦП системы относятся все единицы обработки логики, на которых может
выполняться процесс, включая, если есть, несколько ядер процессора в одном
чипе и Hyper\-Threads внутри ядра процессора. К узлам памяти относятся все
отдельные банки основной памяти; в маленьких и SMP\-системах, обычно, есть
только один узел памяти, который содержит всю основную память системы, в то
время как системы с NUMA (non\-uniform memory access) имеют несколько узлов
памяти.
.PP
Процессорные наборы представляются в иерархической псевдо\-файловой системе в
виде каталогов, где верхний каталог иерархии (\fI/dev/cpuset\fP) представляет
систему полностью (все работающие ЦП и узлы памяти) и любой процессорный
набор — это потомок другого родительского процессорного набора, содержащий
поднабор родительских ЦП и узлов памяти. Каталоги и файлы представляют
процессорные наборы с обычными правами доступа в файловой системе.
.PP
Каждый процесс в системе принадлежит только одному процессорному
набору. Процесс ограничен в работе только на ЦП из процессорного набора,
которому он принадлежит и для него выделяется память только из узлов памяти
этого процессорного набора. Когда процесс запускает \fBfork\fP(2), дочерний
процесс помещается в тот же процессорный набор что и родитель. Имея
достаточно прав, процесс может переместиться из одного процессорного набора
в другой и допустимые ЦП и узлы памяти существующего процессорного набора
могут быть изменены.
.PP
Когда система начинает загружаться, определён один процессорный набор,
который содержит все ЦП и узлы памяти системы, и все процессы находятся в
этом процессорном наборе. При загрузке или позднее, при выполнении обычных
действий, администратор может создать другие процессорные наборы как
подкаталоги этого верхнего процессорного набора, и процессы могут помещаться
в эти новые процессорные наборы.
.PP
Процессорные наборы объединены с механизмом увязывания в планировании
(scheduling affinity) \fBsched_setaffinity\fP(2) и механизмами размещения
памяти \fBmbind\fP(2) и \fBset_mempolicy\fP(2) в ядре. Ни один из этих механизмов
не позволяет процессу использовать ЦП или узел памяти не разрешённый в
процессорном наборе процесса. Если изменение размещения процессорного набора
процесса конфликтует с этими механизмами, то учитывается размещение
процессорного набора, даже если это означает замену значений других
механизмов. Ядро замещает запрашиваемые ЦП и узлы памяти без уведомления
других механизмов на разрешённые из процессорного набора вызвавшего
процесса. Это может привести к ошибке при других вызовах, если, например,
такой вызов заканчивается запросом пустого набора ЦП или узлов памяти, после
чего запрос ограничивается процессорным набором вызывавшего процесса.
.PP
Обычно, процессорный набор используется для управления размещением ЦП и
узлов памяти для набора взаимодействующих процессов, а также планировщика
фоновых заданий, а другие механизмы используются для управления размещением
отдельных процессов или областей памяти внутри этого набора или задания.
.SH ФАЙЛЫ
Каждый каталог в \fI/dev/cpuset\fP представляет процессорный набор и содержит
одинаковый набор псевдо\-файлов, описывающий состояние этого процессорного
набора.
.PP
Новые процессорные наборы создаются с помощью системного вызова \fBmkdir\fP(2)
или команды \fBmkdir\fP(1). Свойства процессорного набора, такие как: флаги,
разрешённые ЦП и узлы памяти, прикреплённые процессы, возвращаются и
изменяются посредством чтения или записи соответствующего файла в каталоге
этого процессорного набора как описано далее.
.PP
Псевдо\-файлы каждого каталога процессорного набора автоматически создаются
при создании процессорного набора, то есть в результате вызова
\fBmkdir\fP(2). Нельзя напрямую добавлять или удалять эти псевдо\-файлы.
.PP
Каталог процессорного набора, в котором нет каталогов дочерних процессорных
наборов, и нет прикреплённых процессов, может быть удалён с помощью
\fBrmdir\fP(2) или \fBrmdir\fP(1). Необязательно и невозможно удалять псевдо\-файлы
внутри каталога перед удалением.
.PP
Псевдо\-файлы в каждом каталоге процессорного набора представляют собой
маленькие текстовые файлы, которые можно читать и писать с помощью обычных
утилит оболочки, таких как \fBcat\fP(1) и \fBecho\fP(1), или из программы с
помощью файловых библиотечных функций ввода\-вывода или системных вызовов,
таких как \fBopen\fP(2), \fBread\fP(2), \fBwrite\fP(2) и \fBclose\fP(2).
.PP
.\" ====================== tasks ======================
Псевдо\-файлы в каталоге процессорного набора описывают внутреннее состояние
ядра и не хранятся на диске. Все файлы описаны ниже.
.TP 
\fItasks\fP
Список ID (PID) процессов в этом процессорном наборе Список представляет
собой серию десятичных цифр ASCII, разделённых символом новой
строки. Процесс может быть добавлен в процессорный набор (автоматически
удаляясь из предыдущего процессорного набора, в котором он находился)
посредством записи его PID в файл \fItasks\fP этого процессорного набора (с или
без завершающего символа новой строки).
.IP
.\" =================== notify_on_release ===================
\fBПредупреждение:\fP за один раз в файл \fItasks\fP может быть записан только
один PID. Если записывается строка с несколькими PID, то будет использован
только первый.
.TP 
\fInotify_on_release\fP
.\" ====================== cpus ======================
Флаг (0 или 1). Если установлен (1), то для процессорного набора будут
выполняться дополнительные действия после его освобождения, то есть после
того, как все процессы перестанут его использовать (завершатся или перейдут
в другой процессорный набор), и все каталоги дочерних процессорных наборов
будут удалены. Смотрите раздел \fBУведомление об освобождении\fP далее.
.TP 
\fIcpuset.cpus\fP
Список номеров физических ЦП, на которых процессам разрешено выполняться в
этом процессорном наборе. О формате \fIcpus\fP смотрите описание в \fBФормат
списка\fP далее.
.IP
.\" ==================== cpu_exclusive ====================
Разрешённые ЦП в процессорном наборе можно изменить записав новый список в
его файл \fIcpus\fP.
.TP 
\fIcpuset.cpu_exclusive\fP
Флаг (0 или 1). Если установлен (1), то процессорный набор монопольно
использует свои ЦП (одноуровневые (sibling) или родственные (cousin)
процессорные наборы не могут иметь одинаковые ЦП). По умолчанию сброшен
(0). У создаваемых процессорных наборов этот флаг также по умолчанию сброшен
(0).
.IP
.\" ====================== mems ======================
Два процессорных набора являются \fIодноуровневыми\fP, если они имеют общий
родительский процессорный набор в иерархии \fI/dev/cpuset\fP. Два процессорных
набора являются \fIродственными\fP, если не один не является предком
другого. Независимо от значения \fIcpu_exclusive\fP, если один процессорный
набор — предок другого, и если оба этих процессорных набора имеют непустые
\fIcpus\fP, то их \fIcpus\fP должны перекрываться, так как \fIcpus\fP любого
процессорного набора всегда являются поднабором \fIcpus\fP своего родительского
процессорного набора.
.TP 
\fIcpuset.mems\fP
.\" ==================== mem_exclusive ====================
Список узлов памяти, на которых процессам разрешено выделять память в этом
процессорном наборе. О формате \fImems\fP смотрите описание в \fBФормат списка\fP
далее.
.TP 
\fIcpuset.mem_exclusive\fP
Флаг (0 или 1) Если установлен (1), то процессорный набор монопольно
использует свои узлы памяти (одноуровневые или родственные процессорные
наборы не могут иметь одинаковые узлы). Также, если флаг установлен (1), то
процессорный набор — \fBHardwall\fP (смотрите далее). По умолчанию флаг сброшен
(0). У создаваемых процессорных наборов флаг также по умолчанию сброшен (0).
.IP
.\" ==================== mem_hardwall ====================
Независимо от значения \fImem_exclusive\fP, если один процессорный набор —
предок другого, то их узлы памяти перекрываются, так как узлы памяти любого
процессорного набора всегда входят в поднабор узлов памяти своего
родительского процессорного набора.
.TP 
\fIcpuset.mem_hardwall\fP (начиная с Linux 2.6.26)
.\" ==================== memory_migrate ====================
Флаг (0 или 1) Если установлен (1), то процессорный набор — \fBHardwall\fP
(смотрите далее). В отличии от \fBmem_exclusive\fP, процессорные наборы с
установленным \fBmem_hardwall\fP (одноуровневые или родственные) не имеют
ограничения по перекрытию по узлам памяти. По умолчанию флаг сброшен (0). У
создаваемых процессорных наборов флаг также по умолчанию сброшен (0).
.TP 
\fIcpuset.memory_migrate\fP (начиная с Linux 2.6.16)
.\" ==================== memory_pressure ====================
Флаг (0 или 1). Если установлен (1), то разрешён перенос (migration)
памяти. По умолчанию сброшен (0). Смотрите раздел \fBПеренос памяти\fP далее.
.TP 
\fIcpuset.memory_pressure\fP (начиная с Linux 2.6.16)
.\" ================= memory_pressure_enabled =================
Величина нагрузки памяти, которую вызывают процессы в этом процессорном
наборе. Смотрите раздел \fBНагрузка памяти\fP далее. Если флаг
\fImemory_pressure_enabled\fP не установлен, то значение всегда равно нулю
(0). Этот файл доступен только для чтения. Смотрите раздел \fBПРЕДУПРЕЖДЕНИЯ\fP
далее.
.TP 
\fIcpuset.memory_pressure_enabled\fP (начиная с Linux 2.6.16)
.\" ================== memory_spread_page ==================
Флаг (0 или 1). Данный файл есть только в корневом процессорном наборе,
обычно \fI/dev/cpuset\fP. Если установлен (1), то включается вычисление
\fImemory_pressure\fP для всех процессорных наборов в системе. По умолчанию
выключен (0). Смотрите раздел \fBНагрузка памяти\fP далее.
.TP 
\fIcpuset.memory_spread_page\fP (начиная с Linux 2.6.17)
.\" ================== memory_spread_slab ==================
Флаг (0 или 1). Если установлен (1), то страницы в страничном кэше ядра
(буферы файловой системы) будут равномерно распределены по всему
процессорному набору. По умолчанию сброшен (0) в корневом процессорном
наборе, и наследуется от родительского процессорного набора для новых
процессорных наборов. Смотрите раздел \fBРаспространение в памяти\fP далее.
.TP 
\fIcpuset.memory_spread_slab\fP (начиная с Linux 2.6.17)
.\" ================== sched_load_balance ==================
Флаг (0 или 1). Если установлен (1), то кэши slab ядра для файлового
ввода\-вывода (структуры каталогов и inode) будут равномерно распределены по
всему процессорному набору. По умолчанию сброшен (0) в корневом процессорном
наборе, и наследуется от родительского процессорного набора для новых
процессорных наборов. Смотрите раздел \fBРаспространение в памяти\fP далее.
.TP 
\fIcpuset.sched_load_balance\fP (начиная с Linux 2.6.24)
.\" ================== sched_relax_domain_level ==================
Флаг (0 или 1). Если установлен (1), то ядро будет автоматически
балансировать нагрузку процессов процессорного набора по всем разрешённым в
процессорном наборе ЦП. Если сброшен (0), то ядро не будет выполнять
балансировку в этом процессорном наборе, \fIесли нет\fP какого\-то другого
процессорного набора с перекрывающимися ЦП и установленным флагом
\fIsched_load_balance\fP. Подробней смотрите \fBБалансировка нагрузки
планировщиком\fP далее.
.TP 
\fIcpuset.sched_relax_domain_level\fP (начиная с Linux 2.6.26)
.\" ================== proc cpuset ==================
Целое число от \-1 до небольшого положительного значения (small positive
value). Величина \fIsched_relax_domain_level\fP управляет шириной диапазона ЦП
в котором планировщик ядра непосредственно выполняет балансировку работающих
задач на ЦП. Если \fIsched_load_balance\fP выключен, то значение
\fIsched_relax_domain_level\fP не учитывается, так как балансировка не
выполняется. Если \fIsched_load_balance\fP включён, то чем больше величина
\fIsched_relax_domain_level\fP, тем шире диапазон ЦП, на которых пытается
выполняться балансировка. Подробней смотрите в \fBСтепень ослабления домена
планировщиком\fP далее.
.PP
.\" ================== proc status ==================
Кроме показанных выше псевдо\-файлов, в каждом каталоге в \fI/dev/cpuset\fP для
каждого процесса есть псевдо\-файл \fI/proc/<pid>/cpuset\fP, в котором
содержится путь к каталогу процессорного набора процесса относительно корня
файловой системы процессорного набора.
.PP
Также в файл \fI/proc/<pid>/status\fP для каждого процесса добавлены
четыре строки, отражающие \fICpus_allowed\fP (на каких ЦП может планироваться
выполнение) и \fIMems_allowed\fP (на каких узлах памяти может получать память)
процесса в двух форматах: \fBв виде маски\fP и \fBв виде списка\fP (смотрите
далее). Пример:
.PP
.in +4n
.EX
Cpus_allowed:   ffffffff,ffffffff,ffffffff,ffffffff
Cpus_allowed_list:     0\-127
Mems_allowed:   ffffffff,ffffffff
Mems_allowed_list:     0\-63
.EE
.in
.PP
.\" ================== EXTENDED CAPABILITIES ==================
Поля «allowed» были добавлены в Linux 2.6.24; поля «allowed_list» были
добавлены в Linux 2.6.26.
.SH "ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ"
.\" ================== Exclusive Cpusets ==================
Кроме контроля \fIcpus\fP и \fImems\fP для процесса, процессорные наборы
предоставляют следующие дополнительные возможности.
.SS "Монополизирующие процессорные наборы"
Если процессорный набор помечен как \fIcpu_exclusive\fP или \fImem_exclusive\fP,
то ни один другой процессорный набор, отличный от прямого предка или
потомка, не может совместно использовать те же ЦП или узлы памяти.
.PP
.\" ================== Hardwall ==================
Процессорный набор с установленным \fImem_exclusive\fP ограничивает ядро при
выделении страниц буферного кэша и других внутренних структур данных ядра,
обычно совместно используемые ядром среди нескольких пользователей. Все
процессорные наборы, с \fImem_exclusive\fP или без, ограничивают выделение
памяти для пользовательского адресного пространства. Это позволяет настроить
систему так, что несколько независимых заданий могут совместно использовать
общие данные ядра, изолируя каждое пользовательское выделение задания в его
процессорном наборе. Для этого создаётся большой процессорный набор
\fImem_exclusive\fP для хранения всех заданий и его потомок без
\fImem_exclusive\fP, отдельный для каждого задания. Только маленькое количество
памяти ядра, например для запросов от обработчиков прерываний, разрешено
размещать вне узлов памяти даже в процессорном наборе с \fImem_exclusive\fP.
.SS Hardwall
Процессорный набор, у которого установлен флаг \fImem_exclusive\fP или
\fImem_hardwall\fP считается \fIhardwall\fP. Процессорный набор \fIhardwall\fP
ограничивает выделение памяти ядром под страницы, буфер и другие данные,
часто используемые ядром для нескольких пользователей. Все процессорные
наборы, \fIhardwall\fP или нет, ограничивают выделение памяти для пространства
пользователя.
.PP
Это позволяет настроить систему так, что несколько независимых заданий могут
совместно использовать общие данные ядра, например для страниц файловой
системы, изолируя каждое пользовательское выделение задания в его
процессорном наборе. Для этого создаётся большой процессорный набор
\fIhardwall\fP для хранения всех заданий и его потомок не \fIhardwall\fP,
отдельный для каждого задания.
.PP
.\" ================== Notify On Release ==================
Только маленькое количество памяти ядра, например для запросов от
обработчиков прерываний, разрешено размещать вне узлов памяти даже в
процессорном наборе \fIhardwall\fP.
.SS "Уведомление об освобождении"
Если в процессорном наборе установлен флаг \fInotify_on_release\fP (1), то
когда последний процесс в процессорном наборе выходит (завершается или
прикрепляется к другому процессорному набору) и последний потомок этого
процессорного набора удаляется, то ядро выполняет команду
\fI/sbin/cpuset_release_agent\fP, передавая ей путь (относительно точки
монтирования файловой системы процессорного набора) ликвидируемого
процессорного набора. Это включает автоматическое удаление ликвидируемых
процессорных наборов.
.PP
Значение по умолчанию \fInotify_on_release\fP в корневом процессорном наборе
при запуске системы сброшено (0). Значение по умолчанию в других
процессорных наборах при создании равно текущему значению
\fInotify_on_release\fP их предка.
.PP
Вызываемой команде \fI/sbin/cpuset_release_agent\fP в \fIargv[1]\fP передаётся имя
(относительно пути \fI/dev/cpuset\fP) освобождаемого процессорного набора.
.PP
Обычно, команда \fI/sbin/cpuset_release_agent\fP — простой сценарий оболочки:
.PP
.in +4n
.EX
#!/bin/sh
rmdir /dev/cpuset/$1
.EE
.in
.PP
.\" ================== Memory Pressure ==================
Для сброса и установки, как и других флагов, этот флаг можно изменить,
записав в файл ASCII\-номер 0 или 1 (с необязательным символом новой строки в
конце), соответственно.
.SS "Нагрузка памяти"
Значение \fImemory_pressure\fP в процессорном наборе предоставляет
индивидуальный простой средний уровень, с которым процессы в процессорном
наборе пытаются освободить используемую память на узлах процессорного
набора, чтобы удовлетворить дополнительные запросы памяти.
.PP
Это позволяет менеджерам заданий, отслеживающим задания, выполняемые на
отдельных процессорных наборах, эффективно определять уровень нагрузки на
память, которую вызывает задание.
.PP
Это полезно как в жёстко контролируемых системах, выполняющих совершенно
разные поставленные задания, которые при попытке использовать больше памяти,
чем разрешено на назначенных им узлам, могут выбирать — завершить задание
или изменить его приоритет, так и для тесно связанных, непрерывных,
распараллеленных научных вычислительных заданий, которые катастрофически
теряют в производительности, если начинают использовать больше памяти, чем
им позволено.
.PP
Данный механизм предоставляет менеджерам заданий очень экономичный способ
для обнаружения признаков нагрузки на память. Задача менеджера заданий или
другого пользовательского кода решить, какие меры принять в случае
обнаружения нагрузки на память.
.PP
Если вычисление нагрузки памяти не включено в псевдо\-файле
\fI/dev/cpuset/cpuset.memory_pressure_enabled\fP, то она не вычисляется для
всех процессорных наборов, и чтение из любого файла \fImemory_pressure\fP
всегда возвращает ноль в виде строки ASCII «0\en». Смотрите раздел
\fBПРЕДУПРЕЖДЕНИЯ\fP далее.
.PP
Для каждого процессорного набора скользящее среднее (running average)
используется по следующим причинам:
.IP * 3
Поскольку измерение проводится по каждому процессорному набору, а не по
каждому процессу или виртуальной области памяти, системная нагрузка,
вызванная проводящим замеры пакетным планировщиком, резко сокращается в
больших системах, так как можно не выполнять сканирование списка задач на
каждый набор запросов.
.IP *
Поскольку измеряется скользящее среднее, а не накопительный счётчик,
пакетный планировщик может обнаружить нагрузку памяти за одно чтение, а не
читать и накапливать результаты за период времени.
.IP *
Поскольку измерение проводится по каждому процессорному набору, а не по
каждому процессу, пакетный планировщик может получить ключевую информацию —
нагрузку памяти в процессорном наборе — за одну операцию чтения, а не
выполняя запрос и не накапливая результаты по всему (динамически
изменяющемуся) набору процессов в процессорном наборе.
.PP
Значение \fImemory_pressure\fP для процессорного набора вычисляется с помощью
индивидуального простого цифрового фильтра, который хранится в ядре. Для
каждого процессорного набора этот фильтр отслеживает недавний уровень, с
которым процессы, прикреплённые к этому процессорному набору, использовали
код непосредственного освобождения ядром (kernel direct reclaim code).
.PP
Код непосредственного освобождения ядром выполняется, когда процессы из\-за
нехватки готовых свободных страниц удовлетворяют запрос выделение страницы
памяти приспособлением (repurpose) страницы, занятой под другие
цели. Грязные страницы файловой системы приспосабливаются после первой
записи обратно на диск. Неизменённые страницы буфера файловой системы
приспосабливаются простым сбросом, и если такая страница потребуется снова,
то она будет повторно прочитана с диска.
.PP
.\" ================== Memory Spread ==================
Файл \fIcpuset.memory_pressure\fP содержит целое число, представляющее недавний
(период спада (half\-life) за 10 секунд) уровень записей в код
непосредственного освобождения, вызванный любым процессом в процессорном
наборе, выражаемый в количестве освобождений в секунду, умноженном на 1000.
.SS "Распространение в памяти"
Для каждого процессорного набора есть два файла — логических флага, которые
управляют местом, где ядро выделяет страницы для буферов файловой системы и
других структур данных ядра. Они называются \fIcpuset.memory_spread_page\fP и
\fIcpuset.memory_spread_slab\fP.
.PP
Если установлен индивидуальный логический флаг\-файл
\fIcpuset.memory_spread_page\fP, то ядро будет распространять буферы файловой
системы (страничный кэш) последовательно по всем узлам, которые разрешено
использовать процессу, а не располагать эти страницы на узле, на котором
выполняется процесс.
.PP
Если установлен индивидуальный логический флаг\-файл
\fIcpuset.memory_spread_slab\fP, то ядро будет распространять slab\-кэши
файловой системы, например, для записей inode и каталогов, последовательно
по всем узлам, которые разрешено использовать процессу, а не располагать эти
страницы на узле, на котором выполняется процесс.
.PP
Установка этих флагов не влияет на страницы сегмента данных (смотрите
\fBbrk\fP(2)) или стека процесса.
.PP
По умолчанию, оба вида распространения в памяти выключены, и ядро
предпочитает выделять страницы памяти на узле, на котором работает
запросивший процесс. Если этот узел не разрешён политикой памяти NUMA
процесса или настройкой процессорного набора или если на этом узле
недостаточно свободных страниц памяти, то ядро ищет ближайший разрешённый
узел с достаточным количеством свободной памяти.
.PP
При создании нового процессорного набора он наследует параметры
распространения в памяти своего родителя.
.PP
Из\-за настройки распространения в памяти при выделении страниц или кэшей
slab происходит игнорирование политики памяти NUMA процесса и задействуется
распространение. Однако, эффект этих изменений по расположению в памяти,
вызванный указанным в процессорном наборе распространением в памяти скрыт,
от вызовов \fBmbind\fP(2) или \fBset_mempolicy\fP(2). При работе с данными
вызовами политики памяти NUMA кажется, что они всегда ведут себя как\-будто
распространение в памяти согласно процессорному набору не действует, даже
если это не так. Если распространение в памяти согласно процессорному набору
затем выключить, то автоматически повторно применится политика памяти NUMA,
заданная этими вызовами последней.
.PP
Файлы \fIcpuset.memory_spread_page\fP и \fIcpuset.memory_spread_slab\fP хранят
логический флаг. По умолчанию, они содержат «0»; это означает, что данное
свойство в процессорном наборе выключено. Если в файл записать «1», то это
включит данное свойство.
.PP
Распространение в памяти, указанное в процессорном наборе, похоже (в других
контекстах) на циклический алгоритм или размещение памяти чередованием.
.PP
Распространение в памяти, указанное в процессорном наборе, может существенно
повысить производительность заданий, которым:
.IP 1. 3
Необходимо разместить локальные данные нити в узлах памяти близко к ЦП, на
которых выполняются нити, то есть наиболее наиболее востребованные данные;
.IP 2.
Необходим доступ к наборам данных больших файловых систем, которые из\-за
размера нужно разместить на нескольких узлах процессорного набора задания.
.PP
.\" ================== Memory Migration ==================
Без этой политики выделение памяти на узлах процессорного набора задания
может быть очень неравномерным, особенно для заданий, которым нужно просто
инициализировать единственную нить или прочитать набор данных.
.SS "Перенос памяти"
Обычно, при настройке \fIcpuset.memory_migrate\fP по умолчанию (выключена) как
только страница выделена (получена физическая страница в основной памяти),
она остаётся на узле, на котором выделена до тех пор, пока остаётся
выделенной, даже если в дальнейшем изменяется политика процессорного набора
\fImems\fP по размещению в памяти.
.PP
При включённом переносе памяти в процессорном наборе, если значение \fImems\fP
в процессорном наборе изменяется, то если страница памяти, используемая
любым процессом в процессорном наборе, становится расположенной в
запрещённом узле, то эта страница перемещается в разрешённый узел памяти.
.PP
Также, если процесс перемещается в процессорный набор, у которого включен
\fImemory_migrate\fP, то все страницы памяти, которые он использует в узлах
памяти предыдущего процессорного набора, но которые запрещены в новом
процессорном наборе, будут перемещены на узел памяти, разрешённый в новом
процессорном наборе.
.PP
.\" ================== Scheduler Load Balancing ==================
Если возможно, при операции перемещения относительное размещение
перемещаемых страниц в процессорном наборе сохраняется. Например, если
страница была на втором разрешённом узле в предыдущем процессорном наборе,
то страница будет помещена на второй допустимый узел нового процессорном
наборе, если возможно.
.SS "Балансировка нагрузки планировщиком"
Планировщик ядра автоматически балансирует нагрузку, вызываемую
процессами. Если один ЦП недозагружен, то ядро будет искать процессы на
других, более загруженных ЦП и переместит процессы на недозагруженный ЦП, с
учётом ограничений механизмов размещения в процессорных наборах и
\fBsched_setaffinity\fP(2).
.PP
Траты на алгоритм балансировки нагрузки и его влияние на основные совместно
используемые структуры данных ядра, такие как список процессов, с ростом
балансируемых ЦП увеличиваются больше, чем линейно. Например, затраты на
него больше при балансировке нагрузке в одном большом наборе ЦП, чем между
двумя маленькими наборами ЦП, каждый из которых равен половине размера
большего набора (точное отношение между количеством балансируемых ЦП и
затратами на балансировку зависит от деталей реализации процесса
планировщика ядра, который изменяется со временем, улучшаясь по мере
реализации в ядре эффективных алгоритмов планирования).
.PP
Индивидуальный флаг \fIsched_load_balance\fP предоставляет механизм для
подавления этого автоматического планировщика балансировки нагрузки в случае
когда он не требуется и его выключение принесло бы больше выгоды для
производительности.
.PP
По умолчанию, балансировка нагрузки выполняется на всех ЦП, за исключением
отмеченных как изолированные при запуске ядра с аргументом «isolcpus=»
(смотрите \fBСтепень ослабления домена планировщиком\fP далее для изменения
этого значения по умолчанию).
.PP
Данное поведение балансировка нагрузки по умолчанию, выполняемое на всех ЦП,
не подходит в двух следующих случаях:
.IP * 3
На больших системах балансировка нагрузки на многих ЦП затратна. Если
система управляется с помощью процессорных наборов для размещения
независимых заданий на отдельных наборах ЦП, то полная балансировка нагрузки
необязательна.
.IP *
В системах, поддерживающих выполнение в реальном времени на некоторых ЦП,
требуются минимальные издержки на системные операции на этих ЦП, включая
запрещение процесса балансировки нагрузки, если он не нужен.
.PP
Когда индивидуальный флаг \fIsched_load_balance\fP установлен (по умолчанию),
запрашивается балансировка нагрузки на всех разрешённых ЦП в этом
процессорном наборе, при балансировке нагрузки может выполняться перемещение
процесса (если он не привязан с помощью \fBsched_setaffinity\fP(2)) с любого ЦП
в этом процессорном наборе на другой ЦП.
.PP
Когда индивидуальный флаг \fIsched_load_balance\fP сброшен, планировщик не
будет балансировать нагрузку по ЦП в этом процессорном наборе, \fIпока это не
станет необходимым\fP из\-за какого\-то перекрывающегося процессорного набора с
включённым \fIsched_load_balance\fP.
.PP
Так, например, если верхний процессорный набор имеет установленный флаг
\fIsched_load_balance\fP, то планировщик будет выполнять балансировку нагрузки
на всех ЦП, и значение флага \fIsched_load_balance\fP других процессорных
наборов не учитывается, так как уже включена полная балансировка нагрузки.
.PP
Поэтому в двух приведённых выше ситуациях флаг \fIsched_load_balance\fP должен
быть сброшен у верхнего процессорного набора, и его нужно устанавливать
только на отдельных дочерних процессорных наборах.
.PP
При выполнении этого вы, обычно, не хотите оставлять любые неприкрепленные
процессы в верхнем процессорном наборе, который может использовать
неограниченное количество ЦП, так как процессы могут быть искусственно
ограничены некоторым подмножеством ЦП, в зависимости от значения этого флага
в дочерних процессорных наборах. Даже если такой процесс мог бы использовать
запасные циклы ЦП в некоторых других ЦП, планировщик ядра не может
рассчитывать на возможность балансировки нагрузки этого процесса на
недогруженном ЦП.
.PP
.\" ================== Scheduler Relax Domain Level ==================
Конечно, процессы, прикреплённые к определённому ЦП, могут оставаться в
процессорном наборе с выключенным \fIsched_load_balance\fP, поскольку такие
процессы никуда не переместятся в любом случае.
.SS "Степень ослабления домена планировщиком"
Планировщик ядра безотлагательно (immediate) выполняет балансировку нагрузки
как только ЦП становится свободным или ещё одна задача становится
выполняемой. Такая балансировка нагрузки работает чтобы гарантировать, что
все возможные ЦП заняты полезной работой по выполнению задач. Также ядро
выполняет периодическую балансировку нагрузки по программным часам,
описанным в \fBtime\fP(7). Значение \fIsched_relax_domain_level\fP применяется
только к безотлагательной балансировке нагрузки. Независимо от значения
\fIsched_relax_domain_level\fP периодическая балансировка нагрузки пытается
работать на всех ЦП (если она не выключена в \fIsched_load_balance\fP). В любом
случае, задачи будут запланированы к выполнению только на разрешённых ЦП в
их процессорных наборах, которые настраиваются с помощью системных вызовов
\fBsched_setaffinity\fP(2).
.PP
В маленьких системах всего с несколькими ЦП безотлагательная балансировка
нагрузки полезна для улучшения отзывчивости системы и минимизации циклов
простоя ЦП. Но в больших системах, попытка безотлагательной балансировки
нагрузки на большом количестве ЦП может оказаться более затратной чем нужно,
в зависимости от определённых показателей производительности смеси заданий и
аппаратных средств.
.PP
Точные значения маленьких целых значений \fIsched_relax_domain_level\fP будет
зависеть от внутренней реализации кода планировщика ядра и неоднородности
архитектуры аппаратных средств. Оба из них постоянно развиваются и
различаются в разных версиях ядра и архитектурах системы.
.PP
На момент написания когда это свойство появилось в Linux 2.6.26, на
определённых популярных архитектурах положительные значения
\fIsched_relax_domain_level\fP были такими:
.PP
.PD 0
.IP \fB(1)\fP 4
Выполнять безотлагательную балансировку нагрузки на одноуровневых потоках
Hyper\-Thread одного ядра.
.IP \fB(2)\fP
Выполнять безотлагательную балансировку нагрузки на других ядрах того же
пакета.
.IP \fB(3)\fP
Выполнять безотлагательную балансировку нагрузки на других ЦП в том же узле
или лезвии.
.IP \fB(4)\fP
Выполнять безотлагательную балансировку нагрузки на нескольких (зависит от
реализации) узлах (в системах с NUMA).
.IP \fB(5)\fP
Выполнять безотлагательную балансировку нагрузки на всех ЦП системы (в
системах с NUMA).
.PD
.PP
Значение \fIsched_relax_domain_level\fP равное нулю (0) всегда означает
отключение безотлагательной балансировки нагрузки, то есть балансировка
нагрузки выполняется только периодически, а не сразу после того, как ЦП
становится доступным или другая задача становится выполняемой.
.PP
Значение \fIsched_relax_domain_level\fP равное минус одному (\-1) всегда
означает использование системного значения по умолчанию. Системное значение
по умолчанию может различаться на разных архитектурах и версиях ядра. Его
можно изменить через аргумент команды загрузки ядра «relax_domain_level=».
.PP
При наличии нескольких перекрывающихся процессорных наборов, которые имеют
конфликтующие значения \fIsched_relax_domain_level\fP, во всех перекрывающихся
процессорных наборах на всех ЦП применяется самое большое значение. В таких
случаях значение \fBминус один (\-1)\fP считается самым маленьким, заменяется
любым значением, а значение \fBноль (0)\fP является следующим самым маленьким
значением.
.SH ФОРМАТЫ
.\" ================== Mask Format ==================
Для представления наборов ЦП и узлов памяти используются следующие форматы:
.SS "В виде маски"
Формат \fBв виде маски\fP используется для представления ЦП и узлов памяти в
виде маски битов в файле \fI/proc/<pid>/status\fP.
.PP
Данный формат отображает каждое 32\-битное слово в шестнадцатеричной форме
(используя символы ASCII «0»\-«9» и «a»\-«f»); если нужно, слова дополняются
ведущими нулями. Для масок длиннее слова между словами используется
разделитель запятая. Слова отображаются в порядке от старшего к младшему, то
есть первым стоит самый значимый бит. Шестнадцатеричные цифры в слове также
расположены в порядке от старшего к младшему.
.PP
Минимальное количество отображаемых 32\-битных слов подбирается таким
образом, чтобы вместить все биты маски, то есть зависит от размера битовой
маски.
.PP
Примеры формата в \fBвиде маски\fP:
.PP
.in +4n
.EX
00000001                        # установлен только бит 0
40000000,00000000,00000000      # установлен только бит 94
00000001,00000000,00000000      # установлен только бит 64
000000ff,00000000               # установлены биты 32\-39
00000000,000e3862               # установлены 1,5,6,11\-13,17\-19
.EE
.in
.PP
Маска с установленными битами 0, 1, 2, 4, 8, 16, 32 и 64 выглядит так:
.PP
.in +4n
.EX
00000001,00000001,00010117
.EE
.in
.PP
.\" ================== List Format ==================
Первая «1» для бита 64, вторая — для бита 32, третья — для 16, четвёртая —
для 8, пятая — для 4 и «7» — для битов 2, 1 и 0.
.SS "В виде списка"
Формат в \fBвиде списка\fP — это список десятичных ASCII значений \fIcpus\fP и
\fImems\fP через запятую для перечисления номеров (и диапазонов) всех ЦП или
узлов памяти.
.PP
Примеры формата в \fBвиде списка\fP:
.PP
.in +4n
.EX
0\-4,9           # установлены биты 0, 1, 2, 3, 4 и 9
0\-2,7,12\-14     # установлены биты 0, 1, 2, 7, 12, 13 и 14
.EE
.in
.\" ================== RULES ==================
.SH ПРАВИЛА
К каждому процессорному набору применяются следующие правила:
.IP * 3
ЦП и узлы памяти должны быть поднабором (возможно, одинаковым) своего
предка.
.IP *
Набор может быть помечен как \fIcpu_exclusive\fP только, если и его предок тоже
помечен.
.IP *
Набор может быть помечен как \fImem_exclusive\fP только, если и его предок тоже
помечен.
.IP *
Если установлен \fIcpu_exclusive\fP, то ЦП набора не могут перекрываться с
любым одноранговым процессорным набором.
.IP *
.\" ================== PERMISSIONS ==================
Если установлен \fImem_exclusive\fP, то узлы памяти набора не могут
перекрываться с любым одноранговым процессорным набором.
.SH "ПРАВА ДОСТУПА"
Права на процессорный набор определяются правами доступа к каталогам и
псевдо\-файлам в файловой системе процессорного набора, обычно смонтированной
в \fI/dev/cpuset\fP.
.PP
Например, процесс может поместить себя в другой процессорный набор (отличный
от текущего), если сможет выполнить запись в файл \fItasks\fP другого
процессорного набора. Для этого требуется право на выполнение для окружающих
каталогов и право на запись в файл \fItasks\fP.
.PP
Дополнительное ограничение устанавливается на запросы размещения другого
процесса в процессорный набор. Один процесс не может прикрепить другой к
процессорному набору, если не имеет право отправки этому процессу сигнала
(смотрите \fBkill\fP(2)).
.PP
Процесс может создать потомка процессорного набора, если у него есть доступ
и право на запись в родительский каталог процессорного набора. Он может
изменить ЦП или узлы памяти в процессорном наборе, если у него есть доступ к
каталогу этого процессорного набора (право на выполнение на каждый
родительский каталог) и право на запись в соответствующий файл \fIcpus\fP или
\fImems\fP.
.PP
Есть незначительное отличие между тем, как эти права вычисляются здесь и при
обычных операциях в файловой системе. Ядро интерпретирует относительные
пути, начиная с текущего рабочего каталога процесса. Даже если он работает с
файлом процессорного набора, относительные пути интерпретируются
относительно текущего рабочего каталога процесса, а не относительно текущего
процессорного набора процесса. Единственные способы, в которых могут
использоваться пути процессорного набора относительно текущего процессорного
набора процесса это когда текущий рабочий каталог процесса совпадает с его
каталогом процессорного набора (сначала выполняется \fBcd\fP или \fBchdir\fP(2) в
каталог его процессорного набора в \fI/dev/cpuset\fP, что немного необычно) или
если некий код пользователя преобразует относительный путь процессорного
набора в полный путь в файловой системе.
.PP
.\" ================== WARNINGS ==================
В теории это означает, то код пользователя должен задавать процессорные
наборы с помощью абсолютных путей, для чего требуется знать точку
монтирования файловой системы процессорного набора (обычно, но
необязательно, \fI/dev/cpuset\fP). На практике, автор кода уровня пользователя
делает простое предположение, что если файловая система процессорного набора
монтируется, то в \fI/dev/cpuset\fP. Кроме этого в порядке вещей при написании
корректного пользовательского кода выполняется проверка наличия псевдо\-файла
\fI/dev/cpuset/tasks\fP, чтобы убедиться, что файловая система процессорного
набора смонтирована.
.SH ПРЕДУПРЕЖДЕНИЯ
.SS "Включение memory_pressure"
По умолчанию, индивидуальный файл \fIcpuset.memory_pressure\fP всегда содержит
ноль (0). Если это свойство не включить записью «1» в псевдо\-файл
\fI/dev/cpuset/cpuset.memory_pressure_enabled\fP, то ядро не вычисляет
индивидуальное значение \fImemory_pressure\fP.
.SS "Использование команды echo"
.\" Gack!  csh(1)'s echo does this
При использовании команды \fBecho\fP в оболочке командной строки для изменения
значений файлов процессорного набора остерегайтесь встроенной в некоторые
оболочки команды \fBecho\fP; она не отображает сообщение об ошибке системного
вызова \fBwrite\fP(2). Например, если команда:
.PP
.in +4n
.EX
echo 19 > cpuset.mems
.EE
.in
.PP
завершится с ошибкой из\-за того, что узел памяти 19 не разрешён (возможно,
текущая система не имеет узла памяти 19), то команда \fBecho\fP может не выдать
ошибки. Для изменения настроек файла процессорного набора лучше использовать
внешнюю команду \fB/bin/echo\fP , так как она выводит ошибки \fBwrite\fP(2),
например:
.PP
.in +4n
.EX
/bin/echo 19 > cpuset.mems
/bin/echo: write error: Invalid argument
.EE
.in
.\" ================== EXCEPTIONS ==================
.SH ИСКЛЮЧЕНИЯ
.SS "Размещение в памяти"
Не каждое выделение системной памяти ограничивается процессорным набором по
следующим причинам:
.PP
Если используется возможность горячего удаления всех ЦП, которые в настоящее
время назначены в процессорный набор, то ядро автоматически обновит
\fIcpus_allowed\fP у всех процессов, подключённых к ЦП в этом процессорном
наборе, позволяя все ЦП. Когда доступна возможность горячего удаления узлов
памяти, то подобное исключение применяется и для них. В общем, ядро
предпочитает нарушить размещения процессорного набора, а не дать голодать
процессу, у которого все доступные ЦП или узлы памяти
выключились. Пользовательский код должен перенастроить процессорные наборы,
чтобы ссылаться только на включённые ЦП и узлы памяти, когда используется
горячее подключение или удаление этих ресурсов.
.PP
Некоторые критичные для ядра запросы на выделение внутренней памяти,
помеченные GFP_ATOMIC, должны быть выполнены немедленно. Ядро может
отбросить какой\-нибудь запрос или сломается, если одно из таких выделений
завершится с ошибкой. Если такой запрос не может быть выполнен в текущем
процессорном наборе процесса, то мы ослабляем требования процессорного
набора, и ищем память где сможем найти. Лучше нарушить указания
процессорного набора, чем испортить ядро.
.PP
Выделения памяти, запрашиваемые драйверами ядра при обработке прерывания, не
относятся к контексту процесса и не ограничиваются процессорными наборами.
.SS "Переименование процессорных наборов"
.\" ================== ERRORS ==================
Для переименования процессорных наборов можно использовать системный вызов
\fBrename\fP(2). Поддерживается только простое переименование; то есть
разрешено изменение имени каталога процессорного набора — переместить
каталог в другой каталог нельзя.
.SH ОШИБКИ
Реализация процессорных наборов в ядре Linux изменяет \fIerrno\fP для указания
причины ошибки системного вызова при работе с процессорными наборами.
.PP
Возможные значения \fIerrno\fP и их смысл при ошибках, возникающих при работе с
процессорным набором:
.TP 
\fBE2BIG\fP
Попытка \fBwrite\fP(2) записать в специальный файл процессорного набора с
длиной, превышающей установленное ядром ограничение на длину таких записей.
.TP 
\fBEACCES\fP
Попытка \fBwrite\fP(2) записать ID (PID) процесса в файл процессорного набора
\fItasks\fP при нехватке прав для перемещения этого процесса.
.TP 
\fBEACCES\fP
Попытка добавить, с помощью \fBwrite\fP(2), ЦП или узел памяти в процессорный
набор, когда этот ЦП или узел памяти отсутствует в его родителе.
.TP 
\fBEACCES\fP
Попытка назначить, с помощью \fBwrite\fP(2), задать \fIcpuset.cpu_exclusive\fP или
\fIcpuset.mem_exclusive\fP для процессорного набора, чей родитель не имеет
таких флагов.
.TP 
\fBEACCES\fP
Попытка \fBwrite\fP(2) записать в файл \fIcpuset.memory_pressure\fP.
.TP 
\fBEACCES\fP
Попытка создать файл в каталоге процессорного набора.
.TP 
\fBEBUSY\fP
Попытка удалить, с помощь \fBrmdir\fP(2), процессорный набор с прикреплёнными
процессами.
.TP 
\fBEBUSY\fP
Попытка удалить, с помощь \fBrmdir\fP(2), процессорный набор с дочерними
процессорными наборами.
.TP 
\fBEBUSY\fP
Попытка удалить ЦП или узел памяти из процессорного набора, который также
есть в потомке этого процессорного набора.
.TP 
\fBEEXIST\fP
Попытка создать, с помощью \fBmkdir\fP(2), процессорный набор, который уже
существует.
.TP 
\fBEEXIST\fP
Попытка \fBrename\fP(2) задать процессорному набору имя, которое уже
существует.
.TP 
\fBEFAULT\fP
Попытка \fBread\fP(2) прочитать или \fBwrite\fP(2) записать в файл процессорного
набора используя буфер, который расположен вне доступного адресного
пространства записи процесса.
.TP 
\fBEINVAL\fP
Попытка изменить процессорный набор с помощью \fBwrite\fP(2) способом, который
нарушает флаг \fIcpu_exclusive\fP или \fImem_exclusive\fP этого процессорного
набора или его одноуровневого собрата.
.TP 
\fBEINVAL\fP
Попытка \fBwrite\fP(2) записать пустой список \fIcpuset.cpus\fP или \fIcpuset.mems\fP
в процессорный набор, к которому прикреплёны процессы или дочерние
процессорные наборы.
.TP 
\fBEINVAL\fP
Попытка \fBwrite\fP(2) записать список \fIcpuset.cpus\fP или \fIcpuset.mems\fP,
который включает диапазон со вторым числом, меньшим первого числа.
.TP 
\fBEINVAL\fP
Попытка \fBwrite\fP(2) записать список \fIcpuset.cpus\fP или \fIcpuset.mems\fP,
который содержит некорректный символ в строке.
.TP 
\fBEINVAL\fP
Попытка \fBwrite\fP(2) записать список в файл \fIcpuset.cpus\fP, в котором нет ни
одного работающего ЦП.
.TP 
\fBEINVAL\fP
Попытка \fBwrite\fP(2) записать список в файл \fIcpuset.mems\fP, в котором нет ни
одного работающего узла памяти.
.TP 
\fBEINVAL\fP
Попытка \fBwrite\fP(2) записать список в файл \fIcpuset.mems\fP, в котором есть
узел без памяти.
.TP 
\fBEIO\fP
Попытка \fBwrite\fP(2) записать строку в файл \fItasks\fP процессорного набора,
которая не начинается с десятичного числа ASCII.
.TP 
\fBEIO\fP
Попытка \fBrename\fP(2) переименовать процессорный набор в другой каталог.
.TP 
\fBENAMETOOLONG\fP
Попытка \fBread\fP(2) прочитать из файла \fI/proc/<pid>/cpuset\fP путь
процессорного набора, который больше размера страницы ядра.
.TP 
\fBENAMETOOLONG\fP
Попытка создать с помощью \fBmkdir\fP(2) процессорный набор, имя базового
каталога которого длиннее 255 символов.
.TP 
\fBENAMETOOLONG\fP
Попытка создать с помощью \fBmkdir\fP(2) процессорный набор, полное имя
которого, включая префикс точки монтирования (обычно «/dev/cpuset/»),
длиннее 4095 символов.
.TP 
\fBENODEV\fP
Процессорный набор был удалён другим процессом одновременно с тем, когда
была попытка \fBwrite\fP(2) записать в один из псевдо\-файлов в каталоге
процессорного набора.
.TP 
\fBENOENT\fP
Попытка создать с помощью \fBmkdir\fP(2) процессорный набор, родителя которого
не существует.
.TP 
\fBENOENT\fP
Попытка выполнить \fBaccess\fP(2) или \fBopen\fP(2) для несуществующего файла в
каталоге процессорного набора.
.TP 
\fBENOMEM\fP
В ядре недостаточно памяти; может возникать при различных системных вызовах
для работы с процессорным набором, но только если в системе очень мало
памяти.
.TP 
\fBENOSPC\fP
Попытка \fBwrite\fP(2) записать ID (PID) процесса в файл процессорного набора
\fItasks\fP, когда у процессорного набора пустое значение в \fIcpuset.cpus\fP или
\fIcpuset.mems\fP.
.TP 
\fBENOSPC\fP
Попытка \fBwrite\fP(2) записать пустое значение в \fIcpuset.cpus\fP или
\fIcpuset.mems\fPпроцессорного набора, у которого есть прикреплённые задачи.
.TP 
\fBENOTDIR\fP
Попытка \fBrename\fP(2) переименовать несуществующий процессорный набор.
.TP 
\fBEPERM\fP
Попытка удалить файл из каталога процессорного набора.
.TP 
\fBERANGE\fP
Указанный список \fIcpuset.cpus\fP или \fIcpuset.mems\fP в ядре, который содержит
слишком большое число для ядра, чтобы задать его битовой маской.
.TP 
\fBESRCH\fP
.\" ================== VERSIONS ==================
Попытка \fBwrite\fP(2) записать ID (PID) процесса несуществующего процесса в
файл процессорного набора \fItasks\fP.
.SH ВЕРСИИ
.\" ================== NOTES ==================
Свойство процессорного набора появилось в ядре Linux версии 2.6.12.
.SH ЗАМЕЧАНИЯ
.\" ================== BUGS ==================
Несмотря на имя, параметр \fIpid\fP в действительности является ID нити, и
каждая нить группы нитей может быть прикреплена к различным процессорным
наборам. В аргументе \fIpid\fP может передаваться значение, возвращаемое
вызовом \fBgettid\fP(2).
.SH ДЕФЕКТЫ
.\" ================== EXAMPLE ==================
Файлы \fIcpuset.memory_pressure\fP процессорного набора можно открывать для
записи, создания и обрезания, но после этого \fBwrite\fP(2) завершается с
ошибкой \fIerrno\fP, равной \fBEACCES\fP, и параметры создания и обрезания в
\fBopen\fP(2) не учитываются.
.SH ПРИМЕР
В следующих примерах показано получения и установка параметров процессорного
набора с помощью команд оболочки.
.SS "Создание и прикрепление к процессорному набору."
Для создания нового процессорного набора и прикрепления текущей оболочки
команд к нему выполняются следующие шаги:
.PP
.PD 0
.IP 1) 4
mkdir /dev/cpuset (если уже не сделано)
.IP 2)
mount \-t cpuset none /dev/cpuset (если уже не сделано)
.IP 3)
Создание нового процессорного набора с помощью \fBmkdir\fP(1).
.IP 4)
Назначение ЦП и узлов памяти новому процессорному набору.
.IP 5)
Прикрепление оболочки к новому процессорному набору.
.PD
.PP
Например, следующая последовательность команд создаёт новый процессорный
набор с именем «Charlie», содержащий только ЦП 2 и 3, и узел памяти 1, а
затем прикрепляет к этому процессорному набору текущую оболочку.
.PP
.in +4n
.EX
$\fB mkdir /dev/cpuset\fP
$\fB mount \-t cpuset cpuset /dev/cpuset\fP
$\fB cd /dev/cpuset\fP
$\fB mkdir Charlie\fP
$\fB cd Charlie\fP
$\fB /bin/echo 2\-3 > cpuset.cpus\fP
$\fB /bin/echo 1 > cpuset.mems\fP
$\fB /bin/echo $$ > tasks\fP
# Текущая оболочка теперь работает в процессорном наборе Charlie
# Следующая строка должна вывести /Charlie
$\fB cat /proc/self/cpuset\fP
.EE
.in
.\"
.SS "Перенос задания в другие узлы памяти."
Чтобы перенести задание (набор процессов, присоединённых к процессорному
набору) на другие ЦП и узлы памяти в системе, включая перемещение страниц
памяти, выделенных под это задание, выполните следующие шаги:
.PP
.PD 0
.IP 1) 4
Предположим, мы хотим перенести задание из процессорного набора \fIalpha\fP (ЦП
4\-\(en7 узлы памяти 2\(en3) в новый процессорный набор \fIbeta\fP (ЦП 16\-\(en19
и узлы памяти 8\(en9).
.IP 2)
Сначала создадим новый процессорный набор \fIbeta\fP.
.IP 3)
Затем включим ЦП 16\(en19 и узлы памяти 8\(en9 в \fIbeta\fP.
.IP 4)
Затем включим флаг \fImemory_migration\fP в \fIbeta\fP.
.IP 5)
Затем переместим каждый процесс из \fIalpha\fP в \fIbeta\fP.
.PD
.PP
Всё это выполняет следующая последовательность команд:
.PP
.in +4n
.EX
$\fB cd /dev/cpuset\fP
$\fB mkdir beta\fP
$\fB cd beta\fP
$\fB /bin/echo 16\-19 > cpuset.cpus\fP
$\fB /bin/echo 8\-9 > cpuset.mems\fP
$\fB /bin/echo 1 > cpuset.memory_migrate\fP
$\fB while read i; do /bin/echo $i; done < ../alpha/tasks > tasks\fP
.EE
.in
.PP
Команды выше должны переместить все процессы из \fIalpha\fP в \fIbeta\fP, и всю
память этих процессов с узлов памяти 2\(en3 на узлы памяти 8\(en9,
соответственно.
.PP
Заметим, что последний шаг не сделан как:
.PP
.in +4n
.EX
$\fB cp ../alpha/tasks tasks\fP
.EE
.in
.PP
Цикл \fIwhile\fP, а не гораздо более простая команда \fBcp\fP(1), необходим, так
как только один PID процесса за раз записывается в файл \fItasks\fP.
.PP
Того же (запись одного PID за раз) как в цикле \fIwhile\fP можно достичь более
эффективно несколькими командами и с синтаксисом, который доступен в любой
оболочке, но выглядит непонятно: используя параметр \fB\-u\fP (не
буферизировать) в \fBsed\fP(1):
.PP
.in +4n
.EX
$\fB sed \-un p < ../alpha/tasks > tasks\fP
.EE
.in
.\" ================== SEE ALSO ==================
.SH "СМОТРИТЕ ТАКЖЕ"
\fBtaskset\fP(1), \fBget_mempolicy\fP(2), \fBgetcpu\fP(2), \fBmbind\fP(2),
\fBsched_getaffinity\fP(2), \fBsched_setaffinity\fP(2), \fBsched_setscheduler\fP(2),
\fBset_mempolicy\fP(2), \fBCPU_SET\fP(3), \fBproc\fP(5), \fBcgroups\fP(7), \fBnuma\fP(7),
\fBsched\fP(7), \fBmigratepages\fP(8), \fBnumactl\fP(8)
.PP
.\" commit 45ce80fb6b6f9594d1396d44dd7e7c02d596fef8
Файл \fIDocumentation/cgroup\-v1/cpusets.txt\fP из дерева исходного кода ядра
Linux (или \fIDocumentation/cpusets.txt\fP до Linux 2.6.29)
