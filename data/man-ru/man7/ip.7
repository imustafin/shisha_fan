.\" -*- mode: troff; coding: UTF-8 -*-
'\" t
.\" This man page is Copyright (C) 1999 Andi Kleen <ak@muc.de>.
.\"
.\" %%%LICENSE_START(VERBATIM_ONE_PARA)
.\" Permission is granted to distribute possibly modified copies
.\" of this page provided the header is included verbatim,
.\" and in case of nontrivial modification author and date
.\" of the modification is added to the header.
.\" %%%LICENSE_END
.\"
.\" $Id: ip.7,v 1.19 2000/12/20 18:10:31 ak Exp $
.\"
.\" FIXME The following socket options are yet to be documented
.\"
.\" 	IP_XFRM_POLICY (2.5.48)
.\"	    Needs CAP_NET_ADMIN
.\"
.\" 	IP_IPSEC_POLICY (2.5.47)
.\"	    Needs CAP_NET_ADMIN
.\"
.\" 	IP_PASSSEC (2.6.17)
.\" 	    Boolean
.\"	    commit 2c7946a7bf45ae86736ab3b43d0085e43947945c
.\"	    Author: Catherine Zhang <cxzhang@watson.ibm.com>
.\"
.\"	IP_MINTTL (2.6.34)
.\"	    commit d218d11133d888f9745802146a50255a4781d37a
.\"	    Author: Stephen Hemminger <shemminger@vyatta.com>
.\"
.\"	MCAST_JOIN_GROUP (2.4.22 / 2.6)
.\"
.\"	MCAST_BLOCK_SOURCE (2.4.22 / 2.6)
.\"
.\"	MCAST_UNBLOCK_SOURCE (2.4.22 / 2.6)
.\"
.\"	MCAST_LEAVE_GROUP (2.4.22 / 2.6)
.\"
.\"	MCAST_JOIN_SOURCE_GROUP (2.4.22 / 2.6)
.\"
.\"	MCAST_LEAVE_SOURCE_GROUP (2.4.22 / 2.6)
.\"
.\"	MCAST_MSFILTER (2.4.22 / 2.6)
.\"
.\"	IP_UNICAST_IF (3.4)
.\"	    commit 76e21053b5bf33a07c76f99d27a74238310e3c71
.\"	    Author: Erich E. Hoover <ehoover@mines.edu>
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH IP 7 2019\-03\-06 Linux "Руководство программиста Linux"
.SH ИМЯ
ip \- реализация протокола IPv4 в Linux
.SH ОБЗОР
\fB#include <sys/socket.h>\fP
.br
.\" .B #include <net/netinet.h> -- does not exist anymore
.\" .B #include <linux/errqueue.h> -- never include <linux/foo.h>
\fB#include <netinet/in.h>\fP
.br
\fB#include <netinet/ip.h> \fP/* включает предыдущий */
.PP
\fItcp_socket\fP\fB = socket(AF_INET, SOCK_STREAM, 0);\fP
.br
\fIudp_socket\fP\fB = socket(AF_INET, SOCK_DGRAM, 0);\fP
.br
\fIraw_socket\fP\fB = socket(AF_INET, SOCK_RAW, \fP\fIprotocol\fP\fB);\fP
.SH ОПИСАНИЕ
В Linux реализован протокол Интернета (Internet Protocol, IP) версии 4,
описанный в RFC\ 791 и RFC\ 1122. В модуле \fBip\fP содержится реализация
второго уровня групповых многоадресных сообщений, которая соответствует RFC\ 1112. Кроме того, в нём имеется маршрутизатор IP с фильтрацией пакетов.
.PP
Программный интерфейс совместим с интерфейсом сокетов BSD. Более подробную
информацию смотрите в \fBsocket\fP(7).
.PP
Сокет IP создаётся с помощью \fBsocket\fP(2):
.PP
    socket(AF_INET, socket_type, protocol);
.PP
Возможные типы сокета (\fIsocket_type\fP): \fBSOCK_STREAM\fP (для открытия сокета
\fBtcp\fP(7)), \fBSOCK_DGRAM\fP (для открытия сокета \fBudp\fP(7)), \fBSOCK_RAW\fP (для
открытия сокета \fBraw\fP(7) с прямым доступом к протоколу IP). В \fIprotocol\fP
задаётся протокол IP, который указывается в IP\-заголовке принимаемых или
отправляемых пакетов. Допустимые значения для параметра \fIprotocol\fP: 0 и
\fBIPPROTO_TCP\fP — для сокетов TCP, 0 и \fBIPPROTO_UDP\fP — для сокетов UDP. Для
\fBSOCK_RAW\fP можно указать любой из IP\-протоколов, описанных в RFC\ 1700 и
зарегистрированных в IANA.
.PP
Если процесс хочет принимать новые входящие пакеты или соединения, то он
должен связать сокет с адресом локального интерфейса с помощью
\fBbind\fP(2). Каждый IP\-сокет может быть связан только с одной задаваемой
локальной парой (адрес, порт). Если в вызове \fBbind\fP(2) указать
\fBINADDR_ANY\fP, то сокет будет связан со \fIвсеми\fP локальными
интерфейсами. При вызове \fBlisten\fP(2) для несвязанного сокета происходит
автоматическая привязка к произвольно выбранному свободному порту с
локальным адресом \fBINADDR_ANY\fP. При вызове \fBconnect\fP(2) для несвязанного
сокета происходит автоматическая привязка к произвольно выбранному
свободному порту или используемому общему порту с локальным адресом
\fBINADDR_ANY\fP.
.PP
После закрытия связанного локального TCP\-сокета его адрес будет недоступен в
течение некоторого времени, если только не был установлен флаг
\fBSO_REUSEADDR\fP. Следует проявлять осторожность при использовании этого
флага, поскольку это делает TCP менее надежным.
.SS "Формат адреса"
Адрес IP\-сокета определяется как комбинация IP\-адреса интерфейса и номера
порта. В самом протоколе IP нет номеров портов, они реализуются протоколами
более высокого уровня, например \fBudp\fP(7) и \fBtcp\fP(7). У неструктурированных
(raw) сокетов номер протокола IP указывается в \fIsin_port\fP.
.PP
.in +4n
.EX
struct sockaddr_in {
    sa_family_t    sin_family; /* семейство адресов: AF_INET */
    in_port_t      sin_port;   /* порт сокета в сетевом порядке
                                  байт */
    struct in_addr sin_addr;   /* Интернет\-адрес */
};

/* Интернет\-адрес */
struct in_addr {
    uint32_t       s_addr;     /* адрес в сетевом порядке байт */
};
.EE
.in
.PP
Значение \fIsin_family\fP всегда устанавливается в \fBAF_INET\fP. Это обязательно;
в Linux 2.2 большая часть сетевых функций возвращает код ошибки \fBEINVAL\fP,
если это условие не выполняется. В \fIsin_port\fP указывается номер порта в
сетевом порядке байт. Порты, номера которых меньше 1024, называются
\fIпривилегированными портами\fP (или, иногда, \fIзарезервированными
портами\fP). Только привилегированные процессы (в Linux: процессы с мандатом
\fBCAP_NET_BIND_SERVICE\fP в пользовательском пространстве имён, управляющим
его сетевым пространством имён) могут быть связаны с этими сокетами с
помощью \fBbind\fP(2). Заметим, что у неструктурированного протокола IPv4 нет
понятия портов как таковых, они реализуются только протоколами более
высокого уровня, типа \fBtcp\fP(7) и \fBudp\fP(7).
.PP
В \fIsin_addr\fP указывается IP\-адрес узла. В поле \fIs_addr\fP структуры \fIstruct
in_addr\fP содержится адрес интерфейса узла в сетевом порядке байт. Значение
\fIin_addr\fP должно быть одним из \fBINADDR_*\fP (например, \fBINADDR_LOOPBACK\fP)
установленное \fBhtonl\fP(3), или с помощью библиотечных функций
\fBinet_aton\fP(3), \fBinet_addr\fP(3), \fBinet_makeaddr\fP(3) или напрямую с помощью
преобразователя имён (смотрите \fBgethostbyname\fP(3)).
.PP
.\" Leave a loophole for XTP @)
Адреса IPv4 делятся на однозначные (unicast), широковещательные (broadcast)
и многоадресные (multicast). Однозначный адрес указывает на один интерфейс
узла, широковещательный адрес указывает на  все узлы в сети, а многоадресный
указывает на все узлы многоадресной (multicast group). Дейтаграммы могут
посылаться или приниматься по широковещательным адресам только, если для
сокета установлен флаг \fBSO_BROADCAST\fP. В текущей реализации сокетам,
ориентированным на соединения, разрешено иметь только однозначные адреса.
.PP
Заметим, что значение адреса и порта всегда хранится в сетевом порядке
байт. В частности, это означает, что требуется вызывать \fBhtons\fP(3) для
числа, обозначающего порт. Все функции из стандартной библиотеки,
используемые для работы с адресами/портами, используют сетевой порядок байт.
.PP
Есть несколько специальных адресов: \fBINADDR_LOOPBACK\fP (127.0.0.1) всегда
ссылается на локальный узел через интерфейс обратной петли; \fBINADDR_ANY\fP
(0.0.0.0) означает любой адрес для связывания; \fBINADDR_BROADCAST\fP
(255.255.255.255) означает любой узел и, по историческим причинам, при
связывании подобен \fBINADDR_ANY\fP.
.SS "Параметры сокета"
.\" or SOL_IP on Linux
IP поддерживает некоторые параметры сокета, относящиеся к протоколу, которые
могут быть установлены с помощью \fBsetsockopt\fP(2) и прочитаны с помощью
\fBgetsockopt\fP(2). Значением уровня (level) параметров сокета для IP является
\fBIPPROTO_IP\fP. Логический флаг в виде целого числа со значением ноль
означает «ложь», другие значения — «истина».
.PP
Если сокету передается неправильный параметр, то \fBgetsockopt\fP(2) и
\fBsetsockopt\fP(2) завершаются с ошибкой \fBENOPROTOOPT\fP.
.TP 
\fBIP_ADD_MEMBERSHIP\fP (начиная с Linux 1.2)
Присоединиться к многоадресной группе. В аргументе указывается структура
\fIip_mreqn\fP.
.PP
.in +4n
.EX
struct ip_mreqn {
    struct in_addr imr_multiaddr; /* IP\-адрес группы */
    struct in_addr imr_address;   /* IP локального
                                     интерфейса */
    int            imr_ifindex;   /* индекс интерфейса */
};
.EE
.in
.PP
.\" (i.e., within the 224.0.0.0-239.255.255.255 range)
В \fIimr_multiaddr\fP содержится адрес многоадресной группы, в которую
приложение хочет войти или выйти. Это должен быть правильный адрес
многоадресной рассылки (иначе \fBsetsockopt\fP(2) завершится с ошибкой
\fBEINVAL\fP). В \fIimr_address\fP указывается адрес локального интерфейса, через
который система должна войти в многоадресную группу; если указано значение
\fBINADDR_ANY\fP, то нужный интерфейс выбирается системой самостоятельно. В
\fIimr_ifindex\fP указывается индекс интерфейса, через который нужно
войти/выйти в группу \fIimr_multiaddr\fP, или 0, если интерфейс может быть
любым.
.IP
Структура \fIip_mreqn\fP доступна только начиная с Linux 2.2. Для
совместимости, старая структура \fIip_mreq\fP (существует с Linux 1.2)
по\-прежнему поддерживается; она отличается от \fIip_mreqn\fP только отсутствием
поля \fIimr_ifindex\fP (при передаче ядро определяет нужную структуру исходя из
размера, переданного в \fIoptlen\fP).
.IP
.\"
\fBIP_ADD_MEMBERSHIP\fP допустим только для \fBsetsockopt\fP(2).
.TP 
\fBIP_ADD_SOURCE_MEMBERSHIP\fP (начиная с Linux 2.4.22 / 2.5.68)
Присоединиться к многоадресной группе и разрешить принимать данные только из
указанного источника. Аргументом является структура \fIip_mreq_source\fP.
.PP
.in +4n
.EX
struct ip_mreq_source {
    struct in_addr imr_multiaddr;  /* IP многоадресной
                                      группы */
    struct in_addr imr_interface;  /* IP\-адрес локального
                                      интерфейса */
    struct in_addr imr_sourceaddr; /* IP\-адрес многоадресного
                                      источника */
};
.EE
.in
.PP
Структура \fIip_mreq_source\fP похожа на \fIip_mreqn\fP, которая описана в разделе
о \fBIP_ADD_MEMBERSIP\fP. Поле \fIimr_multiaddr\fP содержит адрес многоадресной
группы, к которой приложение хочет подключиться или выйти. Поле
\fIimr_interface\fP содержит адрес локального интерфейса, с которого система
должна подключаться к многоадресной группе. В поле \fIimr_sourceaddr\fP
содержится адрес источника, из которого приложение хочет получать данные.
.IP
Для приёма данных из нескольких источников этот параметр можно использовать
несколько раз.
.TP 
\fBIP_BIND_ADDRESS_NO_PORT\fP (начиная с Linux 4.2)
.\" commit 90c337da1524863838658078ec34241f45d8394d
Информирует ядро, что не требуется резервировать эфемерный порт при
использовании \fBbind\fP(2) с номером порта 0. Позднее, порт будет
автоматически выбран при \fBconnect\fP(2); это позволяет использовать общий
исходящий порт пока уникальна связка 4\-х значений.
.TP 
\fBIP_BLOCK_SOURCE\fP (начиная с Linux 2.4.22 / 2.5.68)
Прекратить приём многоадресных данных из указанного источника заданной
группы. Это допустимо, если приложение подписывалось на многоадресную группу
с помощью \fBIP_ADD_MEMBERSHIP\fP или \fBIP_ADD_SOURCE_MEMBERSHIP\fP.
.IP
Аргументом является структура \fIip_mreq_source\fP, описанная в разделе о
\fBIP_ADD_SOURCE_MEMBERSHIP\fP.
.TP 
\fBIP_DROP_MEMBERSHIP\fP (начиная с Linux 1.2)
Выйти из многоадресной группы. Аргументом является структура \fIip_mreqn\fP или
\fIip_mreq\fP, описана в \fBIP_ADD_MEMBERSHIP\fP.
.TP 
\fBIP_DROP_SOURCE_MEMBERSHIP\fP (начиная с Linux 2.4.22 / 2.5.68)
Выйти из указанной группы — то есть прекратить приём данных указанной
многоадресной группы, которые поступают из указанного источника. Если
приложение подписано на несколько источников одной группы, то данные из
оставшихся источников продолжат поступать. Чтобы прекратить приём данных из
всех источников сразу, используйте \fBIP_DROP_MEMBERSHIP\fP.
.IP
Аргументом является структура \fIip_mreq_source\fP, описанная в разделе о
\fBIP_ADD_SOURCE_MEMBERSHIP\fP.
.TP 
\fBIP_FREEBIND\fP (начиная с Linux 2.4)
.\" Precisely: 2.4.0-test10
Этот логический параметр позволяет привязаться (если значение равно
«истина») к IP\-адресу, который не является локальным или (пока) не
существует. Это позволяет прослушивать сокет, не имея нижележащего сетевого
интерфейса или назначенного динамического IP\-адреса, которых может ещё не
быть, когда приложение пытается связаться с ним. Этот параметр имеет
эквивалентный интерфейс \fIip_nonlocal_bind\fP (описан далее) в \fI/proc\fP на
каждый сокет.
.TP 
\fBIP_HDRINCL\fP (начиная с Linux 2.0)
Если значение равно «истина», то это означает, что пользователь добавил
заголовок IP в начало своих данных. Допустим только для сокетов \fBSOCK_RAW\fP;
более подробную информацию смотрите в \fBraw\fP(7). Если этот флаг установлен,
то значения, заданные параметрами \fBIP_OPTIONS\fP, \fBIP_TTL\fP и \fBIP_TOS\fP,
игнорируются.
.TP 
\fBIP_MSFILTER\fP (начиная с Linux 2.4.22 / 2.5.68)
Этот параметр предоставляет доступ к расширенному программному интерфейсу
фильтрации. Аргументом является структура \fIip_msfilter\fP.
.PP
.in +4n
.EX
struct ip_msfilter {
    struct in_addr imsf_multiaddr; /* IP\-адрес
                                      многоадресной группы */
    struct in_addr imsf_interface; /* IP\-адрес локального
                                      интерфейса */
    uint32_t       imsf_fmode;     /* Режим фильтрации */

    uint32_t       imsf_numsrc;    /* Количество источников в
                                      следующем массиве */
    struct in_addr imsf_slist[1];  /* Массив адресов
                                      источников */
};
.EE
.in
.PP
Для задания режима фильтрации существует два макроса — \fBMCAST_INCLUDE\fP и
\fBMCAST_EXCLUDE\fP. Также, существует макрос \fBIP_MSFILTER_SIZE\fP(n), которым
можно определить количество памяти, требуемой для хранения структуры
\fIip_msfilter\fP с \fIn\fP источниками в списке источников.
.IP
Полное описание фильтрации многоадресных источников групп смотрите в RFC
3376.
.TP 
\fBIP_MTU\fP (начиная с Linux 2.2)
.\" Precisely: 2.1.124
Возвращает известное в данный момент значение MTU маршрута текущего
сокета. Возвращается целое число.
.IP
Параметр \fBIP_MTU\fP допускается только для \fBgetsockopt\fP(2) и может
использоваться только для подключённого сокета.
.TP 
\fBIP_MTU_DISCOVER\fP (начиная с Linux 2.2)
.\" Precisely: 2.1.124
Устанавливает или возвращает значение Path MTU Discovery (обнаружение
значения MTU маршрута) для сокета. Если он установлен, то Linux будет
производить обнаружение значения MTU маршрута для сокетов \fBSOCK_STREAM\fP
согласно RFC\ 1191. Для сокетов не \fBSOCK_STREAM\fP при значении
\fBIP_PMTUDISC_DO\fP у всех исходящих пакетов будет устанавливаться флаг
запрета фрагментации. Ответственность за разбивку данных на пакеты согласно
размеру MTU, и за выполнение, при необходимости, повторной передачи данных,
лежит на пользователе. Ядро будет отвергать пакеты (с ошибкой \fBEMSGSIZE\fP),
размер которых больше текущего значения MTU у маршрута. При значении
\fBIP_PMTUDISC_WANT\fP дейтаграмма будет фрагментироваться по размеру MTU, если
требуется, иначе устанавливается флаг запрета фрагментации.
.IP
Системное значение по умолчанию можно переключать между \fBIP_PMTUDISC_WANT\fP
и \fBIP_PMTUDISC_DONT\fP, записывая, соответственно, нулевое и ненулевое
значение в файл \fI/proc/sys/net/ipv4/ip_no_pmtu_disc\fP.
.TS
tab(:);
c l
l l.
Значение определения маршрута MTU:Значение
IP_PMTUDISC_WANT:Использовать для каждого маршрута своё значение.
IP_PMTUDISC_DONT:Никогда не выполнять обнаружение значения MTU маршрута.
IP_PMTUDISC_DO:Всегда выполнять обнаружение значения MTU маршрута.
IP_PMTUDISC_PROBE:Установить DF, но игнорировать маршрут MTU.
.TE
.sp 1
Если значение Path MTU Discovery задано, то ядро автоматически следит за MTU
маршрута для каждого удалённого узла. Когда с некоторым узлом установлено
соединение с помощью \fBconnect\fP(2), текущее значение MTU маршрута можно
легко получить через параметр сокета \fBIP_MTU\fP (например, после
возникновения ошибки \fBEMSGSIZE\fP). Значение MTU может со временем
меняться. Для сокетов без установления соединения, которые имеют несколько
узлов\-получателей, новое значение MTU для заданного узла назначения может
быть получено с помощью очереди ошибок (смотрите \fBIP_RECVERR\fP). При каждом
входящем сообщении об обновлении MTU в очередь будет добавляться новая
ошибка.
.IP
Во время процесса обнаружения MTU начальные пакеты от дейтаграмных сокетов
могут быть отброшены. Приложения, использующие UDP, должны учитывать это и
не думать, что эти пакеты будут переданы повторно.
.IP
Чтобы запустить процесс обнаружения MTU маршрута для сокетов без
установления соединения сначала можно установить большой размер дейтаграммы
(с размером заголовка до 64 килобайт) и сокращать его при изменении MTU
маршрута.
.IP
Чтобы получить начальную оценку MTU маршрута, соедините дейтаграмный сокет с
адресом назначения, используя \fBconnect\fP(2), и узнайте значение MTU путем
вызова \fBgetsockopt\fP(2) с параметром \fBIP_MTU\fP.
.IP
Возможно реализовать обнаружение MTU согласно RFC 4821 с помощью сокетов
типа \fBSOCK_DGRAM\fP или \fBSOCK_RAW\fP, установив значение \fBIP_PMTUDISC_PROBE\fP
(доступно, начиная с Linux 2.6.22). В частности, это также полезно для
инструментов диагностики, таких как \fBtracepath\fP(8), которым нужно умышленно
посылать проверочные пакеты большего размера, чем исследуемый Path MTU.
.TP 
\fBIP_MULTICAST_ALL\fP (since Linux 2.6.31)
Может использоваться для изменения политики доставки многоадресных сообщений
в сокеты, подсоединённые к шаблонному (wildcard) адресу
\fBINADDR_ANY\fP. Аргументом является логическое целое (по умолчанию 1). Если
значение равно 1, то сокет будет принимать сообщения от всех групп, к
которым было выполнено присоединение глобально всей системы. В противном
случае будут доставляться сообщения от групп, к которым было выполнено
присоединение явным образом(например, с помощью \fBIP_ADD_MEMBERSHIP\fP) на
этом сокете.
.TP 
\fBIP_MULTICAST_IF\fP (начиная с Linux 1.2)
.\" net: IP_MULTICAST_IF setsockopt now recognizes struct mreq
.\" Commit: 3a084ddb4bf299a6e898a9a07c89f3917f0713f7
Назначает локальное устройство для многоадресного группового сокета
(multicast socket). Аргументом для \fBsetsockopt\fP(2) является структура
\fIip_mreqn\fP или \fIip_mreq\fP (начиная с Linux 3.5), подобная
\fBIP_ADD_MEMBERSHIP\fP или структуре \fIin_addr\fP (при передаче ядро определяет
нужную структуру исходя из размера, переданного в \fIoptlen\fP). Для
\fBgetsockopt\fP(2) аргументом является структура \fIin_addr\fP.
.TP 
\fBIP_MULTICAST_LOOP\fP (начиная с Linux 1.2)
Устанавливает или возвращает логический флаг в виде целого числа, в
зависимости от того, будут ли пакеты, использующие многоадресную адресацию,
закольцовываться на локальные сокеты.
.TP 
\fBIP_MULTICAST_TTL\fP (начиная с Linux 1.2)
Устанавливает или возвращает значение времени существования (time\-to\-live)
для многоадресных исходящих из этого сокета пакетов, использующих
многоадресную адресацию. Для подобных пакетов очень важно установить
наименьшее возможное значение TTL. По умолчанию оно равно 1, это значит, что
многоадресные пакеты не выйдут за пределы локальной сети, если только
пользовательская программа явно не попросит этого. Значением аргумента
является целое число.
.TP 
\fBIP_NODEFRAG\fP (начиная с Linux 2.6.36)
Если установлен (аргумент не равен нулю), то на уровне netfilter запрещается
выполнять переборку (reassembly) исходящих пакетов. Значением аргумента
является целое число.
.IP
Этот параметр допускается только для сокетов с типом \fBSOCK_RAW\fP.
.TP 
\fBIP_OPTIONS\fP (начиная с Linux 2.0)
.\" Precisely: 1.3.30
Устанавливает или возвращает параметры IP, которые посылаются с каждым
пакетом из данного сокета. Аргументами являются указатель на буфер памяти с
этими параметрами и размер параметра. Системный вызов \fBsetsockopt\fP(2)
устанавливает параметры IP, связанные с сокетом. Для IPv4 максимальный
размер параметра IPv4 равен 40 байтам. Все возможные параметры перечислены в
RFC\ 791. Если пакет, устанавливающий соединение с сокетом типа
\fBSOCK_STREAM\fP, содержит параметры IP, то эти параметры IP (с
инвертированными заголовками маршрутизации) будут использоваться в этом
сокете. После установления соединения изменять параметры входящими пакетами
запрещено. По умолчанию, обработка всех параметров, связанных с
маршрутизацией от источника, отключена, но её можно включить через интерфейс
\fIaccept_source_route\fP в \fI/proc\fP. Другие параметры, например связанные с
временными отметками (timestamp), продолжают обрабатываться. Для
дейтаграмных сокетов параметры IP могут быть установлены только локальным
пользователем. Вызов \fBgetsockopt\fP(2) с параметром \fBIP_OPTIONS\fP помещает в
указанный буфер текущие параметры IP, используемые при отправке.
.TP 
\fBIP_PKTINFO\fP (начиная с Linux 2.2)
.\" Precisely: 2.1.68
Передает вспомогательное (ancillary) сообщение \fBIP_PKTINFO\fP с структурой
\fIpktinfo\fP, которая содержит некоторую информацию о входящем
пакете. Допускается только для сокетов, ориентированных на посылку
дейтаграмм. Аргументом является флаг, который сообщает сокету, нужно ли
посылать сообщение \fBIP_PKTINFO\fP или нет. Само сообщение может быть
послано/получено только в виде управляющего сообщения с пакетом, используя
\fBrecvmsg\fP(2) или \fBsendmsg\fP(2).
.IP
.in +4n
.EX
struct in_pktinfo {
    unsigned int   ipi_ifindex;  /* индекс интерфейса */
    struct in_addr ipi_spec_dst; /* локальный адрес */
    struct in_addr ipi_addr;     /* заголовок адреса
                                    назначения */
};
.EE
.in
.IP
.\" This field is grossly misnamed
\fIipi_ifindex\fP это уникальный индекс интерфейса, из которого был получен
этот пакет. \fIipi_spec_dst\fP это локальный адрес пакета, а \fIipi_addr\fP это
адрес назначения, указанный в заголовке пакета. Если параметр \fBIP_PKTINFO\fP
передаётся в \fBsendmsg\fP(2) и \fIipi_spec_dst\fP не равно нулю, то
\fIipi_spec_dst\fP будет использован как локальный адрес источника при
просмотре таблицы маршрутизации и для установки IP\-параметров маршрутизации
от источника. Если значение \fIipi_ifindex\fP не равно нулю, то при поиске в
таблице маршрутизации вместо значения \fIipi_spec_dst\fP используется первичный
локальный адрес интерфейса с указанным индексом.
.TP 
\fBIP_RECVERR\fP (начиная с Linux 2.2)
.\" Precisely: 2.1.15
.\" or SOL_IP on Linux
Делает передачу сообщений об ошибках более надёжной. Если этот параметр
установлен для дейтаграмного сокета, то все возникающие ошибки будут
поставлены в очередь ошибок, свою для каждого сокета. Для получения ошибки
при операции с сокетом пользователь может воспользоваться вызовом
\fBrecvmsg\fP(2) с установленным флагом \fBMSG_ERRQUEUE\fP. Структура
\fIsock_extended_err\fP, описывающая ошибку, будет передана в вспомогательном
сообщении с типом \fBIP_RECVERR\fP и уровнем \fBIPPROTO_IP\fP. Этот параметр
полезен для надежной обработки ошибок для сокетов без установления
соединения. В пакете с ошибкой из очереди ошибок, также содержится порция
полученных данных.
.IP
Вспомогательное сообщение \fBIP_RECVERR\fP содержит структуру
\fIsock_extended_err\fP:
.IP
.in +4n
.EX
#define SO_EE_ORIGIN_NONE    0
#define SO_EE_ORIGIN_LOCAL   1
#define SO_EE_ORIGIN_ICMP    2
#define SO_EE_ORIGIN_ICMP6   3

struct sock_extended_err {
    uint32_t ee_errno;   /* номер ошибки */
    uint8_t  ee_origin;  /* где возникла ошибка */
    uint8_t  ee_type;    /* тип */
    uint8_t  ee_code;    /* код */
    uint8_t  ee_pad;
    uint32_t ee_info;    /* дополнительная информация */
    uint32_t ee_data;    /* другие данные */
    /* Дальше могут следовать данные */
};

struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);
.EE
.in
.IP
В \fIee_errno\fP содержится номер ошибки в очереди. В \fIee_origin\fP содержится
код источника ошибки. Значение остальных полей зависит от протокола. Макрос
\fBSO_EE_OFFENDER\fP возвращает указатель на адрес сетевого объекта, в котором
возникла ошибка, согласно указанному указателю на вспомогательное
сообщение. Если адрес неизвестен, то поле \fIsa_family\fP структуры \fIsockaddr\fP
содержит \fBAF_UNSPEC\fP, и остальные поля \fIsockaddr\fP не определены.
.IP
.\" FIXME . Is it a good idea to document that? It is a dubious feature.
.\" On
.\" .B SOCK_STREAM
.\" sockets,
.\" .B IP_RECVERR
.\" has slightly different semantics. Instead of
.\" saving the errors for the next timeout, it passes all incoming
.\" errors immediately to the user.
.\" This might be useful for very short-lived TCP connections which
.\" need fast error handling. Use this option with care:
.\" it makes TCP unreliable
.\" by not allowing it to recover properly from routing
.\" shifts and other normal
.\" conditions and breaks the protocol specification.
Для IP структура \fIsock_extended_err\fP используется следующим образом:
значение поля \fIee_origin\fP устанавливается в \fBSO_EE_ORIGIN_ICMP\fP, если
ошибка получена из пакета ICMP, или в \fBSO_EE_ORIGIN_LOCAL\fP, если возникла
локальная ошибка. Неизвестные значения следует игнорировать. Значения полей
\fIee_type\fP и \fIee_code\fP устанавливаются исходя из значений полей типа и кода
заголовка ICMP. При ошибках \fBEMSGSIZE\fP поле \fIee_info\fP содержит
обнаруженную величину MTU. Сообщение также содержит структуру \fIsockaddr_in
узла\fP, вызвавшего ошибку, которая доступна через макрос
\fBSO_EE_OFFENDER\fP. Если источник неизвестен, то поле \fIsin_family\fP адреса,
возвращённого макросом \fBSO_EE_OFFENDER\fP, содержит значение
\fBAF_UNSPEC\fP. Если ошибка  возникла в сети, то все параметры IP
(\fBIP_OPTIONS\fP, \fBIP_TTL\fP и т.д.), которые используются сокетом и содержатся
в пакете с описанием ошибки, передаются в управляющих сообщениях. Данные
пакета, вызвавшего ошибку, возвращаются как нормальные данные. Заметьте, что
у TCP нет очереди ошибок; флаг \fBMSG_ERRQUEUE\fP нельзя использовать для
сокетов типа \fBSOCK_STREAM\fP. Параметр \fBIP_RECVERR\fP допустим для TCP, но все
ошибки возвращаются только через функцию сокета или через параметр
\fBSO_ERROR\fP.
.IP
Для неструктурированных сокетов, параметром \fBIP_RECVERR\fP включается
передача в приложение всех получаемых ошибок ICMP, иначе сообщается только
об ошибках в сокетах, ориентированных на соединение.
.IP
Этот параметр устанавливается или возвращается как логический флаг в виде
целого числа. По умолчанию, параметр \fBIP_RECVERR\fP выключен.
.TP 
\fBIP_RECVOPTS\fP (начиная с Linux 2.2)
.\" Precisely: 2.1.15
Передает пользователю все входящие параметры IP с помощью управляющего
сообщения \fBIP_OPTIONS\fP. Для локального узла заполняется заголовок
маршрутизации и другие параметры. Не поддерживается сокетами типа
\fBSOCK_STREAM\fP.
.TP 
\fBIP_RECVORIGDSTADDR\fP (начиная с Linux 2.6.29)
.\" commit e8b2dfe9b4501ed0047459b2756ba26e5a940a69
Данный логический параметр включает вспомогательное сообщение
\fBIP_ORIGDSTADDR\fP в \fBrecvmsg\fP(2), в котором ядро возвращает первоначальный
адрес назначения полученной дейтаграммы. Вспомогательное сообщение содержит
структуру \fIstruct sockaddr_in\fP.
.TP 
\fBIP_RECVTOS\fP (начиная с Linux 2.2)
.\" Precisely: 2.1.68
Если включён, то вместе с входящими пакетами передаётся вспомогательное
сообщение \fBIP_TOS\fP. В нём содержится байт, в котором указано поле типа
сервиса/приоритета из заголовка пакета. Ожидается логическое значение в виде
целого числа.
.TP 
\fBIP_RECVTTL\fP (начиная с Linux 2.2)
.\" Precisely: 2.1.68
Если указан этот флаг, то передаётся управляющее сообщение \fBIP_TTL\fP с
байтом значения поля времени существования из полученного пакета в виде
32\-битного целого. Не поддерживается сокетами типа \fBSOCK_STREAM\fP.
.TP 
\fBIP_RETOPTS\fP (начиная с Linux 2.2)
.\" Precisely: 2.1.15
Идентичен параметру \fBIP_RECVOPTS\fP, но возвращает необработанные параметры,
причём без заполненных временных меток и записи о маршрутизации до этой
точки (hop).
.TP 
\fBIP_ROUTER_ALERT\fP (начиная с Linux 2.2)
.\" Precisely: 2.1.68
Передаёт этому сокету все пересылаемые (forwarded) пакеты с установленным
параметром IP Router Alert. Этот параметр используется для «сырых»
сокетов. Он может быть полезен, например, для служб RSVP, запущенных в
пространстве пользователя. Перехваченные пакеты дальше ядром не
пересылаются: ответственность за их отсылку лежит на
пользователе. Связывание сокета игнорируется, так как пакеты фильтруются по
протоколу. Ожидается логическое значение в виде целого числа.
.TP 
\fBIP_TOS\fP (начиная с Linux 1.0)
.\" FIXME elaborate on this
.\" The priority can also be set in a protocol-independent way by the
.\" .RB ( SOL_SOCKET ", " SO_PRIORITY )
.\" socket option (see
.\" .BR socket (7)).
Устанавливает или получает значение поля Type\-Of\-Service (TOS, тип сервиса)
каждого IP\-пакета, который отсылается с этого сокета. Это поле используется
для указания приоритета пакета в сети. Значение TOS хранится в одном
байте. Существует несколько стандартных флагов TOS: \fBIPTOS_LOWDELAY\fP — для
минимизации задержки передаваемого трафика, \fBIPTOS_THROUGHPUT\fP — для
оптимизации пропускной способности, \fBIPTOS_RELIABILITY\fP — для увеличения
надёжности, \fBIPTOS_MINCOST\fP — при пересылки данных, для которых неважна
скорость передачи. Может быть указано не более одного из этих значений
TOS. Все другие биты являются недействительными и должны быть обнулены. По
умолчанию, Linux посылает дейтаграммы с \fBIPTOS_LOWDELAY\fP первыми, но точное
поведение зависит от настроенного порядка очередности (queueing
discipline). Для установки некоторых высокоприоритетных типов сервиса могут
потребоваться права суперпользователя (мандат \fBCAP_NET_ADMIN\fP).
.TP 
\fBIP_TRANSPARENT\fP (начиная с Linux 2.6.24)
.\" commit f5715aea4564f233767ea1d944b2637a5fd7cd2e
.\"     This patch introduces the IP_TRANSPARENT socket option: enabling that
.\"     will make the IPv4 routing omit the non-local source address check on
.\"     output. Setting IP_TRANSPARENT requires NET_ADMIN capability.
.\" http://lwn.net/Articles/252545/
Установка этого логического параметра включает прозрачное проксирование на
заданный сокет. Данный параметр сокета позволяет вызвавшему приложению
привязаться к нелокальному IP\-адресу и работать клиентом и сервером с
внешним адресом как с локальной конечной точкой. ЗАМЕЧАНИЕ: требуется
настройка маршрутизации пакетов для внешнего адреса через TProxy (то есть,
системы, на которой находится приложение, применяющее параметр сокета
\fBIP_TRANSPARENT\fP). Для установки данного параметра сокета требуются права
суперпользователя (мандат \fBCAP_NET_ADMIN\fP).
.IP
Также, для установки данного параметра на перенаправляемый сокет требуется
перенаправление TProxy с помощью цели TPROXY в iptables.
.TP 
\fBIP_TTL\fP (начиная с Linux 1.0)
Устанавливает или получает текущее значение поля времени существования (time
to live), которое указывается в каждом пакете, отсылаемом с этого сокета.
.TP 
\fBIP_UNBLOCK_SOURCE\fP (начиная с Linux 2.4.22 / 2.5.68)
Разблокировать ранее заблокированный многоадресный источник. Возвращает
\fBEADDRNOTAVAIL\fP, если указанный источник не заблокирован.
.IP
Аргументом является структура \fIip_mreq_source\fP, описанная в разделе о
\fBIP_ADD_SOURCE_MEMBERSHIP\fP.
.SS "Интерфейсы в /proc"
.\" FIXME As at 2.6.12, 14 Jun 2005, the following are undocumented:
.\"  ip_queue_maxlen
.\"  ip_conntrack_max
.\"
Настройку глобальных параметров протокола IP можно осуществлять через
интерфейс \fI/proc\fP. Все параметры доступны посредством чтения или записи
файлов из каталога \fI/proc/sys/net/ipv4/\fP. Для логических (\fIBoolean\fP)
параметров значения указываются в виде целых чисел: ненулевое значение
(«истина») означает включает параметра, а нулевое значение («ложь») —
выключение.
.TP 
\fIip_always_defrag\fP (Boolean; начиная с Linux 2.2.13)
[Появился в ядре версии 2.2.13; в ранних версиях это свойство
контролировалось с помощью флага \fBCONFIG_IP_ALWAYS_DEFRAG\fP времени
компиляции; данный параметр убран в 2.4.x]
.IP
Если этот флаг включён (не равен 0), то входящие фрагменты (части
IP\-пакетов, которые образуются, если некоторый узел, находящийся между
отправителем и получателем, решает, что пакеты слишком велики и разделяет их
на кусочки) будут снова собраны (дефрагментированны) перед дальнейшей
обработкой, даже если они должны быть пересланы дальше.
.IP
Включайте этот параметр только на межсетевом экране, который является
единственной связью с вашей сетью, или на прозрачном прокси; никогда не
включайте его на обычном маршрутизаторе или узле. В противном случае,
соединение может быть нарушено, если фрагменты передаются по различным
линиям. Дефрагментация также требует много памяти и процессорного времени.
.IP
.\"
Этот параметр включается автоматически при настройке маскарадинга или
прозрачного проксирования.
.TP 
\fIip_autoconfig\fP (в Linux 2.2 по 2.6.17)
.\" Precisely: since 2.1.68
.\" FIXME document ip_autoconfig
.\"
Не описан.
.TP 
\fIip_default_ttl\fP (integer; по умолчанию: 64; начиная с Linux 2.2)
.\" Precisely: 2.1.15
.\"
Устанавливает значение time\-to\-live по умолчанию для исходящих пакетов. Это
значение может быть изменено для каждого отдельного сокета с помощью
параметра \fBIP_TTL\fP.
.TP 
\fIip_dynaddr\fP (Boolean; по умолчанию: выключен; начиная с Linux 2.0.31)
.\"
Включает динамическую адресацию сокета и подмену (masquerading) при
изменении адреса интерфейса. Это полезно для интерфейсов коммутируемых
соединений (dialup) с изменяющимися IP\-адресами. Значение 0 означает не
подменять, 1 включает подмену и 2 включает режим подробностей работы.
.TP 
\fIip_forward\fP (Boolean; по умолчанию: выключен; начиная с Linux 1.2)
.\"
Включает/выключает пересылку (forwarding) IP\-пакетов. Пересылка IP также
может быть включена для каждого интерфейса в отдельности.
.TP 
\fIip_local_port_range\fP (начиная с Linux 2.2)
.\" Precisely: since 2.1.68
В этом файле содержатся два целых числа, определяющие диапазон локальных
портов по умолчанию, выделенных для сокетов, у которые нет явно привязанного
номера порта  — то есть диапазон \fIэфемерных портов\fP. Эфемерный порт
выделяется сокету в следующих случаях:
.RS
.IP * 3
при вызове \fBbind\fP(2) в номере порта адреса сокета указан 0;
.IP *
Вызов \fBlisten\fP(2) вызван для потокового сокета, который ещё не привязан;
.IP *
Вызов \fBconnect\fP(2) вызван для сокета, который ещё не привязан;
.IP *
Вызов \fBsendto\fP(2) вызван для дейтаграмного сокета, который ещё не привязан.
.RE
.IP
Выделение эфемерных портов начинается с первого числа в
\fIip_local_port_range\fP и заканчивается вторым числом. Если диапазон
эфемерных портов закончился, то соответствующий системный вызов вернёт
ошибку (но смотрите ДЕФЕКТЫ).
.IP
.\"
Заметим, что диапазон портов в \fIip_local_port_range\fP не должен
конфликтовать с портами, используемыми для маскарадинг (хотя это
проверяется). Также, произвольные значения могут вызвать проблемы с
некоторыми пакетными фильтрами межсетевых экранов, которые делают
предположения об используемых локальных портах. Первое число должно быть не
менее 1024, или лучше более 4096, чтобы не пересекаться с всем известными
портами и минимизировать проблемы с межсетевыми экранами.
.TP 
\fIip_no_pmtu_disc\fP (Boolean; по умолчанию: выключен; начиная с Linux 2.2)
.\" Precisely: 2.1.15
.\"
.\" The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
Если включён, то, по умолчанию, не производится обнаружение значения MTU у
маршрута для TCP сокетов. Обнаружение MTU маршрута может завершиться с
ошибкой из\-за встретившихся на пути неверно настроенных межсетевых экранов
(которые отбрасывают все пакеты ICMP) или из\-за неверно настроенных
интерфейсов (например, соединение точка\-точка, у которого оба конца не
договорились о MTU). Лучше исправить встреченные на пути неисправные
маршрутизаторы, чем глобально отключать обнаружение MTU маршрута, потому что
это отключение приведёт к высокой нагрузке на сеть.
.TP 
\fIip_nonlocal_bind\fP (Boolean; по умолчанию: выключен; начиная с Linux 2.4)
.\" Precisely: patch-2.4.0-test10
.\"
.\" The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
Если установлен, то это позволяет процессам привязываться (\fBbind\fP(2)) к
нелокальным IP\-адресам, что полезно, но может привести к неработоспособности
некоторых приложений.
.TP 
\fIip6frag_time\fP (integer; по умолчанию: 30)
.\"
.\" The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
Время в секундах, на которое фрагмент IPv6 остаётся в памяти.
.TP 
\fIip6frag_secret_interval\fP (integer; по умолчанию: 600)
Интервал регенерации (в секундах) контрольной суммы секрета (hash secret)
(или время существования контрольной суммы секрета) фрагментов IPv6.
.TP 
\fIipfrag_high_thresh\fP (integer), \fIipfrag_low_thresh\fP (integer)
Если количество фрагментов IP, стоящих в очереди, достигает значения
\fIipfrag_high_thresh\fP, то очередь укорачивается до значения
\fIipfrag_low_thresh\fP. Содержит целое число, означающее количество байт.
.TP 
\fIneigh/*\fP
.\" FIXME Document the conf/*/* interfaces
.\"
.\" FIXME Document the route/* interfaces
Смотрите в \fBarp\fP(7).
.SS "Вызовы ioctl"
.\" 2006-04-02, mtk
.\" commented out the following because ipchains is obsolete
.\" .PP
.\" The ioctls to configure firewalling are documented in
.\" .BR ipfw (4)
.\" from the
.\" .B ipchains
.\" package.
Все вызовы ioctl, описанные в \fBsocket\fP(7), применимы к \fBip\fP.
.PP
.\" FIXME Add a discussion of multicasting
Вызовы ioctl для настройки общих параметров устройств описаны в
\fBnetdevice\fP(7).
.SH ОШИБКИ
.\" FIXME document all errors.
.\"     We should really fix the kernels to give more uniform
.\"     error returns (ENOMEM vs ENOBUFS, EPERM vs EACCES etc.)
.TP 
\fBEACCES\fP
Пользователь попытался выполнить действие, не имея на это необходимых
полномочий. Примеры таких действий: посылка пакета по широковещательному
адресу без предварительной установки флага \fBSO_BROADCAST\fP; посылка пакета
по \fIзапрещённому\fP маршруту; изменение настроек межсетевого экрана не имея
прав суперпользователя (мандата \fBCAP_NET_ADMIN\fP); связывание сокета с
зарезервированным портом, не имея прав суперпользователя (мандата
\fBCAP_NET_BIND_SERVICE\fP).
.TP 
\fBEADDRINUSE\fP
Попытка связать сокет с уже используемым адресом.
.TP 
\fBEADDRNOTAVAIL\fP
Был запрошен несуществующий интерфейс или запрошенный исходящий адрес не
является локальным.
.TP 
\fBEAGAIN\fP
Действие над неблокирующим сокетом привело бы к его блокировке.
.TP 
\fBEALREADY\fP
Операция соединения на неблокирующем сокете уже находится в процессе
выполнения.
.TP 
\fBECONNABORTED\fP
Соединение закрыто во время \fBaccept\fP(2).
.TP 
\fBEHOSTUNREACH\fP
В таблице маршрутизации нет допустимых записей, соответствующих адресу
назначения. Эта ошибка может возникнуть из\-за ICMP\-сообщения от удалённого
маршрутизатора или из\-за локальной таблицы маршрутизации.
.TP 
\fBEINVAL\fP
Передан недопустимый аргумент. При операциях отправки эта ошибка может
возникнуть из\-за передачи по маршруту \fIчёрная дыра\fP (blackhole).
.TP 
\fBEISCONN\fP
Вызов \fBconnect\fP(2) запущен для сокета, уже установившего соединение.
.TP 
\fBEMSGSIZE\fP
Дейтаграмма больше значения MTU на маршруте, и она не может быть
фрагментирована.
.TP 
\fBENOBUFS\fP, \fBENOMEM\fP
Недостаточно свободной памяти. Часто это означает, что выделение памяти
ограничено не размером системной памяти, а границами буфера сокета, но это
не всегда так.
.TP 
\fBENOENT\fP
Для сокета вызван \fBSIOCGSTAMP\fP, но он ещё не получил ни одного пакета.
.TP 
\fBENOPKG\fP
Не настроена подсистема ядра.
.TP 
\fBENOPROTOOPT\fP и \fBEOPNOTSUPP\fP
Передан недопустимый параметр сокета.
.TP 
\fBENOTCONN\fP
Операция определена только для сокета, установившего соединение, а этот
сокет не соединён.
.TP 
\fBEPERM\fP
У пользователя нет достаточных полномочий, чтобы повысить приоритет,
изменить настройку или послать сигнал запрашиваемому процессу или группе
процессов.
.TP 
\fBEPIPE\fP
Соединение неожиданно закрылось или завершено (shut down) другой стороной.
.TP 
\fBESOCKTNOSUPPORT\fP
Сокет не настроен или запрошен неизвестный тип сокета.
.PP
Протоколами более высокого уровня могут генерироваться другие ошибки;
смотрите \fBtcp\fP(7), \fBraw\fP(7), \fBudp\fP(7) и \fBsocket\fP(7).
.SH ЗАМЕЧАНИЯ
.\" IP_PASSSEC is Linux-specific
.\" IP_XFRM_POLICY is Linux-specific
.\" IP_IPSEC_POLICY is a nonstandard extension, also present on some BSDs
Значения \fBIP_FREEBIND\fP, \fBIP_MSFILTER\fP, \fBIP_MTU\fP, \fBIP_MTU_DISCOVER\fP,
\fBIP_RECVORIGDSTADDR\fP, \fBIP_PKTINFO\fP, \fBIP_RECVERR\fP, \fBIP_ROUTER_ALERT\fP и
\fBIP_TRANSPARENT\fP есть только в Linux.
.PP
Будьте осторожны при использовании параметра \fBSO_BROADCAST\fP — в Linux он не
является привилегированным. Если небрежно относиться к широковещательным
сообщениям, то можно легко перегрузить сеть. В новых протоколах для
приложений лучше использовать многоадресные рассылки вместо
широковещательных. Не используйте широковещание.
.PP
Для определения адреса назначения и интерфейса полученных дейтаграмм в
некоторые реализациях сокетов BSD введены параметры сокетов \fBIP_RCVDSTADDR\fP
и \fBIP_RECVIF\fP. В Linux для этой цели есть общий параметр \fBIP_PKTINFO\fP.
.PP
В некоторых реализациях сокетов BSD также есть параметр \fBIP_RECVTTL\fP, но
вспомогательное сообщение с типом \fBIP_RECVTTL\fP передаётся с входным
пакетом. В этом отличие от параметра \fBIP_TTL\fP, используемого в Linux.
.PP
Использование уровня параметров сокета \fBSOL_IP\fP непереносимо — в BSD\-стеках
используется уровень \fBIPPROTO_IP\fP.
.PP
Значение \fBINADDR_ANY\fP
(0.0.0.0) и
\fBINADDR_BROADCAST\fP
(255.255.255.255) указываются с нейтральным порядком байт.
Это означает, что
\fBhtonl\fP(3)
на них не действует.
.SS Совместимость
Для совместимости с Linux 2.0 устаревший синтаксис \fBsocket(AF_INET,
SOCK_PACKET, \fP\fIprotocol\fP\fB)\fP всё ещё поддерживается для открытия сокетов
типа \fBpacket\fP(7). Такое использование не поощряется и должно быть заменено
на \fBsocket(AF_PACKET, SOCK_RAW, \fP\fIprotocol\fP\fB)\fP. Основное различие между
ними в новой адресной структуре \fIsockaddr_ll\fP (вместо старой структуры
\fBsockaddr_pkt\fP), хранящей информацию обобщённого уровня соединения.
.SH ДЕФЕКТЫ
Слишком много противоречий в значениях ошибок.
.PP
Ошибка, используемая при диагностике исчерпания диапазона эфемерных портов,
отличается в различных системных вызовах (\fBconnect\fP(2), \fBbind\fP(2),
\fBlisten\fP(2), \fBsendto\fP(2)), из\-за чего эфемерные порты могут быть
назначены.
.PP
.\" .PP
.\" Some versions of glibc forget to declare
.\" .IR in_pktinfo .
.\" Workaround currently is to copy it into your program from this man page.
Не описаны ioctl для настройки специальных параметров IP для интерфейса и
таблиц ARP.
.PP
.\" .SH AUTHORS
.\" This man page was written by Andi Kleen.
Получение исходного адреса назначения в \fImsg_name\fP с помощью
\fBMSG_ERRQUEUE\fP вызовом \fBrecvmsg\fP(2) не работает в некоторых ядрах 2.2.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBrecvmsg\fP(2), \fBsendmsg\fP(2), \fBbyteorder\fP(3), \fBipfw\fP(4),
\fBcapabilities\fP(7), \fBicmp\fP(7), \fBipv6\fP(7), \fBnetlink\fP(7), \fBraw\fP(7),
\fBsocket\fP(7), \fBtcp\fP(7), \fBudp\fP(7), \fBip\fP(8)
.PP
Первоначальная спецификация IP описана в RFC\ 791. В RFC\ 1122 определены
требования для узлов IPv4. В RFC\ 1812 определены требования для
маршрутизаторов IPv4.
