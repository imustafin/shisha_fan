.\" -*- mode: troff; coding: UTF-8 -*-
.\" Copyright (c) 2013, 2014 by Michael Kerrisk <mtk.manpages@gmail.com>
.\" and Copyright (c) 2012, 2014 by Eric W. Biederman <ebiederm@xmission.com>
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH USER_NAMESPACES 7 2019\-08\-02 Linux "Руководство программиста Linux"
.SH ИМЯ
user_namespaces \- обзор пользовательских пространств имён Linux
.SH ОПИСАНИЕ
Обзор пространств имён смотрите в \fBnamespaces\fP(7).
.PP
.\" FIXME: This page says very little about the interaction
.\" of user namespaces and keys. Add something on this topic.
.\"
.\" ============================================================
.\"
Пользовательские пространства имён изолируют идентификаторы и атрибуты
безопасности, в частности ID пользователя и ID группы (смотрите
\fBcredentials\fP(7)), корневой каталог, ключи (смотрите \fBkeyrings\fP(7)) и
мандаты (смотрите \fBcapabilities\fP(7)). Идентификаторы пользователя и группы
процесса могут отличаться внутри и снаружи пользовательского пространства
имён. В частности, процесс может иметь обычный бесправный пользовательский
ID снаружи и ID равный 0 внутри пространства имён; другими  словами, процесс
имеет доступ ко всем операциям внутри пользовательского пространства имён,
но не имеет доступа к привилегированным операциям вне пространства имён.
.SS "Вложенные пространства имён, членство пространств имён"
Пользовательские пространства имён могут быть вложенными, то есть каждое
пользовательское пространство имён — за исключением первого («корневого») —
имеет родительское пространство имён и может иметь ноль или более дочерних
пространств имён. Родительское пространство имён — это пользовательское
пространство имён процесса, которое создаётся с помощью вызова \fBunshare\fP(2)
или \fBclone\fP(2) с флагом \fBCLONE_NEWUSER\fP.
.PP
.\" commit 8742f229b635bf1c1c84a3dfe5e47c814c20b5c8
.\" FIXME Explain the rationale for this limit. (What is the rationale?)
Ядро ограничивает (начиная с версии 3.11) глубину вложенности
пользовательских пространств имён 32 уровнями. Вызовы \fBunshare\fP(2) или
\fBclone\fP(2), которые бы превысили это ограничение, завершаются с ошибкой
\fBEUSERS\fP.
.PP
Каждый процесс является членом только одного пользовательского пространства
имён. Процесс, созданный с помощью \fBfork\fP(2) или \fBclone\fP(2) без флага
\fBCLONE_NEWUSER\fP, является членом того же пользовательского пространства
имён что и его родитель. Однонитевой процесс может перейти в другое
пользовательское пространство имён с помощью \fBsetns\fP(2), если в этом
пространстве у него есть мандат \fBCAP_SYS_ADMIN\fP; после перехода он получает
полный набор мандатов в этом пространстве имён.
.PP
Вызов \fBclone\fP(2) или \fBunshare\fP(2) с флагом \fBCLONE_NEWUSER\fP делает новый
дочерний (для \fBclone\fP(2)) или вызвавший (для \fBunshare\fP(2)) процесс членом
нового пользовательского пространства имён, создаваемого вызовом.
.PP
.\"
.\" ============================================================
.\"
Операцию \fBNS_GET_PARENT\fP \fBioctl\fP(2) можно использовать для обнаружения
родительской связи между пространствами имён пользователя; смотрите
\fBioctl_ns\fP(2).
.SS Мандаты
Дочерний процесс, созданный \fBclone\fP(2) с флагом \fBCLONE_NEWUSER\fP,
запускается в новом пользовательском пространстве имён с полным набором
мандатов. Аналогично, процесс, создающий новое пользовательское пространство
имён с помощью \fBunshare\fP(2) или переходящий в существующее пользовательское
пространство имён с помощью \fBsetns\fP(2), получает полный набор мандатов  в
этом пространстве имён. С другой стороны, этот процесс не имеет мандатов в
родительском (в случае \fBclone\fP(2)) или предыдущем (в случае \fBunshare\fP(2) и
\fBsetns\fP(2)) пользовательском пространстве имён, даже если новое
пространство имён создано или переход осуществлялся суперпользователем
(т. е., процесс с ID пользователя 0 в корневом пространстве имён).
.PP
Заметим, что вызов \fBexecve\fP(2) приводит к пересчёту мандатов процесса
обычным порядком (смотрите \fBcapabilities\fP(7)). Следовательно, если ID
пользователя процесс не равно 0 внутри пространства имён или исполняемый
файл имеет непустую маску наследования мандатов, то процесс теряет все
мандаты. Смотрите описание отображения пользовательских и групповых ID
далее.
.PP
Вызов \fBclone\fP(2), \fBunshare\fP(2) или \fBsetns\fP(2) с флагом \fBCLONE_NEWUSER\fP
устанавливает флаги «securebits» (смотрите \fBcapabilities\fP(7)) в их значения
по умолчанию (все флаги сброшены) в потомке (для \fBclone\fP(2)) или вызывающем
(для \fBunshare\fP(2) или \fBsetns\fP(2)). Заметим, что из\-то того, что вызывающий
больше не имеет мандатов в своём первоначальном пользовательском
пространстве имён после вызова \fBsetns\fP(2), невозможно у процесса сбросить
его флаги «securebits», хотя удержать своё членство в пользовательском
пространстве имён можно с помощью пары вызовов \fBsetns\fP(2) — сначала
переместиться в другое пользовательское пространство имён и затем вернуться
в своё первоначальное пользовательское пространство имён.
.PP
Правила определения наличия мандата у процесса в определённом
пользовательском пространстве имён следующие:
.IP 1. 3
.\" In the 3.8 sources, see security/commoncap.c::cap_capable():
Процесс имеет мандат внутри пользовательского пространства имён, если он
является членом этого пространства имён и имеет мандат в своём наборе
эффективных мандатов. Процесс может получить мандаты в своём наборе
эффективных мандатов различными способами. Например, он может запустить
программу с битом set\-user\-ID или исполняемый файл, имеющий мандаты
файла. Также процесс может получить мандаты при выполнении \fBclone\fP(2),
\fBunshare\fP(2) или \fBsetns\fP(2), как описывалось ранее.
.IP 2.
Если процесс имеет мандат в пользовательском пространстве имён, то он также
имеет этот мандат во всех дочерних (и позже удалённых потомках)
пространствах имён.
.IP 3.
.\" * The owner of the user namespace in the parent of the
.\" * user namespace has all caps.
.\" (and likewise associates the effective group ID of the creating process
.\" with the namespace).
.\" See kernel commit 520d9eabce18edfef76a60b7b839d54facafe1f9 for a fix
.\" on this point
.\"     This includes the case where the process executes a set-user-ID
.\"     program that confers the effective UID of the creator of the namespace.
.\"
.\" ============================================================
.\"
При создании пользовательского пространства имён ядро записывает эффективный
пользовательский ID создающего процесса как «владельца» пространства
имён. Процесс, располагающийся в родительском пространстве имён
пользовательского пространства имён и чей эффективный пользовательский ID
совпадает с владельцем пространства имён, имеет все мандаты в пространстве
имён. Предыдущее правило означает, что у процесса также есть все мандаты во
всех в последствии удалённых потомках пользовательских пространств имён. Для
обнаружения идентификатора пользователя\-владельца пространства имён можно
использовать операцию \fBNS_GET_OWNER_UID\fP вызова \fBioctl\fP(2); смотрите
\fBioctl_ns\fP(2).
.SS "Влияние мандатов внутри пространства имён пользователя"
Наличие мандата внутри пространства имён пользователя разрешает процессу
выполнять операции (требующие привилегий) с ресурсами, управляемыми только
этим пространством имён. Иначе говоря, наличие мандата в пользовательском
пространстве имён разрешает процессу выполнять привилегированные операции с
ресурсами, которые управляются (не пользовательскими) пространствами имён,
принадлежащими (связанными с) пространству имён пользователя (смотрите
следующий подраздел).
.PP
С другой стороны, существует много привилегированных операций, которые
влияют на ресурсы не связанные с каким\-либо типом пространства имён,
например, изменение системного времени (регулируется \fBCAP_SYS_TIME\fP),
загрузка модуля ядра (регулируется \fBCAP_SYS_MODULE\fP) и создание устройства
(регулируется \fBCAP_MKNOD\fP). Такие операции может выполнять только процесс с
привилегиями в \fIначальном\fP пользовательском пространстве имён.
.PP
.\" fs_flags = FS_USERNS_MOUNT in kernel sources
Наличие \fBCAP_SYS_ADMIN\fP внутри пользовательского пространства имён,
принадлежащему пространству имён монтирования процесса, позволяет этому
процессу создавать привязки монтирования и монтировать следующие типы
файловых систем:
.PP
.RS 4
.PD 0
.IP * 2
\fI/proc\fP (начиная с Linux 3.8)
.IP *
\fI/sys\fP (начиная с Linux 3.8)
.IP *
\fIdevpts\fP (начиная с Linux 3.9)
.IP *
\fBtmpfs\fP(5)  (начиная с Linux 3.9)
.IP *
\fIramfs\fP (начиная с Linux 3.9)
.IP *
\fImqueue\fP (начиная с Linux 3.9)
.IP *
.\" commit b2197755b2633e164a439682fb05a9b5ea48f706
\fIbpf\fP (начиная с Linux 4.4)
.PD
.RE
.PP
Наличие \fBCAP_SYS_ADMIN\fP внутри пользовательского пространства имён,
принадлежащему пространству имён cgroup процесса, позволяет (начиная с Linux
4.6) этому процессу монтировать именованные иерархии файловой системы cgroup
версии 2 и cgroup версии 1 (т. е., файловые системы cgroup, монтируемые с
параметром \fI"none,name="\fP).
.PP
Наличие \fBCAP_SYS_ADMIN\fP внутри пользовательского пространства имён,
принадлежащему пространству имён PID процесса, позволяет (начиная с Linux
3.8) этому процессу монтировать файловые системы \fI/proc\fP.
.PP
.\"
.\" ============================================================
.\"
Однако заметим, что монтирование блочных файловых систем может производиться
только процессом, имеющим \fBCAP_SYS_ADMIN\fP в начальном пространстве имён
пользователя.
.SS "Взаимодействие между пользовательскими и другими типами пространств имён"
Начиная с Linux 3.8, непривилегированные процессы могут создавать
пользовательские пространства имён, а для создания пространств имён других
типов требуется мандат \fBCAP_SYS_ADMIN\fP в пользовательском пространстве имён
вызывающего.
.PP
После создания не пользовательского пространства имён оно принадлежит
пользовательскому пространству имён, в котором на момент создания
пространства имён создающий процесс являлся членом. Для привилегированных
операций над ресурсами, управляемыми не пользовательским пространством имён,
от процесса требуется иметь мандаты в пользовательском пространстве имён,
которому принадлежит не пользовательское пространство имён.
.PP
Если вместе с флагами \fBCLONE_NEW*\fP указан флаг \fBCLONE_NEWUSER\fP в вызове
\fBclone\fP(2) или \fBunshare\fP(2), то пользовательское пространство имён
гарантированно создаётся первым, давая потомку (\fBclone\fP(2)) или вызывающему
(\fBunshare\fP(2))  права на остальные пространства имён, создаваемые
вызовом. Даже бесправный вызывающий может задать такую комбинацию флагов.
.PP
При создании нового пространства имён (не пользовательского пространства
имён) посредством \fBclone\fP(2) или \fBunshare\fP(2), ядро записывает
пользовательское пространство имён создающего процесса как владельца нового
пространства имён (эту связь нельзя изменить). Когда процесс в новом
пространстве имён в дальнейшем выполняет привилегированные операции, которые
работают с глобальными ресурсами, изолированными пространством имён,
выполняется проверка прав согласно мандатам процесса в пользовательском
пространстве имён, которое ядро связало с новым пространством
имён. Например, предположим, что процесс пытается изменить имя узла
(\fBsethostname\fP(2)) — ресурс, управляемый пространство имён UTS. В этом
случае, ядро будет искать пространство имён пользователя, принадлежащее
пространству имён UTS процесса, и проверять что процесс имеет необходимый
мандат (\fBCAP_SYS_ADMIN\fP) в этом пространстве имён пользователя.
.PP
.\"
.\" ============================================================
.\"
Операцию \fBNS_GET_USERNS\fP \fBioctl\fP(2) можно использовать для обнаружения
пространства имён пользователя, которое владеет не пользовательским
пространством имён; смотрите \fBioctl_ns\fP(2).
.SS "Отображение идентификаторов пользователей и групп: uid_map и gid_map"
.\" commit 22d917d80e842829d0ca0a561967d728eb1d6303
В новом созданном пользовательском пространстве имён отсутствует отображение
пользовательских ID (ID групп) в родительское пользовательское
пространство. Файл \fI/proc/[pid]/uid_map\fP и \fI/proc/[pid]/gid_map\fP (доступны
начиная с Linux 3.5) предоставляют отображения пользовательских и групповых
ID внутри пользовательского пространства имён для процесса \fIpid\fP. Эти файлы
можно читать для просмотра отображений в пользовательском пространстве имён
и писать (однократно) для определения отображений.
.PP
В следующих параграфах объясняется формат \fIuid_map\fP; \fIgid_map\fP имеет тот
же формат, но каждый экземпляр «ID пользователя» заменяется на «ID группы».
.PP
Файл \fIuid_map\fP предоставляет отображение пользовательских ID из
пользовательского пространства имён процесса \fIpid\fP в пользовательское
пространство имён процесса, который открыл \fIuid_map\fP (но смотрите уточнение
далее). Другими словами, процессы, которые находятся в разных
пользовательских пространствах имён, возможно будут видеть разные значения
при чтении соответствующего файла \fIuid_map\fP, в зависимости от отображений
пользовательских ID у пользовательских пространств имён читающего процесса.
.PP
Каждая строка в файле \fIuid_map\fP определяет отображение 1\-в\-1 непрерывного
диапазона пользовательских ID между двумя пользовательскими пространствами
имён (при создании пользовательского пространства имён этот файл пуст). В
каждой строке содержится три числа через пробел. Первые два числа определяют
начальный пользовательский ID в каждом из двух пользовательских пространств
имён. Третье число определяет длину отображаемого диапазона. Эти поля
рассматриваются так:
.IP (1) 4
Начало диапазона пользовательских ID в пользовательском пространстве имён
процесса \fIpid\fP.
.IP (2)
Начало диапазона пользовательских ID, на который отображаются
пользовательские ID, указанные в первом поле. Интерпретация второго поля
зависит от того, находится ли процесс, открывший \fIuid_map\fP, и процесс
\fIpid\fP, в одном пользовательском пространстве имён:
.RS
.IP а) 3
Если два процесса находятся в разных пользовательских пространствах имён:
поле два — начало диапазона пользовательских ID в пользовательском
пространстве имён процесса, который открыл \fIuid_map\fP.
.IP б)
Если два процесса находятся в одном пользовательском пространстве имён: поле
два — начало диапазона пользовательских ID в родительском пользовательском
пространстве имён процесса \fIpid\fP. Это позволяет открывшему \fIuid_map\fP
(обычно открывают \fI/proc/self/uid_map\fP) видеть отображение пользовательских
ID в пользовательском пространстве имён процесса, создавшего это
пользовательское пространство имён.
.RE
.IP (3)
Длина диапазона пользовательских ID, выполняющего отображение между двумя
пользовательскими пространствами имён.
.PP
Системные вызовы, возвращающие пользовательские ID (ID групп), например,
\fBgetuid\fP(2), \fBgetgid\fP(2), и мандатные поля в структуре, возвращаемой
\fBstat\fP(2), возвращают пользовательский ID (ID группы), отображённый в
пользовательском пространстве имён вызывающего.
.PP
Когда процесс обращается к файлу, его ID пользователя и группы отображаются
в начальном пользовательском пространстве имён с целью проверки прав доступа
и назначенного ID при создании файла. Когда процесс получает ID пользователя
и группы файла через \fBstat\fP(2), то ID отображаются в обратном направлении,
для создания значений, относительно отображений ID пользователя и группы
процесса.
.PP
Начальное пользовательское пространство имён не имеет родительского
пространства имён, но для однородности, для него ядро предоставляет
фиктивные файлы отображения ID пользователей и групп. Посмотрим на файл
\fIuid_map\fP (в \fIgid_map\fP тоже самое) из оболочки в начальном пространстве
имён:
.PP
.in +4n
.EX
$ \fBcat /proc/$$/uid_map\fP
         0          0 4294967295
.EE
.in
.PP
.\"
.\" ============================================================
.\"
Данное отображение показывает, что диапазон начинающийся с пользовательского
ID 0 в этом пространстве имён, отображается в диапазон, начинающийся, с 0, в
(несуществующее) родительское пространство имён, и длина диапазона равна
самому большому 32\-битному беззнаковому целому. Значение 4294967295
(32\-битное знаковое значение \-1) оставлено без отображения. Предназначение:
\fI(uid_t)\ \-\1\fP используется в некоторых интерфейсах (например,
\fBsetreuid\fP(2)) для указания «отсутствия ID пользователя». Оставление
\fI(uid_t)\ \-\1\fP без отображения и его не использование гарантирует, что при
использовании этих интерфейсов не будет проблем).
.SS "Отображение идентификаторов пользователей и групп: запись в uid_map и gid_map"
.PP
После создания нового пользовательского пространства имён в файл \fIuid_map\fP
\fIодин\fP из процессов в пространстве имён может выполнить \fIоднократную\fP
запись для определения отображения пользовательских ID в новом
пользовательском пространстве имён. Повторная попытка записи в файл
\fIuid_map\fP в пользовательском пространстве имён завершится с ошибкой
\fBEPERM\fP. Эти же правила применимы к файлам \fIgid_map\fP.
.PP
Записываемые в \fIuid_map\fP (\fIgid_map\fP) строки должны соответствовать
следующим правилам:
.IP * 3
В трёх полях должны быть корректные числа и последнее поле должно быть
больше 0.
.IP *
Строки заканчиваются символами новой строки.
.IP *
.\" 5*12-byte records could fit in a 64B cache line
.\" commit 6397fac4915ab3002dc15aae751455da1a852f25
Существует ограничение на количество строк в файле. В Linux 4.14 и старее
оно установлено (произвольно) равным пятью строкам. Начиная с Linux 4.14 его
значение равно 340 строкам. Также, количество байт, записываемых в файл,
должно быть меньше размера системной страницы, и запись должна выполняться в
начало файла (т. е., нельзя использовать \fBlseek\fP(2) и \fBpwrite\fP(2) для
записи в файл при ненулевом смещении).
.IP *
.\" commit 0bd14b4fd72afd5df41e9fd59f356740f22fceba
Диапазон пользовательских ID (групповых ID), указанный в каждой строке, не
должен перекрываться с диапазонами в других строках. В первой реализации
(Linux 3.8) это требование удовлетворялось простейшим способом, который
задавал другое требование: значения в полях 1 и 2 следующих одна за одной
строк, должны увеличиваться, что не давало создавать некоторые корректные
отображения. В Linux 3.9 и новее это ограничение было снято, и допустим
любой набор не перекрывающихся отображений.
.IP *
В файл должна быть записана, как минимум, одна строка.
.PP
Попытки записи, нарушающие перечисленные выше правила, завершаются с ошибкой
\fBEINVAL\fP.
.PP
Чтобы процесс мог записывать в файл \fI/proc/[pid]/uid_map\fP
(\fI/proc/[pid]/gid_map\fP) должны быть удовлетворены все условия:
.IP 1. 3
Записывающий процесс должен иметь мандат \fBCAP_SETUID\fP (\fBCAP_SETGID\fP) в
пользовательском пространстве имён процесса \fIpid\fP.
.IP 2.
Записывающий процесс должен находиться в пользовательском пространстве имён
процесса \fIpid\fP или быть родительским пользовательским пространством имён
процесса \fIpid\fP.
.IP 3.
Отображаемые пользовательские ID (групповые ID) должны иметь соответствующее
отображение в родительском пользовательском пространстве имён.
.IP 4.
Применимо к одному из двух случаев:
.RS
.IP * 3
\fIИли\fP записывающий процесс имеет мандат \fBCAP_SETUID\fP (\fBCAP_SETGID\fP) в
\fIродительском\fP пользовательском пространстве имён.
.RS
.IP + 3
В дальнейшем ограничения не применяются: процесс может создавать отображения
в произвольные пользовательские ID (групповые ID) в родительском
пользовательском пространстве имён.
.RE
.IP * 3
\fIИли\fP в противном случае накладываются следующие (все) ограничения:
.RS
.IP + 3
Данные, записываемые в \fIuid_map\fP (\fIgid_map\fP), должны состоять из одной
строки, которая отображает эффективный пользовательский ID (групповой ID)
записывающего процесса в родительском пользовательском пространстве имён в
пользовательский ID (групповой ID) в пользовательском пространстве имён.
.IP +
Записывающий процесс должен иметь мандат тот же эффективный пользовательский
ID что и процесс, который создал пользовательское пространство имён.
.IP +
В случае \fIgid_map\fP, перед записью в \fIgid_map\fP сначала нужно использовать
системный \fBsetgroups\fP(2) для записи "\fIdeny\fP" в файл
\fI/proc/[pid]/setgroups\fP (смотрите ниже).
.RE
.RE
.PP
.\"
.\" ============================================================
.\"
Попытки записи, нарушающие перечисленные выше правила, завершаются с ошибкой
\fBEPERM\fP.
.SS "Взаимодействие с системными вызовами, которые изменяют UID или GID процесса."
В пользовательском пространстве имён, в котором не выполнялась запись в файл
\fIuid_map\fP, системные вызовы, изменяющие ID пользователя, будут завершаться
с ошибкой. Подобными образом, если не выполнялась запись в файл \fIgid_map\fP,
то системные вызовы, изменяющие ID группы, будут завершаться с
ошибкой. После записи в файл \fIuid_map\fP и \fIgid_map\fP только отображённые
значения могут использоваться в системных вызовах, изменяющих ID
пользователя или группы.
.PP
Для ID пользователя, это относится  к следующим системным вызовам:
\fBsetuid\fP(2), \fBsetfsuid\fP(2), \fBsetreuid\fP(2) и \fBsetresuid\fP(2). Для ID
группы, это относится  к следующим системным вызовам: \fBsetgid\fP(2),
\fBsetfsgid\fP(2), \fBsetregid\fP(2), \fBsetresgid\fP(2) и \fBsetgroups\fP(2).
.PP
.\" Things changed in Linux 3.19
.\" commit 9cc46516ddf497ea16e8d7cb986ae03a0f6b92f8
.\" commit 66d2f338ee4c449396b6f99f5e75cd18eb6df272
.\" http://lwn.net/Articles/626665/
.\"
.\" ============================================================
.\"
Запись "\fIdeny\fP" в файле \fI/proc/[pid]/setgroups\fP перед записью в
\fI/proc/[pid]/gid_map\fP насовсем отключает \fBsetgroups\fP(2) в пользовательском
пространстве имён, а также разрешает запись в \fI/proc/[pid]/gid_map\fP без
мандата \fBCAP_SETGID\fP в родительском пользовательском пространстве имён.
.SS "Файл /proc/[pid]/setgroups"
.\"
.\" commit 9cc46516ddf497ea16e8d7cb986ae03a0f6b92f8
.\" commit 66d2f338ee4c449396b6f99f5e75cd18eb6df272
.\" http://lwn.net/Articles/626665/
.\" http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-8989
.\"
Файл \fI/proc/[pid]/setgroups\fP содержит строку "\fIallow\fP", если процессам в
пользовательском пространстве имён, которые содержат процесс с \fIpid\fP,
разрешено выполнять системный вызов \fBsetgroups\fP(2); в файл содержится
строка "\fIdeny\fP", если \fBsetgroups\fP(2) запрещён в этом пользовательском
пространстве имён. Заметим, что независимо от значения в файле
\fI/proc/[pid]/setgroups\fP (и независимо от мандатов процесса) вызовы
\fBsetgroups\fP(2) также запрещены, если \fI/proc/[pid]/gid_map\fP до этого не был
настроен.
.PP
Привилегированный процесс (с мандатом \fBCAP_SYS_ADMIN\fP в пространстве имён)
может записать строку "\fIallow\fP" или "\fIdeny\fP" в этот файл \fIдо\fP записи
отображения ID групп для этого пользовательского пространства имён в файл
\fI/proc/[pid]/gid_map\fP. Запись строки "\fIdeny\fP" запрещает любому процессу в
пользовательском пространстве имён выполнять \fBsetgroups\fP(2).
.PP
Сущность ограничений, описанных в предыдущем абзаце в том, чтобы разрешить
запись в \fI/proc/[pid]/setgroups\fP только когда запрещено вызывать
\fBsetgroups\fP(2), так как \fI/proc/[pid]/gid_map\fP не настроен. Это
гарантирует, что процесс не сможет перейти из состояния, в котором
\fBsetgroups\fP(2) разрешён, в состояние, в котором \fBsetgroups\fP(2) запрещён;
процесс может переходить только из состояния, когда \fBsetgroups\fP(2)
запрещён, в состояние, когда \fBsetgroups\fP(2) разрешён.
.PP
Значение по умолчанию в этом файле для начального состояния
пользовательского пространства имён равно "\fIallow\fP".
.PP
После записи в \fI/proc/[pid]/gid_map\fP (что действует как разрешение работы
\fBsetgroups\fP(2) в пользовательском пространстве имён), больше невозможно
запретить \fBsetgroups\fP(2) записью "\fIdeny\fP" в \fI/proc/[pid]/setgroups\fP
(запись завершается ошибкой \fBEPERM\fP).
.PP
Дочернее пользовательское пространство имён наследует значение
\fI/proc/[pid]/setgroups\fP своего родителя.
.PP
Если файл \fIsetgroups\fP содержит значение "\fIdeny\fP", то системный вызов
\fBsetgroups\fP(2) не может быть повторно включён в дальнейшем (записью
"\fIallow\fP" в файл) в этом пользовательском пространстве имён (попытка это
сделать завершается ошибкой \fBEPERM\fP). Это ограничение также
распространяется на всех потомков пользовательского пространства имён этого
пользовательского пространства имён.
.PP
.\"
.\" /proc/PID/setgroups
.\"	[allow == setgroups() is allowed, "deny" == setgroups() is disallowed]
.\"	* Can write if have CAP_SYS_ADMIN in NS
.\"	* Must write BEFORE writing to /proc/PID/gid_map
.\"
.\" setgroups()
.\"	* Must already have written to gid_map
.\"	* /proc/PID/setgroups must be "allow"
.\"
.\" /proc/PID/gid_map -- writing
.\"	* Must already have written "deny" to /proc/PID/setgroups
.\"
.\" ============================================================
.\"
Файл \fI/proc/[pid]/setgroups\fP был добавлен в Linux 3.19, но перенесён и в
старшие серии ядра, так как служит для обеспечения безопасности. В
частности, это влияет на файлы с правами доступа «rwx\-\-\-rwx». Эти файлы
меньшие права «группе» по сравнению с группой «остальные». Это означает, что
удаление группы с помощью \fBsetgroups\fP(2) может открыть доступ к файлу, тем
которые не имели его. До существования пользовательских пространств имён это
не было проблемой, так как только привилегированный процесс (с мандатом
\fBCAP_SETGID\fP) мог вызывать \fBsetgroups\fP(2). Однако с введение
пользовательских пространств имён стало возможным и непривилегированному
процессу создавать новое пространство имён, в котором пользователь имеет все
права. После этого ранее непривилегированный пользователь может удалить
группы и таким образом получить доступ к файлу, которого раньше не
имел. Файл \fI/proc/[pid]/setgroups\fP был добавлен для решения этой проблемы
безопасности; он запрещает непривилегированному процессу удалять группы с
помощью  \fBsetgroups\fP(2).
.SS "Неотображённые пользовательские и групповые ID"
.PP
.\" from_kuid_munged(), from_kgid_munged()
Есть несколько мест, где в пользовательском пространстве могут появиться
неотображённые пользовательские ID (групповые ID). Например, первый процесс
в новом пользовательском пространстве имён может вызвать \fBgetuid\fP(2) до
определения отображения пользовательских ID для пространства имён. В
большинстве случаев, неотображённый пользовательский ID преобразуется в
пользовательский ID (групповой ID) переполнения (overflow); значение по
умолчанию для пользовательского ID (группового ID) переполнения равно
65534. Смотрите описание \fI/proc/sys/kernel/overflowuid\fP и
\fI/proc/sys/kernel/overflowgid\fP в \fBproc\fP(5).
.PP
.\" also SO_PEERCRED
Случаи, где неотображённые ID отображаются в таком виде, относятся к
системным вызовам, которые возвращают пользовательские ID (\fBgetuid\fP(2),
\fBgetgid\fP(2) и подобные), мандаты, передаваемые через доменный сокет UNIX,
мандаты, возвращаемые \fBstat\fP(2), \fBwaitid\fP(2) и System V IPC
«ctl»\-операциями \fBIPC_STAT\fP, мандаты, показываемые в \fI/proc/[pid]/status\fP
и файлах в \fI/proc/sysvipc/*\fP, мандаты, возвращаемые в поле \fIsi_uid\fP
структуры \fIsiginfo_t\fP, полученной по сигналу (смотрите \fBsigaction\fP(2)),
мандаты, записываемые в файл учёта процесса (смотрите \fBacct\fP(5)), и
мандаты, возвращаемые с уведомлениями очереди сообщений POSIX (смотрите
\fBmq_notify\fP(3)).
.PP
.\" from_kuid(), from_kgid()
.\" Also F_GETOWNER_UIDS is an exception
.\"
.\" ============================================================
.\"
Есть один известный случай, где неотображённый пользовательский и групповой
ID \fIне\fP преобразуется в соответствующее значение ID переполнения. Если при
просмотре файла \fIuid_map\fP или \fIgid_map\fP обнаруживается, что для второго
поля нет отображения, то поле отображается как 4294967295 (\-1 для
беззнакового целого).
.SS "Доступ к файлам"
.PP
.\"
.\" ============================================================
.\"
Чтобы определить права, с которыми непривилегированный процесс обращается к
файлу, берутся идентификаторы процесса (UID, GID) и идентификаторы файла,
отображаемые в те, которые были бы в исходном пространстве имён
пользователя, и затем сравниваются для определения прав, которые процесс
имеет на файл. Это также выполняется и для других объектов, использующих
идентификаторы плюс модель маски прав доступа, например для объектов System
V IPC.
.SS "Операции с файловыми мандатами"
.PP
Некоторые мандаты позволяют процессу обходить различные ограничения,
налагаемые ядром на выполнение операций над файлами, принадлежащими другим
пользователям или группам. Список мандатов: \fBCAP_CHOWN\fP,
\fBCAP_DAC_OVERRIDE\fP, \fBCAP_DAC_READ_SEARCH\fP, \fBCAP_FOWNER\fP и \fBCAP_FSETID\fP.
.PP
Внутри пользовательского пространства имён эти мандаты позволяют процессу
обходить правила, если процесс имеет соответствующий мандат на файле,
подразумевающий что:
.IP * 3
процесс имеет соответствующий эффективный мандат в своём пространстве имён
пользователя; и
.IP *
файловые ID пользователя и группы корректно отображаются в
пользовательскомпространстве имён.
.PP
.\" These are the checks performed by the kernel function
.\" inode_owner_or_capable(). There is one exception to the exception:
.\" overriding the directory sticky permission bit requires that
.\" the file has a valid mapping for both its UID and GID.
.\"
.\" ============================================================
.\"
Мандат \fBCAP_FOWNER\fP учитывается по\-другому: it allows a process to bypass
the corresponding rules so long as at least the file's user ID has a mapping
in the user namespace (т. е., файловый ID группы может не иметь корректного
отображения).
.SS "Программы с установленными битами set\-user\-ID и set\-group\-ID"
.PP
.\"
.\" ============================================================
.\"
Когда процесс внутри пользовательского пространства имён выполняет программу
с установленным битом set\-user\-ID (set\-group\-ID), то эффективный ID
пользователя (группы) внутри пространства имён изменяется на значение,
отображённое для ID пользователя (группы) файла. Однако, если ID
пользователя \fIили\fP группы файла не имеет отображения внутри пространства
имён, то бит set\-user\-ID (set\-group\-ID) просто игнорируется: выполняется
новая программа, но эффективный ID пользователя (группы) остаётся не
изменённым (такое поведение зеркально семантике выполнения программы с
set\-user\-ID или set\-group\-ID, располагающейся в файловой системе, которая
была смонтирована с флагом \fBMS_NOSUID\fP, как описано в \fBmount\fP(2)).
.SS Разное
.PP
.\"
Когда ID пользователя и группы процесса передаются через доменный сокет UNIX
в процесс в другом пользовательском пространстве имён (смотрите описание
\fBSCM_CREDENTIALS\fP в \fBunix\fP(7)), то они транслируются в соответствующие
значения согласно отображению ID пользователя и группы принимающего
процесса.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
.\"
Пространства имён есть только в Linux.
.SH ЗАМЕЧАНИЯ
.\"
.\" ============================================================
.\"
За эти годы в ядро Linux добавлено много свойств, которые были доступны
только привилегированным пользователям, так как их возможности слишком
велики, чтобы наделять ими приложения с set\-user\-ID. В целом, становится
безопасно разрешать пользователю root в пользовательском пространстве имён
использовать эти свойства, так как будучи в пользовательском пространстве
имён, он не может получить больше прав, чем имеет root в пользовательском
пространстве имён.
.SS Доступность
Для использования пользовательских пространств имён ядро должно быть собрано
с параметром \fBCONFIG_USER_NS\fP. Пользовательские пространства имён требуют
поддержки во многих подсистемах ядра. Если в ядре задействована
неподдерживаемая подсистема, то включить поддержку пользовательских
пространств имён невозможно.
.PP
.\" commit d6970d4b726cea6d7a9bc4120814f95c09571fc3
.\"
В Linux 3.8 самые важные подсистемы поддерживают пользовательские
пространства имён, но значительное количество файловых систем не имеют
инфраструктуры для отображения пользовательских и групповых ID между
пользовательскими пространствами имён. В Linux 3.9 добавлена требуемая
поддержка инфраструктуры во многие неподдерживаемые файловые системы (Plan 9
(9P), Andrew File System (AFS), Ceph, CIFS, CODA, NFS и OCFS2). В Linux 3.12
добавлена поддержка в последние основные файловые системы (XFS).
.SH ПРИМЕР
Представленная далее программа разработана для экспериментов с
пользовательскими пространствами имён. Она создаёт пространства имён
согласно параметрам командной строки и затем выполняет команду внутри этих
пространств имён. В комментариях и функции \fIusage()\fP предоставлено полное
описание программы. Следующий сеанс оболочки показывает её работу.
.PP
Сначала, посмотрим на окружение выполнения:
.PP
.in +4n
.EX
$ \fBuname \-rs\fP     # требуется Linux 3.8 или новее
Linux 3.8.0
$ \fBid \-u\fP         # работа от непривилегированного пользователя
1000
$ \fBid \-g\fP
1000
.EE
.in
.PP
Теперь запустим новую оболочку в новых пользовательском (\fI\-U\fP),
монтирования (\fI\-m\fP) и PID (\fI\-p\fP) пространствах имён с пользовательским
(\fI\-M\fP) и групповым ID (\fI\-G\fP)  1000, отображающимся в 0 внутри
пользовательского пространства имён:
.PP
.in +4n
.EX
$ \fB./userns_child_exec \-p \-m \-U \-M '0 1000 1' \-G '0 1000 1' bash\fP
.EE
.in
.PP
У оболочки PID равен 1, так как это первый процесс в новом пространстве имён
PID:
.PP
.in +4n
.EX
bash$ \fBecho $$\fP
1
.EE
.in
.PP
Смонтируем новую файловую систему \fI/proc\fP и просмотрим все процессы,
видимые в новом пространстве имён PID; убедимся, что оболочка не видит ни
одного процесса вне своего пространства имён PID:
.PP
.in +4n
.EX
bash$ \fBmount \-t proc proc /proc\fP
bash$ \fBps ax\fP
  PID TTY      STAT   TIME COMMAND
    1 pts/3    S      0:00 bash
   22 pts/3    R+     0:00 ps ax
.EE
.in
.PP
Внутри пользовательского пространства имён идентификаторы пользователя и
группы оболочки равны 0, и она имеет полный набор разрешённых и эффективных
мандатов:
.PP
.in +4n
.EX
bash$ \fBcat /proc/$$/status | egrep '^[UG]id'\fP
Uid:	0	0	0	0
Gid:	0	0	0	0
bash$ \fBcat /proc/$$/status | egrep '^Cap(Prm|Inh|Eff)'\fP
CapInh:	0000000000000000
CapPrm:	0000001fffffffff
CapEff:	0000001fffffffff
.EE
.in
.SS "Исходный код программы"
\&
.EX
/* userns_child_exec.c

   Лицензируется на условиях Универсальной общественной лицензии
   GNU версии 2 и новее

   Создаёт дочерний процесс, который запускает командную оболочку
   в новых пространствах имён; может выполнять отображение UID и GID,
   если они указаны при создании пользовательского пространства имён.
*/
#define _GNU_SOURCE
#include <sched.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <signal.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <errno.h>

/* Простая функция обработки ошибок: выводит сообщение об ошибке согласно
   значению в «errno» и завершает вызвавший процесс */

#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \e
                        } while (0)

struct child_args {
    char **argv;        /* команда, выполняемая потомком с параметрами */
    int    pipe_fd[2];  /* канал для синхронизации родителя и потомка */
};

static int verbose;

static void
usage(char *pname)
{
    fprintf(stderr, "Использование: %s [параметры] кмд [арг…]\en\en", pname);
    fprintf(stderr, "Создаёт дочерний процесс, который запускает командную "
            "оболочку в новом пользовательском пространстве имён,\en"
            "и, возможно, также в других новых пространствах имён.\en\en");
    fprintf(stderr, "Параметры:\en\en");
#define fpe(str) fprintf(stderr, "    %s", str);
    fpe("\-i          Новое пространство имён IPC\en");
    fpe("\-m          Новое пространство имён монтирования\en");
    fpe("\-n          Новое сетевое пространство имён\en");
    fpe("\-p          Новое пространство имён PID\en");
    fpe("\-u          Новое пространство имён UTS\en");
    fpe("\-U          Новое пользовательское пространство имён\en");
    fpe("\-M uid_map  карта UID для пользовательского пространства имён\en");
    fpe("\-G gid_map  карта GID для пользовательского пространства имён\en");
    fpe("\-z          Отображать пользовательский UID и GID в 0 в пользовательском пространстве имён\en");
    fpe("            (эквивалентно: \-M \(aq0 <uid> 1\(aq \-G \(aq0 <gid> 1\(aq)\en");
    fpe("\-v          показывать дополнительные сообщения\en");
    fpe("\en");
    fpe("Если указан \-z, \-M или \-G, то требуется \-U.\en");
    fpe("Нельзя указывать \-z вместе с \-M или \-G.\en");
    fpe("\en");
    fpe("Строка карты для \-M и \-G состоит из записей вида:\en");
    fpe("\en");
    fpe("    ID\-внутри\-ns   ID\-вне\-ns   длина\en");
    fpe("\en");
    fpe("Строка карты может содержать несколько записей через запятую;\en");
    fpe("запятые замещаются на символы новой строки перед записью"
        " в файлы карт.\en");

    exit(EXIT_FAILURE);
}

/* Обновляем файл отображения «map_file» значением из
   «mapping» — строкой, в которой определены отображения UID или GID.
   Отображения UID или GID состоят из одной или более записей
   (разделённых символом новой строки) вида:

       ID\-внутри\-ns    ID\-снаружи\-ns   длина

   Требовать от пользователя указывать строку с символами новой строки
   в командной строке неприемлемо. Поэтому мы позволим использовать
   для разделения записей запятые и заменим их символами новой строки
   перед записью строки в файл. */

static void
update_map(char *mapping, char *map_file)
{
    int fd, j;
    size_t map_len;     /* длина «mapping» */

    /* Заменяем запятые на символы новой строки в строке отображения */

    map_len = strlen(mapping);
    for (j = 0; j < map_len; j++)
        if (mapping[j] == \(aq,\(aq)
            mapping[j] = \(aq\en\(aq;

    fd = open(map_file, O_RDWR);
    if (fd == \-1) {
        fprintf(stderr, "ОШИБКА: open %s: %s\en", map_file,
                strerror(errno));
        exit(EXIT_FAILURE);
    }

    if (write(fd, mapping, map_len) != map_len) {
        fprintf(stderr, "ОШИБКА: write %s: %s\en", map_file,
                strerror(errno));
        exit(EXIT_FAILURE);
    }

    close(fd);
}

/* В Linux 3.19 изменена работа с setgroups(2) и добавлен файл
   \(aqgid_map\(aq для обеспечения безопасности. Задача в том,
   чтобы запретить удалять группы *непривилегированному* пользователю
   через создание пространства имён. Результат изменений 3.19 в том, что
   для обновления файла \(aqgid_maps\(aq, сначала нужно запретить системный
   вызов setgroups() в этом пользовательском пространстве имён, записав
   "deny" в один из файлов /proc/PID/setgroups в этом пространстве имён.
   Это цель данной функции. */

static void
proc_setgroups_write(pid_t child_pid, char *str)
{
    char setgroups_path[PATH_MAX];
    int fd;

    snprintf(setgroups_path, PATH_MAX, "/proc/%ld/setgroups",
            (long) child_pid);

    fd = open(setgroups_path, O_RDWR);
    if (fd == \-1) {

        /* Система может не поддерживать
           /proc/PID/setgroups. В этом случае файл не существует,
           и система не закладывает ограничений, добавленных в Linux 3.19.
           Хорошо, нам не нужно ничего делать, чтобы разрешить
           обновлять \(aqgid_map\(aq.

           Однако, если ошибка open() отличается от
           ENOENT, сообщим об этом пользователю. */

        if (errno != ENOENT)
            fprintf(stderr, "ERROR: open %s: %s\en", setgroups_path,
                strerror(errno));
        return;
    }

    if (write(fd, str, strlen(str)) == \-1)
        fprintf(stderr, "ОШИБКА: write %s: %s\en", setgroups_path,
            strerror(errno));

    close(fd);
}

static int              /* Начальная функция клонированного потомка */
childFunc(void *arg)
{
    struct child_args *args = (struct child_args *) arg;
    char ch;

    /* Ждём пока родитель обновит отображения UID и GID.
       Смотрите комментарий в main(). Мы ждём конца файла в канале,
       который будет закрыт родительским процессом после обновления
       отображений. */

    close(args\->pipe_fd[1]);    /* закрываем наш дескриптор для записи
                                   конца канала для того, чтобы мы
                                   увидели EOF, когда родитель закроет
                                   свой дескриптор */
    if (read(args\->pipe_fd[0], &ch, 1) != 0) {
        fprintf(stderr,
                "Ошибка в потомке: при чтении из канала получен != 0\en");
        exit(EXIT_FAILURE);
    }

    close(args\->pipe_fd[0]);

    /* Запускаем командную оболочку */

    printf("О exec %s\en", args\->argv[0]);
    execvp(args\->argv[0], args\->argv);
    errExit("execvp");
}

#define STACK_SIZE (1024 * 1024)

static char child_stack[STACK_SIZE];    /* место под стек в потомке */

int
main(int argc, char *argv[])
{
    int flags, opt, map_zero;
    pid_t child_pid;
    struct child_args args;
    char *uid_map, *gid_map;
    const int MAP_BUF_SIZE = 100;
    char map_buf[MAP_BUF_SIZE];
    char map_path[PATH_MAX];

    /* Разбираем параметры командной строки. Начальный символ «+» в
       последнем аргументе getopt() предотвращает подстановку параметров
       командной строки в стиле GNU. Это полезно, так как иногда
       «команда», выполняемая этой программой, сама имеет параметры
       командной строки. Мы не хотим, чтобы getopt() передала их
       нашей программе. */

    flags = 0;
    verbose = 0;
    gid_map = NULL;
    uid_map = NULL;
    map_zero = 0;
    while ((opt = getopt(argc, argv, "+imnpuUM:G:zv")) != \-1) {
        switch (opt) {
        case \(aqi\(aq: flags |= CLONE_NEWIPC;        break;
        case \(aqm\(aq: flags |= CLONE_NEWNS;         break;
        case \(aqn\(aq: flags |= CLONE_NEWNET;        break;
        case \(aqp\(aq: flags |= CLONE_NEWPID;        break;
        case \(aqu\(aq: flags |= CLONE_NEWUTS;        break;
        case \(aqv\(aq: verbose = 1;                  break;
        case \(aqz\(aq: map_zero = 1;                 break;
        case \(aqM\(aq: uid_map = optarg;             break;
        case \(aqG\(aq: gid_map = optarg;             break;
        case \(aqU\(aq: flags |= CLONE_NEWUSER;       break;
        default:  usage(argv[0]);
        }
    }

    /* \-M или \-G без \-U не имеют смысла */

    if (((uid_map != NULL || gid_map != NULL || map_zero) &&
                !(flags & CLONE_NEWUSER)) ||
            (map_zero && (uid_map != NULL || gid_map != NULL)))
        usage(argv[0]);

    args.argv = &argv[optind];

    /* Мы используем канал для синхронизации родителя и потомка, чтобы
       родитель настроил отображения UID и GID до того, как потомок
       вызовет execve(). Это гарантирует, что потомок предъявит свои
       мандаты при execve(); обычно мы хотим отобразить эффективный
       пользовательский ID потомка в 0 в новом пользовательском
       пространстве имён. Без этой синхронизации потомок потерял
       бы свои мандаты при вызове execve() с ненулевым пользовательским
       ID (смотрите в справочной странице capabilities(7) подробности
       преобразования мандатов процесса при execve()). */

    if (pipe(args.pipe_fd) == \-1)
        errExit("pipe");

    /* создаём потомка в новом пространстве имён */

    child_pid = clone(childFunc, child_stack + STACK_SIZE,
                      flags | SIGCHLD, &args);
    if (child_pid == \-1)
        errExit("clone");

    /* предок попадает сюда */

    if (verbose)
        printf("%s: PID потомка, созданного clone(): %ld\en",
                argv[0], (long) child_pid);

    /* обновляем отображения UID и GID в потомке */

    if (uid_map != NULL || map_zero) {
        snprintf(map_path, PATH_MAX, "/proc/%ld/uid_map",
                (long) child_pid);
        if (map_zero) {
            snprintf(map_buf, MAP_BUF_SIZE, "0 %ld 1", (long) getuid());
            uid_map = map_buf;
        }
        update_map(uid_map, map_path);
    }

    if (gid_map != NULL || map_zero) {
        proc_setgroups_write(child_pid, "deny");

        snprintf(map_path, PATH_MAX, "/proc/%ld/gid_map",
                (long) child_pid);
        if (map_zero) {
            snprintf(map_buf, MAP_BUF_SIZE, "0 %ld 1", (long) getgid());
            gid_map = map_buf;
        }
        update_map(gid_map, map_path);
    }

    /* закрываем конец канала на стороне записи для сообщения потомку
       о том, что мы обновили отображения UID и GID */

    close(args.pipe_fd[1]);

    if (waitpid(child_pid, NULL, 0) == \-1)      /* ждём потомка */
        errExit("waitpid");

    if (verbose)
        printf("%s: завершение\en", argv[0]);

    exit(EXIT_SUCCESS);
}
.EE
.SH "СМОТРИТЕ ТАКЖЕ"
.\" From the shadow package
.\" From the shadow package
.\" From the shadow package
.\" From the shadow package
\fBnewgidmap\fP(1), \fBnewuidmap\fP(1), \fBclone\fP(2), \fBptrace\fP(2), \fBsetns\fP(2),
\fBunshare\fP(2), \fBproc\fP(5), \fBsubgid\fP(5), \fBsubuid\fP(5), \fBcapabilities\fP(7),
\fBcgroup_namespaces\fP(7)  \fBcredentials\fP(7), \fBnamespaces\fP(7),
\fBpid_namespaces\fP(7)
.PP
Файл из дерева исходного кода ядра
\fIDocumentation/namespaces/resource\-control.txt\fP.
