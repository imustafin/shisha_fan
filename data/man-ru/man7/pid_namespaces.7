.\" -*- mode: troff; coding: UTF-8 -*-
.\" Copyright (c) 2013 by Michael Kerrisk <mtk.manpages@gmail.com>
.\" and Copyright (c) 2012 by Eric W. Biederman <ebiederm@xmission.com>
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH PID_NAMESPACES 7 2019\-03\-06 Linux "Руководство программиста Linux"
.SH ИМЯ
pid_namespaces \- обзор пространств имён Linux PID
.SH ОПИСАНИЕ
Обзор пространств имён смотрите в \fBnamespaces\fP(7).
.PP
Пространства имён PID изолируют пространство номеров идентификаторов
процессов, то есть процессы в разных пространствах имён PID могут иметь
единый  PID. Пространства имён PID позволяют предоставлять такие возможности
в контейнерах как приостановку/возобновление работы набора процессов в
контейнере и перенос контейнера на новый узел, при чём процессы внутри
контейнера сохранят свои PID.
.PP
Идентификаторы в новом пространстве имён PID начинаются с 1 как в автономной
системе, и вызовы \fBfork\fP(2), \fBvfork\fP(2) или \fBclone\fP(2) будут создавать
процессы с уникальными идентификаторами в пределах пространства имён.
.PP
.\"
.\" ============================================================
.\"
Для использования пространств имён PID требуется, чтобы ядро было собрано с
параметром \fBCONFIG_PID_NS\fP.
.SS "Пространство имён начального процесса"
Первый процесс, созданный в новом пространстве имён (т. е., процесс,
созданный вызовом \fBclone\fP(2) с флагом \fBCLONE_NEWPID\fP или первый потомок,
созданный процессом после вызова \fBunshare\fP(2) с флагом \fBCLONE_NEWPID\fP)
имеет PID 1, и это «начальный» (init) процесс пространства имён (смотрите
\fBinit\fP(1)). Этот процесс становится родителем всех дочерних процессов,
которые осиротели из\-за завершения родителей, находящихся внутри этого
пространства имён PID (дополнительную информацию смотрите ниже).
.PP
Если процесс «init» пространства имён PID завершает работу, то ядро
завершает работу всех процессов в пространстве имён с помощью сигнала
\fBSIGKILL\fP. Такое поведение показывает, что процесс «init» необходим для
корректной работы пространства имён PID. В этом случае последующий вызов
\fBfork\fP(2) в этом пространство имён PID завершается ошибкой \fBENOMEM\fP;
невозможно создать новый процесс в пространстве имён PID, в котором не
работает процесс «init». Такое может произойти, например, когда процесс
использует открытый файловый дескриптор файла \fI/proc/[pid]/ns/pid\fP,
соответствующий процессу, который был в пространстве имён \fBsetns\fP(2), в
этом пространстве имён после того, как процесс «init» завершился. Другой
возможный сценарий может произойти после вызова \fBunshare\fP(2): если первый
потомок после этого созданный \fBfork\fP(2) завершится, то последующие вызовы
\fBfork\fP(2)  завершаются ошибкой \fBENOMEM\fP.
.PP
Члены пространства имён PID могут посылать процессу «init» только сигналы,
для которых процесс «init» установил обработчики.\ Это ограничение
применяется даже к привилегированным процессам, и не позволяет другим членам
пространства имён PID нечаянно убить процесс «init».
.PP
Также, процесс в родительском пространстве имён может (пройдя обычные
проверки прав, описанные в \fBkill\fP(2)) послать сигнал процессу «init»
дочернего пространства имён PID только, если процесс «init» задал
обработчики для этого сигнала (внутри обработчика \fIsi_pid\fP в \fIsiginfo_t\fP,
описанное в \fBsigaction\fP(2) будет равно нулю). Для сигналов \fBSIGKILL\fP и
\fBSIGSTOP\fP сделано исключение: эти сигналы принудительно доставляются при
отправке из родительского пространства имён PID. Ни один из них не может
быть пойман процессом «init», и в результате будут выполнены обычные
действия, связанные с этими сигналами (завершение и останов процесса,
соответственно).
.PP
.\"
.\" ============================================================
.\"
Начиная с Linux 3.4, системный вызов \fBreboot\fP(2) посылает сигнал в
пространство имён процесса «init». Подробности смотрите в \fBreboot\fP(2).
.SS "Вложенные пространства имён PID"
.\" commit f2302505775fd13ba93f034206f1e2a587017929
.\" The kernel constant MAX_PID_NS_LEVEL
Пространства имён PID могут быть вложенными: каждое пространство имён PID
имеет родителя, за исключением начального («корневого») пространства имён
PID. Родитель пространства имён PID — это пространство имён PID процесса,
который был создан в пространстве имён с помощью \fBclone\fP(2) или
\fBunshare\fP(2). Таким образом пространства имён PID образуют дерево со всеми
пространствами имён по которому, в конечном счёте, можно проследить их
родословную до корневого пространства имён. Начиная с Linux 3.7, ядро
ограничивает  глубину максимальной вложенности пространств имён PID
значением 32.
.PP
Процесс видим другим процессам в своём пространстве имён PID, и процессам в
каждом прямом родительском пространстве имён PID вплоть до корневого
пространства имён PID. В этом контексте «видимость» означает, что процесс
может быть целью операции другого процесса в системных вызовах, который
указывает идентификатор процесса. И наоборот, процессы в дочернем
пространстве имён PID не видят процессы в родительском и более удалённых
родительских пространствах имён. Более кратко: процесс может видеть
(например, посылать сигналы с помощью \fBkill\fP(2), назначать значения
уступчивости с помощью \fBsetpriority\fP(2) и т. п.) только процессы из своего
пространства имён PID и в потомках этого пространства имён.
.PP
Процесс имеет идентификатор в каждом слое иерархии пространства имён PID, в
котором он виден, и двигаясь назад, в каждом прямом предке пространства имён
вплоть до корневого пространства имён PID. Системные вызовы, работающие с
идентификатором процесса, всегда используют идентификатор процесса, который
видим в пространстве имён PID вызывающего. Вызов \fBgetpid\fP(2) всегда
возвращает PID, связанный с пространством имён, в котором был создан
процесс.
.PP
Некоторые процессы в пространстве имён PID могут иметь родителей, которые
находятся вне пространства имён. Например, родитель начального процесса в
пространстве имён (т. е., процесс \fBinit\fP(1) с PID 1) неизбежно находится в
другом пространстве имён. Аналогичным образом, прямые потомки процесса,
который использует \fBsetns\fP(2) для объединения потомков в пространство имён
PID, находятся в другом пространстве имён PID относительно вызывающего
\fBsetns\fP(2). При вызове \fBgetppid\fP(2) для таких процессов возвращает 0.
.PP
Хотя процессы могут свободно перемещаться вниз в дочерние пространства имён
PID (например, с помощью \fBsetns\fP(2) с файловым дескриптором пространства
имён PID), они не могут перемещаться в обратном направлении. То есть
процессы не могут входить в пространства имён предка (родителя, прародителя
и т .п.). Изменение пространств имён PID — это односторонняя операция.
.PP
.\"
.\" ============================================================
.\"
Операцию \fBNS_GET_PARENT\fP \fBioctl\fP(2) можно использовать для обнаружения
родительской связи между пространствами имён PID; смотрите \fBioctl_ns\fP(2).
.SS "Семантика setns(2) и unshare(2)"
Последовательно выполняемые вызовы \fBsetns\fP(2) с файловым дескриптором
пространства имён PID и вызов \fBunshare\fP(2) с флагом \fBCLONE_NEWPID\fP
помещают потомков в другое пространство имён PID, отличное от пространства
вызывающего (начиная с Linux 4.12 данное пространство имён PID показывается
через файл \fI/proc/[pid]/ns/pid_for_children\fP как описано в
\fBnamespaces\fP(7)). Однако, эти вызовы не изменяют пространство имён PID
вызывающего процесса, так как это позволило бы изменять PID вызывающего
(сообщаемые \fBgetpid\fP()), что сломало бы многие приложения и библиотеки.
.PP
Посмотрим на вещи под другим углом: членство процесса в пространстве имён
PID определяется при создании процесса и не может быть изменено в
дальнейшем. Помимо прочего, это означает, что родственные отношения между
процессами зеркально отражают родственные отношения между пространствами
имён PID: родитель процесса находится в том же пространстве имён или в
непосредственном родительском пространстве имён namespace.
.PP
.\"
.\" ============================================================
.\"
Процесс может вызвать \fBunshare\fP(2) с флагом \fBCLONE_NEWPID\fP только один
раз. После выполнения этой операции его символическая ссылка
\fI/proc/PID/ns/pid_for_children\fP станет пустой, пока пространстве имён не
будет создать первый потомок.
.SS "Усыновление осиротевших потомков"
Когда дочерний процесс становится сиротой, его родителем становится
«начальный» процесс в пространстве имён PID его родителя (если один из
ближайших родственных процессов родителя не вызывал команду \fBprctl\fP(2)
\fBPR_SET_CHILD_SUBREAPER\fP для назначения себя сборщиком собирателем дочерних
процессов). Заметим, что благодаря семантике \fBsetns\fP(2) и \fBunshare\fP(2),
описанной выше, это может быть процесс «init» в пространстве имён PID,
являющийся \fIродителем\fP пространства имён PID потомка, а не процесс «init»
пространства имён PID самого потомка.

.\" Furthermore, by definition, the parent of the "init" process
.\" of a PID namespace resides in the parent PID namespace.
.\"
.\" ============================================================
.\"
.SS "Совместимость CLONE_NEWPID с другими флагами CLONE_*"
В текущих версиях Linux \fBCLONE_NEWPID\fP нельзя объединять вместе с
\fBCLONE_THREAD\fP. Для нитей требуется находиться в том же пространстве имён
PID, чтобы нити процесса могли посылать сигналы друг другу. Также требуется
видеть все нити процессов в файловой системе \fBproc\fP(5). Также, если две
нити находятся в разных пространствах имён PID, то ID процесса, посылающего
сигнал, невозможно достоверно закодировать при посылке (смотрите описание
типа \fIsiginfo_t\fP в \fBsigaction\fP(2)). Так как вычисление выполняется когда
сигнал попадает в очередь сигналов, общая для процессов из нескольких
пространств имён PID, очередь сигналов не позволяет этого.
.PP
.\" Note these restrictions were all introduced in
.\" 8382fcac1b813ad0a4e68a838fc7ae93fa39eda0
.\" when CLONE_NEWPID|CLONE_VM was disallowed
.\" (restriction lifted in faf00da544045fdc1454f3b9e6d7f65c841de302)
.\" (restriction lifted in e79f525e99b04390ca4d2366309545a836c03bf1)
.\"
.\" ============================================================
.\"
В ранних версиях Linux значение \fBCLONE_NEWPID\fP также запрещалось
(возвращалась ошибка \fBEINVAL\fP) объединять с \fBCLONE_SIGHAND\fP (до Linux
4.3), а также с \fBCLONE_VM\fP (до Linux 3.12). Изменения, снявшие эти
ограничения, были также перенесены в более ранние стабильные ядра.
.SS "/proc и PID пространств имен"
В файловой системе \fI/proc\fP отображаются (в каталогах \fI/proc/[pid]\fP) только
процессы, видимые в пространстве имён PID процесса, который выполнил
монтирование, даже если файловая система \fI/proc\fP видима из процессов
другого пространства имён.
.PP
После создания нового пространства имён PID у потомка полезно изменить его
корневой каталог и смонтировать новый экземпляр procfs в \fI/proc\fP для того,
чтобы корректно работали инструменты типа \fBps\fP(1). Если одновременно
создаётся новое пространство имён монтирования, добавлением флага
\fBCLONE_NEWNS\fP в аргумент \fIflags\fP вызова \fBclone\fP(2) или \fBunshare\fP(2), то
необязательно изменять корневой каталог: новый экземпляр procfs можно
смонтировать непосредственно в \fI/proc\fP.
.PP
Команда оболочки для монтирования \fI/proc\fP:
.PP
.in +4n
.EX
$ mount \-t proc proc /proc
.EE
.in
.PP
.\"
.\" ============================================================
.\"
Вызов \fBreadlink\fP(2) с путём \fI/proc/self\fP выдаёт идентификатор процесса
вызывающего из пространства имён PID, откуда смонтирован procfs (т. е., из
пространства имён PID процесса, который смонтировал procfs). Это может быть
полезно при самоанализе, когда процесс хочет узнать свой PID в других
пространствах имён.
.SS "Файлы в /proc"
.TP 
\fB/proc/sys/kernel/ns_last_pid\fP (начиная с Linux 3.3)
.\" commit b8f566b04d3cddd192cfd2418ae6d54ac6353792
Этот файл отражает последний PID, который был выделен в этом пространстве
имён PID. Когда выделяется следующий PID, ядро ищет самый маленький не
выделенный PID, который больше этого значения, и при следующем чтении этого
файла в нём будет этот PID.
.IP
.\" This ability is necessary to support checkpoint restore in user-space
.\"
.\" ============================================================
.\"
Этот файл доступен на запись процессу с мандатом \fBCAP_SYS_ADMIN\fP внутри
своего пространства имён пользователя. Это делает возможным задать PID,
который выделяется следующему процессу, создаваемому внутри этого
пространства имён PID.
.SS Разное
Когда идентификатор процесса передаётся через доменный сокет UNIX в процесс
в другом пространстве имён PID (смотрите описание \fBSCM_CREDENTIALS\fP в
\fBunix\fP(7)), то он транслируется в соответствующее значения PID из
пространства имён PID принимающего процесса.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
Пространства имён есть только в Linux.
.SH ПРИМЕР
См. \fBuser_namespaces\fP(7).
.SH "СМОТРИТЕ ТАКЖЕ"
\fBclone\fP(2), \fBreboot\fP(2), \fBsetns\fP(2), \fBunshare\fP(2), \fBproc\fP(5),
\fBcapabilities\fP(7), \fBcredentials\fP(7), \fBmount_namespaces\fP(7),
\fBnamespaces\fP(7), \fBuser_namespaces\fP(7), \fBswitch_root\fP(8)
