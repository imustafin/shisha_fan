.\" -*- mode: troff; coding: UTF-8 -*-
.\" Copyright (C) 2013, Heinrich Schuchardt <xypron.glpk@gmx.de>
.\" and Copyright (C) 2014, Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of
.\" this manual under the conditions for verbatim copying, provided that
.\" the entire resulting derived work is distributed under the terms of
.\" a permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume.
.\" no responsibility for errors or omissions, or for damages resulting.
.\" from the use of the information contained herein.  The author(s) may.
.\" not have taken the same level of care in the production of this.
.\" manual, which is licensed free of charge, as they might when working.
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH FANOTIFY 7 2019\-08\-02 Linux "Руководство программиста Linux"
.SH ИМЯ
fanotify \- отслеживание событий в файловой системе
.SH ОПИСАНИЕ
Программный интерфейс fanotify уведомляет о событиях в файловой системе и
перехватывает их. Например, его можно использовать для сканирования файлов
на вирусы и управления иерархическим хранилищем. В настоящее время,
поддерживается только ограниченный набор событий. В частности, не
поддерживаются события создания, удаления и перемещения (о программном
интерфейсе для этих событий смотрите в \fBinotify\fP(7)).
.PP
Дополнительные возможности по сравнению с программным интерфейсом
\fBinotify\fP(7): способность отслеживать все объекты в смонтированной файловой
системе, давать права на доступ и читать или изменять файлы перед тем как
доступ получат другие приложения.
.PP
В программный интерфейс входят следующие системные вызовы:
\fBfanotify_init\fP(2), \fBfanotify_mark\fP(2), \fBread\fP(2), \fBwrite\fP(2) и
\fBclose\fP(2).
.SS "Вызовы fanotify_init(), fanotify_mark() и группы уведомлений"
Системный вызов \fBfanotify_init\fP(2) создаёт и инициализирует группу
уведомления fanotify и возвращает указывающий на неё файловый дескриптор.
.PP
Группа уведомления fanotify — это внутренний объект ядра, в котором хранится
список файлов, каталогов, файловых систем и точек монтирования, для которых
должны создаваться события.
.PP
У каждой записи в группе уведомления fanotify есть две битовые маски:
\fIметок\fP и \fIигнорирования\fP. В маске меток указывается для каких действий на
файлами должны создаваться события. В маске игнорирования указывается для
каких действий не должны создаваться события. Имея маски таких типов можно
пометить файловую систему, точку монтирования или каталог для получения
событий, и в тоже время игнорировать события для определённых объектов в
этой точке монтирования или каталоге.
.PP
Системный вызов \fBfanotify_mark\fP(2) добавляет файл, каталог, файловую
систему или точку монтирования в группу уведомления и задаёт какие события
должны отслеживаться (или игнорироваться), или удаляет или изменяет нужную
запись.
.PP
Возможное применение маски игнорирования — кэш файлов. Интересующие события
для файлового кэша — изменение файла и закрытие. Для этого добавляем
кэшируемый каталог или точку монтирования для приёма этих событий. После
получения первого события об изменении файла, соответствующая запись кэша
помечается как недействительная. Дальнейшие события об изменении файла нас
не интересуют, пока файл не будет закрыт. Для этого событие об изменении
можно добавить в маску игнорирования. При получении события о закрытии,
событие об изменении можно удалить из маски игнорирования и запись файлового
кэша можно обновить.
.PP
Записи в группе уведомления fanotify ссылаются на файл и каталог по номеру
иноды (inode), а на точку монтирования — через ID монтирования. При
переименовании или перемещении файла или каталога внутри той же точки
монтирования соответствующая запись остаётся. Если файл или каталог
удаляется или перемещается в другую точку монтирования, или если файловая
система или точка монтирования размонтируется, то соответствующая запись
удаляется.
.SS "Очередь событий"
Для возникающих событий с объектами файловой системы, которые отслеживаются
группой уведомления, система fanotify генерирует события и помещает их в
очередь. После этого события можно прочитать (с помощью \fBread\fP(2) и
подобных) из файлового дескриптора fanotify, возвращённого
\fBfanotify_init\fP(2).
.PP
Генерируется два типа событий: события \fIуведомления\fP и события
\fIдоступа\fP. Уведомляющие события просто информируют и не требуют действия от
принявшего приложения, за исключением того, что файловый дескриптор,
передаваемый в событии общего типа, должен быть закрыт. Закрытие файловых
дескрипторов для каждого события применяется только приложениями, которые
инициализировали fanotify без использования \fBFAN_REPORT_FID\fP (смотрите
ниже). События доступа запрашивают получившее приложение о разрешении
доступа к файлу. Для этих событий получатель должен написать ответ, давать
ли доступ или нет.
.PP
Событие удаляется из очереди событий группы fanotify после
прочтения. События доступа, которые были прочитаны, остаются во внутреннем
списке группы fanotify до тех пор, пока решение о доступе не будет записано
в файловый дескриптор fanotify, или файловый дескриптор fanotify не будет
закрыт.
.SS "Чтение событий fanotify"
Вызов \fBread\fP(2) с файловым дескриптором, полученным от \fBfanotify_init\fP(2),
блокирует выполнение (если не указан флаг \fBFAN_NONBLOCK\fP в вызове
\fBfanotify_init\fP(2)) до тех пор, пока не произойдёт файловое событие или
вызов не будет прерван сигналом (смотрите \fBsignal\fP(7)).
.PP
При указании флага \fBFAN_REPORT_FID\fP в \fBfanotify_init\fP(2) структуры данных
возвращаются слушателю событий в каждом событии. После успешного выполнения
\fBread\fP(2) буфер чтения содержит одну или более следующих структур:
.PP
.in +4n
.EX
struct fanotify_event_metadata {
    __u32 event_len;
    __u8 vers;
    __u8 reserved;
    __u16 metadata_len;
    __aligned_u64 mask;
    __s32 fd;
    __s32 pid;
};
.EE
.in
.PP
Если в \fBfanotify_init\fP(2) среди флагов указан и \fBFAN_REPORT_FID\fP, то вы
также должны ожидать структуру после общей структуры
\fIfanotify_event_metadata\fP в буфере чтения:
.PP
.in +4n
.EX
struct fanotify_event_info_fid {
    struct fanotify_event_info_header hdr;
    __kernel_fsid_t fsid;
    unsigned char file_handle[0];
};
.EE
.in
.PP
Для увеличения производительности рекомендуется использовать буфер большого
размера (например, 4096 байт) для того, чтобы получить несколько событий за
один вызов \fBread\fP(2).
.PP
Возвращаемое \fBread\fP(2) значение — количество байт помещённых в буфер, или
\-1 в случае ошибки (но смотрите ДЕФЕКТЫ).
.PP
Поля структуры \fIfanotify_event_metadata\fP:
.TP 
\fIevent_len\fP
Длина данных текущего события и смещение на следующее событие в буфере. Без
\fBFAN_REPORT_FID\fP значение \fIevent_len\fP всегда равно
\fBFAN_EVENT_METADATA_LEN\fP. С \fBFAN_REPORT_FID\fP значение \fIevent_len\fP также
включает идентификатор файла переменной длины.
.TP 
\fIvers\fP
Номер версии структуры. Он должен сравниваться с
\fBFANOTIFY_METADATA_VERSION\fP для проверки того, что структуры, возвращаемые
во время выполнения, соответствуют структурам, определённым во время
компиляция. В случае несоответствия приложение должно прекратить попытки
использовать файловый дескриптор fanotify.
.TP 
\fIreserved\fP
Не используется.
.TP 
\fImetadata_len\fP
Длина структуры. Это поле было добавлено для облегчения реализации
необязательных заголовков разных типов событий. В текущей реализации такие
необязательные заголовки отсутствуют.
.TP 
\fImask\fP
Битовая маска, описывающая событие (смотрите далее).
.TP 
\fIfd\fP
Открытый файловый дескриптор объекта доступа или \fBFAN_NOFD\fP, если возникло
переполнение очереди. Если файловый дескриптор fanotify инициализирован с
использованием \fBFAN_REPORT_FID\fP,то приложения должны ожидать, что это
значение равно \fBFAN_NOFD\fP у каждого полученного события. Файловый
дескриптор можно использовать для доступа к содержимому отслеживаемого файла
или каталога. Читающее приложение ответственно за закрытие этого файлового
дескриптора.
.IP
Когда вызывается \fBfanotify_init\fP(2) вызывающий может указать (в аргументе
\fIevent_f_flags\fP) различные флаги состояния файла, которые будут установлены
на открытом файловом дескрипторе, соответствующем этому файловому
дескриптору. Также, на отрываемом файловом дескрипторе устанавливается
(внутри ядра) флаг состояния файла \fBFMODE_NONOTIFY\fP. Этот флаг подавляет
генерацию событий fanotify. Таким образом, когда получатель события fanotify
обратится к отслеживаемому файлу или каталогу через этот файловый
дескриптор, дополнительных событий создано не будет.
.TP 
\fIpid\fP
Если в \fBfanotify_init\fP(2) установлен флаг \fBFAN_REPORT_TID\fP, то это TID
нити, из\-за которой возникло событие. В противном случае это PID процесса,
из\-за которой возникло событие.
.PP
Программа, слушающая события fanotify, может сравнить этот PID с PID,
возвращаемым \fBgetpid\fP(2), для проверки, что событие не возникло из\-за
самого слушающего, а из\-за доступа к файлу другого процесса.
.PP
В битовой маске \fImask\fP указывают события, произошедшие с одиночным объектом
файловой системы. В маске может быть установлено несколько бит, если было
более одного события с отслеживаемым объектом файловой системы. В частности,
возникшие друг за другом события с одним объектом файловой системы и
произошедшие из\-за одного процесса могут быть объединены в одно событие, за
исключением того, что два события доступа никогда не объединяются в одном
элементе очереди.
.PP
Биты маски \fImask\fP:
.TP 
\fBFAN_ACCESS\fP
Доступ (на чтение) к файлу или каталогу (но смотрите ДЕФЕКТЫ).
.TP 
\fBFAN_OPEN\fP
Файл или каталог открыт.
.TP 
\fBFAN_OPEN_EXEC\fP
Файл открыт для выполнения. Смотрите ЗАМЕЧАНИЯ в \fBfanotify_mark\fP(2).
.TP 
\fBFAN_ATTRIB\fP
Метаданные файла или каталога изменены.
.TP 
\fBFAN_CREATE\fP
Создан дочерний файл или каталог в отслеживаемом родителе.
.TP 
\fBFAN_DELETE\fP
Удалён дочерний файл или каталог в отслеживаемом родителе.
.TP 
\fBFAN_DELETE_SELF\fP
Отслеживаемый файл или каталог был удалён.
.TP 
\fBFAN_MOVED_FROM\fP
Дочерний файл или каталог был перемещён из отслеживаемого родительского
каталога.
.TP 
\fBFAN_MOVED_TO\fP
Дочерний файл или каталог был помещён в отслеживаемый родительский каталог.
.TP 
\fBFAN_MOVE_SELF\fP
Отслеживаемый файл или каталог был перемещён.
.TP 
\fBFAN_MODIFY\fP
Файл изменён.
.TP 
\fBFAN_CLOSE_WRITE\fP
Файл, открытый на запись (\fBO_WRONLY\fP или \fBO_RDWR\fP), закрыт.
.TP 
\fBFAN_CLOSE_NOWRITE\fP
Файл или каталог, открытый только для чтения (\fBO_RDONLY\fP), закрыт.
.TP 
\fBFAN_Q_OVERFLOW\fP
Очередь событий превысила ограничение в 16384 записи. Это ограничение можно
изменить, указав флаг \fBFAN_UNLIMITED_QUEUE\fP при вызове \fBfanotify_init\fP(2).
.TP 
\fBFAN_ACCESS_PERM\fP
Приложение хочет прочитать файл или каталог, например, с помощью \fBread\fP(2)
или \fBreaddir\fP(2). Читатель события должен написать ответ (описано далее) о
разрешении доступа к объекту файловой системы.
.TP 
\fBFAN_OPEN_PERM\fP
Приложение хочет открыть файл или каталог. Читатель события должен написать
ответ о разрешении открытия объекта файловой системы.
.TP 
\fBFAN_OPEN_EXEC_PERM\fP
Приложение хочет открыть файл для выполнения. Читатель должен написать ответ
о разрешении открытия объекта файловой системы для выполнения. Смотрите
ЗАМЕЧАНИЯ в \fBfanotify_mark\fP(2).
.PP
Для проверки любого события закрытия может использоваться следующая битовая
маска:
.TP 
\fBFAN_CLOSE\fP
Файл закрыт. Это синоним:
.IP
    FAN_CLOSE_WRITE | FAN_CLOSE_NOWRITE
.PP
Для проверки любого события перемещения может использоваться следующая
битовая маска:
.TP 
\fBFAN_MOVE\fP
Файл или каталог был перемещён. Это синоним для:
.IP
    FAN_MOVED_FROM | FAN_MOVED_TO
.PP
Поля структуры \fIfanotify_event_info_fid\fP:
.TP 
\fIhdr\fP
Структура типа \fIfanotify_event_info_header\fP. Это общий заголовок,
содержащий информацию для описания дополнительной информации, присоединяемой
к событию. Например, когда файловый дескриптор fanotify создан с
использованием \fBFAN_REPORT_FID\fP, поле \fIinfo_type\fP этого заголовка равно
\fBFAN_EVENT_INFO_TYPE_FID\fP. Слушатели события могут использовать это поле
для проверки того, что полученная дополнительная информация о событии имеет
правильный тип. Также \fIfanotify_event_info_header\fP содержит поле \fIlen\fP.  В
текущей реализации значение \fIlen\fP всегда равно (event_len \-
FAN_EVENT_METADATA_LEN).
.TP 
\fIfsid\fP
Уникальный идентификатор файловой системы, содержащей объект, связанный с
событием. Это структура имеет тип \fI__kernel_fsid_t\fP и содержит те же
значения что и \fIf_fsid\fP при вызове \fBstatfs\fP(2).
.TP 
\fIfile_handle\fP
Структура переменной длины, имеет тип \fIfile_handle\fP. Это закрытый
описатель, который соответствует заданному объекту файловой системы,
возвращается \fBname_to_handle_at\fP(2). Её можно использовать как уникально
определяемую файл в файловой системе и передавать аргументом в
\fBopen_by_handle_at\fP(2). Заметим, что для событий элементов каталога, таких
как \fBFAN_CREATE\fP, \fBFAN_DELETE\fP, и \fBFAN_MOVE\fP, значение \fIfile_handle\fP
описывает изменяемый каталог, а не созданный/удалённый/перемещённый дочерний
объект. События \fBFAN_ATTRIB\fP, \fBFAN_DELETE_SELF\fP и \fBFAN_MOVE_SELF\fP будут
содержать информацию \fIfile_handle\fP о дочернем объекте, если дочерний объект
отслеживается.
.PP
Следующие макросы позволяют обходить буфер с метаданными событий fanotify,
возвращаемый \fBread\fP(2) из файлового дескриптора fanotify:
.TP 
\fBFAN_EVENT_OK(meta, len)\fP
Этот макрос сверяет оставшуюся длину \fIlen\fP буфера \fImeta\fP с длиной
структуры метаданных и полем \fIevent_len\fP из первой структуры метаданных в
буфере.
.TP 
\fBFAN_EVENT_NEXT(meta, len)\fP
Этот макрос использует длину из поля \fIevent_len\fP структуры метаданных, на
которую указывает \fImeta\fP, для вычисления адреса следующей структуры
метаданных, которая находится после \fImeta\fP. В поле \fIlen\fP указано
количество байт метаданных, оставшихся в буфере. Макрос возвращает указатель
на следующую структуру метаданных после \fImeta\fP и уменьшает \fIlen\fP на
количество байт в структуре метаданных, которая была пропущена (т. е.,
вычитает \fImeta\->event_len\fP из \fIlen\fP).
.PP
Дополнительно есть:
.TP 
\fBFAN_EVENT_METADATA_LEN\fP
.\"
Этот макрос возвращает размер (в байтах) структуры
\fIfanotify_event_metadata\fP. Это минимальный размер (и, в настоящее время,
единственный) метаданных любого события.
.SS "Отслеживание событий через файловый дескриптор fanotify"
Когда возникает событие fanotify файловый дескриптор fanotify помечается как
доступный для чтения при его передаче в \fBepoll\fP(7), \fBpoll\fP(2) или
\fBselect\fP(2).
.SS "Работа с событиями доступа"
Для событий доступа приложение должно записать (\fBwrite\fP(2)) в файловый
дескриптор fanotify следующую структуру:
.PP
.in +4n
.EX
struct fanotify_response {
    __s32 fd;
    __u32 response;
};
.EE
.in
.PP
Поля этой структуры имеют следующее назначение:
.TP 
\fIfd\fP
Файловый дескриптор из структуры \fIfanotify_event_metadata\fP.
.TP 
\fIresponse\fP
В этом поле указывает о разрешении доступа или запрещении. Данное значение
должно быть равно \fBFAN_ALLOW\fP, чтобы разрешить операцию с файлом, или
\fBFAN_DENY\fP для запрета.
.PP
Если доступ запрещается, то запрашивающее приложение получит ошибку
\fBEPERM\fP.
.SS "Закрытие файлового дескриптора fanotify"
.PP
Когда все файловые дескрипторы, указывающие на группу уведомления fanotify,
закрыты, группа fanotify освобождается и её ресурсы становятся доступны ядру
для повторного использования. После \fBclose\fP(2) все оставшиеся
непросмотренные события доступа будут разрешены.
.SS /proc/[pid]/fdinfo
Файл \fI/proc/[pid]/fdinfo/[fd]\fP содержит информацию о метках fanotify для
файлового дескриптора \fIfd\fP процесса \fIpid\fP Подробности смотрите в
\fBproc\fP(5).
.SH ОШИБКИ
Кроме обычных ошибок \fBread\fP(2) при чтении из файлового дескриптора fanotify
могут возникать следующие ошибки:
.TP 
\fBEINVAL\fP
Буфер слишком мал для хранения события.
.TP 
\fBEMFILE\fP
Достигнуто максимальное попроцессное количество открытых файлов. Смотрите
описание \fBRLIMIT_NOFILE\fP в \fBgetrlimit\fP(2).
.TP 
\fBENFILE\fP
Достигнут предел на общее количество открытых файлов в системе. Смотрите
\fI/proc/sys/fs/file\-max\fP в \fBproc\fP(5).
.TP 
\fBETXTBSY\fP
Эта ошибка возвращается \fBread\fP(2), если при вызове \fBfanotify_init\fP(2) в
аргументе \fIevent_f_flags\fP был указан \fBO_RDWR\fP или \fBO_WRONLY\fP и произошло
событие с отслеживаемым файлом, который в данный момент выполняется.
.PP
Кроме обычных ошибок \fBwrite\fP(2) при записи в файловый дескриптор fanotify
могут возникать следующие ошибки:
.TP 
\fBEINVAL\fP
Свойство для проверки прав доступа fanotify не включено в настройках ядра
или некорректное значение \fIresponse\fP в структуре ответа.
.TP 
\fBENOENT\fP
Некорректный файловый дескриптор \fIfd\fP в структуре ответа. Это может
происходить, когда ответ на право доступа уже был записан.
.SH ВЕРСИИ
Программный интерфейс fanotify представлен в версии 2.6.36 ядра Linux и
включён в версии 2.6.37. Поддержка fdinfo была добавлена в версии 3.8.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
Программный интерфейс fanotify есть только в Linux.
.SH ЗАМЕЧАНИЯ
Программный интерфейс fanotify доступен только, если ядро собрано с
включённым параметром настройки \fBCONFIG_FANOTIFY\fP. Также, работа с доступом
в fanotify доступна только, если включён параметр настройки
\fBCONFIG_FANOTIFY_ACCESS_PERMISSIONS\fP.
.SS "Ограничения и подводные камни"
Fanotify сообщает только о событиях, которые возникли при использовании
пользовательскими программами программного интерфейса файловой
системы. Поэтому события об обращении к файлам в сетевых файловых системах
не отлавливаются.
.PP
Программный интерфейс fanotify не сообщает о доступе и изменениях, которые
могут произойти из\-за \fBmmap\fP(2), \fBmsync\fP(2) и \fBmunmap\fP(2).
.PP
События для каталогов создаются только, если сам каталог открывается,
читается и закрывается. Добавление, удаление и изменение потомков
отслеживаемого каталога не приводит к возникновению событий.
.PP
Fanotify не следит за каталогами рекурсивно: чтобы следить за подкаталогами
каталога, нужно их явно пометить (и, заметим, что программный интерфейс
fanotify не позволяет отслеживать создание подкаталога, что затрудняет
рекурсивное слежение). Отслеживание точек монтирования позволяет следить за
всем деревом каталогов. Отслеживание файловых систем позволяет следить за
изменениями, сделанными в любом смонтированном экземпляре файловой системы.
.PP
Очередь событий может переполниться. В этом случае события теряются.
.SH ДЕФЕКТЫ
.\" commit 820c12d5d6c0890bc93dd63893924a13041fdc35
До Linux 3.19, \fBfallocate\fP(2) не генерировал событий fanotify. Начиная с
Linux 3.19, вызовы \fBfallocate\fP(2)  генерируют событие \fBFAN_MODIFY\fP.
.PP
В Linux 3.17 существуют следующие дефекты:
.IP * 3
В Linux объект файловой системы может быть доступен через несколько путей,
например, часть файловой системы может быть перемонтирована \fBmount\fP(8) с
использованием параметра \fI\-\-bind\fP. Ожидающий слушатель получит уведомления
об объекте файловой системы только из запрошенной точки монтирования. О
событиях из других точек уведомлений не поступит.
.IP *
.\" FIXME . A patch was proposed.
При генерации события не делается проверка, что пользовательскому ID
получающего процесса разрешено читать или писать в файл перед передачей
файлового дескриптора на этот файл. Это представляет некоторый риск
безопасности, когда у программ, выполняющихся непривилегированными
пользователями, есть мандат \fBCAP_SYS_ADMIN\fP.
.IP *
Если вызов \fBread\fP(2) получает несколько событий из очереди fanotify и
возникает ошибка, будет возвращена полная длина событий, которые были
успешно скопированы в буфер пользовательского пространства до
ошибки. Возвращаемое значение не будет равно \-1, и в \fIerrno\fP не
записывается код ошибки. То есть читающее приложение не может обнаружить
ошибку.
.SH ПРИМЕР
Далее показано два примера программы, в которых
продемонстрированоиспользование программного интерфейса fanotify.
.SS "Программа\-пример: fanotify_example.c"
В первой программе показано как использовать fanotify с информацией об
событийном объекте, передаваемом в виде файлового дескриптора. Программа
помечает точку монтирования, переданную в аргументе командной строки, и ждёт
событий с типом \fBFAN_OPEN_PERM\fP и \fBFAN_CLOSE_WRITE\fP. При возникновении
событий доступа выдаёт ответ \fBFAN_ALLOW\fP.
.PP
В сеансе оболочки далее показан пример запуска программы. В сеансе
выполняется редактирование файла \fI/home/user/temp/notes\fP. Перед открытием
файла возникает событие \fBFAN_OPEN_PERM\fP. После закрытия файла возникает
событие \fBFAN_CLOSE_WRITE\fP. Выполнение программы заканчивается после нажатия
пользователем клавиши ENTER.
.PP
.in +4n
.EX
# \fB./fanotify_example /home\fP
Нажмите enter для завершения работы.
Ожидание событий.
FAN_OPEN_PERM: Файл /home/user/temp/notes
FAN_CLOSE_WRITE: Файл /home/user/temp/notes

Ожидание событий прекращено.
.EE
.in
.EE
.in
.SS "Исходный код программы: fanotify_example.c"
\&
.EX
#define _GNU_SOURCE     /* для получения определения O_LARGEFILE */
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <poll.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/fanotify.h>
#include <unistd.h>

/* читаем все доступные события fanotify из файлового дескриптора «fd» */

static void
handle_events(int fd)
{
    const struct fanotify_event_metadata *metadata;
    struct fanotify_event_metadata buf[200];
    ssize_t len;
    char path[PATH_MAX];
    ssize_t path_len;
    char procfd_path[PATH_MAX];
    struct fanotify_response response;

    /* проходим по всем событиям, которые можем прочитать
       из файлового дескриптора fanotify */

    for (;;) {

        /* читаем несколько событий */

        len = read(fd, (void *) &buf, sizeof(buf));
        if (len == \-1 && errno != EAGAIN) {
            perror("read");
            exit(EXIT_FAILURE);
        }

        /* проверяем, достигнут ли конец доступных данных */

        if (len <= 0)
            break;

        /* выбираем первое событие в буфере */

        metadata = buf;

        /* проходим по всем событиям в буфере */

        while (FAN_EVENT_OK(metadata, len)) {

            /* проверяем, что структуры, использовавшиеся при сборке,
               идентичны структурам при выполнении */

            if (metadata\->vers != FANOTIFY_METADATA_VERSION) {
                fprintf(stderr,
                        "Версия метаданных fanotify не совпадает.\en");
                exit(EXIT_FAILURE);
            }

            /* metadata\->fd содержит или FAN_NOFD, указывающее
               на переполнение очереди, или файловый дескриптор
               (неотрицательное целое). Здесь мы просто игнорируем
               переполнение очереди. */

            if (metadata\->fd >= 0) {

                /* обрабатываем событие на право открытия */

                if (metadata\->mask & FAN_OPEN_PERM) {
                    printf("FAN_OPEN_PERM: ");

                    /* разрешаем открыть файл */

                    response.fd = metadata\->fd;
                    response.response = FAN_ALLOW;
                    write(fd, &response,
                          sizeof(struct fanotify_response));
                }

                /* обрабатываем событие закрытия записываемого файла */

                if (metadata\->mask & FAN_CLOSE_WRITE)
                    printf("FAN_CLOSE_WRITE: ");

                /* получаем и выводим имя файла, к которому
                   отслеживается доступ */

                snprintf(procfd_path, sizeof(procfd_path),
                         "/proc/self/fd/%d", metadata\->fd);
                path_len = readlink(procfd_path, path,
                                    sizeof(path) \- 1);
                if (path_len == \-1) {
                    perror("readlink");
                    exit(EXIT_FAILURE);
                }

                path[path_len] = \(aq\e0\(aq;
                printf("Файл %s\en", path);

                /* закрываем файловый дескриптор из события */

                close(metadata\->fd);
            }

            /* переходим на следующее событие */

            metadata = FAN_EVENT_NEXT(metadata, len);
        }
    }
}

int
main(int argc, char *argv[])
{
    char buf;
    int fd, poll_num;
    nfds_t nfds;
    struct pollfd fds[2];

    /* проверяем заданную точку монтирования */

    if (argc != 2) {
        fprintf(stderr, "Использование: %s ТОЧКА_МОНТИРОВАНИЯ\en",
                                        argv[0]);
        exit(EXIT_FAILURE);
    }

    printf("Нажмите enter для завершения работы.\en");

    /* Создаём файловый дескриптор для доступа к fanotify API */

    fd = fanotify_init(FAN_CLOEXEC | FAN_CLASS_CONTENT | FAN_NONBLOCK,
                       O_RDONLY | O_LARGEFILE);
    if (fd == \-1) {
        perror("fanotify_init");
        exit(EXIT_FAILURE);
    }

    /* Помечаем точку монтирования для:
       \- событий доступа перед открытием файлов
       \- событий уведомления после закрытия файлового дескриптора
         для файла открытого для записи */

    if (fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_MOUNT,
                      FAN_OPEN_PERM | FAN_CLOSE_WRITE, AT_FDCWD,
                      argv[1]) == \-1) {
        perror("fanotify_mark");
        exit(EXIT_FAILURE);
    }

    /* подготовка к опросу */

    nfds = 2;

    /* ввод с консоли  */

    fds[0].fd = STDIN_FILENO;
    fds[0].events = POLLIN;

    /* ввод из fanotify */

    fds[1].fd = fd;
    fds[1].events = POLLIN;

    /* цикл ожидания входящих событий */

    printf("Ожидание событий.\en");

    while (1) {
        poll_num = poll(fds, nfds, \-1);
        if (poll_num == \-1) {
            if (errno == EINTR)     /* прервано сигналом */
                continue;           /* перезапуск poll() */

            perror("poll");         /* неожиданная ошибка */
            exit(EXIT_FAILURE);
        }

        if (poll_num > 0) {
            if (fds[0].revents & POLLIN) {

                /* доступен ввод с консоли: опустошаем stdin и выходим */

                while (read(STDIN_FILENO, &buf, 1) > 0 && buf != \(aq\en\(aq)
                    continue;
                break;
            }

            if (fds[1].revents & POLLIN) {

                /* доступны события fanotify */

                handle_events(fd);
            }
        }
    }

    printf("Ожидание событий прекращено.\en");
    exit(EXIT_SUCCESS);
}
.EE
.\"
.SS "Программа\-пример: fanotify_fid.c"
Во второй программе показано как использовать fanotify с включённым
\fBFAN_REPORT_FID\fP. Программа помечает объект файловой системы, переданный в
аргументе командной строки, и ждёт возникновения события с типом
\fBFAN_CREATE\fP. В маске событий задаётся какой тип объекта файловой системы
ждать — файл или каталог. После того как все события из буфера будут
прочитаны и правильно обработаны программа просто завершает работу.
.PP
В следующих сеансах показано два разных запуска программы с разными
выполняемыми действиями над наблюдаемым объектом.
.PP
В первом сеансе ставится отметка на \fI/home/user\fP. После этого создаётся
обычный файл \fI/home/user/testfile.txt\fP. В результате возникает событие
\fBFAN_CREATE\fP, в котором передаётсяобъект отслеживаемого родительского
каталога файла. Программа завершает выполнение после обработки всех
захваченных и помещённых в буфер событий.
.PP
.in +4n
.EX
# \fB./fanotify_fid /home/user\fP
Ожидание событий.
FAN_CREATE (создан файл): Каталог /home/user изменён.
Все события успешно обработаны. Завершение программы.

$ \fBtouch /home/user/testing\fP              # в другом терминале
.EE
.in
.PP
Во втором сеансе ставится отметка на \fI/home/user\fP. После этого создаётся
каталог \fI/home/user/testdir\fP. В результате такого специального действия в
программу передаются события \fBFAN_CREATE\fP и \fBFAN_ONDIR\fP.
.PP
.in +4n
.EX
# \fB./fanotify_fid /home/user\fP
Ожидание событий.
FAN_CREATE | FAN_ONDIR (создан подкаталог):
        Каталог /home/user изменён.
Все события успешно обработаны. Завершение программы.

$ \fBmkdir \-p /home/user/testing\fP          # в другом терминале
.EE
.in
.SS "Исходный код программы: fanotify_fid.c"
\&
.EX
#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/fanotify.h>
#include <unistd.h>

#define BUF_SIZE 256

int
main(int argc, char **argv)
{
    int fd, ret, event_fd;
    ssize_t len, path_len;
    char path[PATH_MAX];
    char procfd_path[PATH_MAX];
    char events_buf[BUF_SIZE];
    struct file_handle *file_handle;
    struct fanotify_event_metadata *metadata;
    struct fanotify_event_info_fid *fid;

    if (argc != 2) {
        fprintf(stderr, "Некорректное количество аргументов в командной строке.\en");
        exit(EXIT_FAILURE);
    }

    /* создаём файловый дескриптор fanotify с флагом FAN_REPORT_FID для
       того, чтобы программа могла принимать события fid. */

    fd = fanotify_init(FAN_CLASS_NOTIF | FAN_REPORT_FID, 0);
    if (fd == \-1) {
        perror("fanotify_init");
        exit(EXIT_FAILURE);
    }

    /* ставим метку на объект файловой системы, заданный в argv[1]. */

    ret = fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_ONLYDIR,
                        FAN_CREATE | FAN_ONDIR,
                        AT_FDCWD, argv[1]);
    if (ret == \-1) {
        perror("fanotify_mark");
        exit(EXIT_FAILURE);
    }

    printf("Ожидание событий.\en");

    /* читаем события из очереди событий в буфер */

    len = read(fd, (void *) &events_buf, sizeof(events_buf));
    if (len == \-1 && errno != EAGAIN) {
        perror("read");
        exit(EXIT_FAILURE);
    }

    /* обрабатываем все события в буфере */

    for (metadata = (struct fanotify_event_metadata *) events_buf;
            FAN_EVENT_OK(metadata, len);
            metadata = FAN_EVENT_NEXT(metadata, len)) {
        fid = (struct fanotify_event_info_fid *) (metadata + 1);
        file_handle = (struct file_handle *) fid\->handle;

        /* проверим, что информация о событии правильного типа */

        if (fid\->hdr.info_type != FAN_EVENT_INFO_TYPE_FID) {
            fprintf(stderr, "Получена информация о событии неожидаемого типа.\en");
            exit(EXIT_FAILURE);
        }

        if (metadata\->mask == FAN_CREATE)
            printf("FAN_CREATE (создан файл):");

        if (metadata\->mask == FAN_CREATE | FAN_ONDIR)
            printf("FAN_CREATE | FAN_ONDIR (создан подкаталог):");

        /* metadata\->fd присваивается FAN_NOFD, если включён
           FAN_REPORT_FID. Чтобы получить файловый дескриптор для
           файлового объекта, соответствующего событию, можно
           использовать struct file_handle, которая находится
           внутри fanotify_event_info_fid и системный вызов
           open_by_handle_at(2). Проверка на ESTALE нужна, чтобы
           учесть ситуацию, когда файловый описатель для объекта
           был удалён до этого системного вызова. */

        event_fd = open_by_handle_at(AT_FDCWD, file_handle, O_RDONLY);
        if (ret == \-1) {
            if (errno == ESTALE) {
                printf("Обработчик файл более недействителен. "
                        "Файл был удалён\en");
                continue;
            } else {
                perror("open_by_handle_at");
                exit(EXIT_FAILURE);
	    }
        }

        snprintf(procfd_path, sizeof(procfd_path), "/proc/self/fd/%d",
                event_fd);

        /* получаем и выводим путь изменённой dentry */

        path_len = readlink(procfd_path, path, sizeof(path) \- 1);
        if (path_len == \-1) {
            perror("readlink");
            exit(EXIT_FAILURE);
        }

        path[path_len] = \(aq\e0\(aq;
        printf("\etКаталог \(aq%s\(aq изменён.\en", path);

        /* закрываем связанный файловый дескриптор этого события */

        close(event_fd);
    }

    printf("Все события успешно обработаны. Завершение программы.\en");
    exit(EXIT_SUCCESS);
}
.EE
.SH "СМОТРИТЕ ТАКЖЕ"
.ad l
\fBfanotify_init\fP(2), \fBfanotify_mark\fP(2), \fBinotify\fP(7)
