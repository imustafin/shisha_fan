.\" -*- mode: troff; coding: UTF-8 -*-
.\"  Copyright (C) 2003  Davide Libenzi
.\"
.\" %%%LICENSE_START(GPLv2+_SW_3_PARA)
.\"  This program is free software; you can redistribute it and/or modify
.\"  it under the terms of the GNU General Public License as published by
.\"  the Free Software Foundation; either version 2 of the License, or
.\"  (at your option) any later version.
.\"
.\"  This program is distributed in the hope that it will be useful,
.\"  but WITHOUT ANY WARRANTY; without even the implied warranty of
.\"  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\"  GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, see
.\" <http://www.gnu.org/licenses/>.
.\" %%%LICENSE_END
.\"
.\"  Davide Libenzi <davidel@xmailserver.org>
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH EPOLL 7 2019\-03\-06 Linux "Руководство программиста Linux"
.SH ИМЯ
epoll \- средство уведомления о событии ввода\-вывода
.SH ОБЗОР
\fB#include <sys/epoll.h>\fP
.SH ОПИСАНИЕ
Программный интерфейс \fBepoll\fP выполняется схожую с \fBpoll\fP(2) задачу:
следит за несколькими файловыми дескрипторами и ждёт, когда станет возможен
ввод\-вывод для одного из них. Программный интерфейс \fBepoll\fP можно
использовать либо в режиме edge\-triggered, либо в level\-triggered и
применять для слежения за достаточно большим количеством файловых
дескрипторов.
.PP
Центральным элементом программного интерфейса \fBepoll\fP является \fIэкземпляр\fP
\fBepoll\fP — структура данных ядра, которая с точки зрения пользовательского
пространства может рассматриваться как контейнер с двумя списками:
.IP * 4
Список \fIinterest\fP (иногда также называемый набором \fBepoll\fP): набор
файловых дескрипторов, которые зарегистрировал процесс для слежения.
.IP *
Список \fIready\fP: набор файловых дескрипторов, которые «готовы» для
проведения операций ввода\-вывода. Список ready — это часть набора (точнее,
набор ссылок) файловых дескрипторов из списка interest, он динамически
заполняется ядром в результате действий ввода\-вывода с этими файловыми
дескрипторами.
.PP
Для создания и управления экземпляром \fBepoll\fP служат следующие системные
вызовы:
.IP * 3
Вызов \fBepoll_create\fP(2) создаёт экземпляр новый \fBepoll\fP и возвращает
файловый дескриптор, указывающий на этот экземпляр (более новый
\fBepoll_create1\fP(2) расширяет возможности \fBepoll_create\fP(2)).
.IP *
Затем с помощью \fBepoll_ctl\fP(2) регистрируются интересующие файловые
дескрипторы, который добавляет их в список interest экземпляра \fIepoll\fP.
.IP *
.\"
Вызов \fBepoll_wait\fP(2) ждёт наступления событий ввода\-вывода, блокируя
вызывающую нить, если события пока недоступны (данный системный вызов можно
рассматривать как выборщике элементов из списка готовности экземпляра
\fBepoll\fP).
.SS "Режимы level\-triggered и edge\-triggered"
Существует два режима выдачи событий \fBepoll\fP: edge\-triggered (ET) и
level\-triggered (LT). Разницу между ними можно описать так. Предположим, что
реализован следующий сценарий событий:
.IP 1. 3
Файловый дескриптор, представляющий читающую сторону канала (\fIrfd\fP),
регистрируется в экземпляре \fBepoll\fP.
.IP 2.
Пишущая сторона канала записывает 2\ КБ данных на записываемой стороне
канала.
.IP 3.
Вызов \fBepoll_wait\fP(2) завершается и возвращает \fIrfd\fP как готовый файловый
дескриптор.
.IP 4.
Читающая сторона канала считывает 1\ КБ данных из \fIrfd\fP.
.IP 5.
Вызов \fBepoll_wait\fP(2) завершается.
.PP
Если файловый дескриптор \fIrfd\fP добавлен к экземпляру \fBepoll\fP с указанным
флагом \fBEPOLLET\fP (edge\-triggered), то вызов \fBepoll_wait\fP(2) на шаге 5,
вероятно, повиснет, несмотря на имеющие данные в буфере ввода; в это же
время удалённая сторона может ожидать подтверждения приёма уже отправленных
данных. Причиной этого является то, что в режиме edge\-triggered события
доставляются только когда происходит изменение состояния отслеживаемого
файлового дескриптора.\ Поэтому в шаге \fB5\fP вызывающий может бесконечно ждать
появления данных, хотя они уже есть в буфере ввода. В приведённом выше
примере событие для \fIrfd\fP будет сгенерировано из\-за операции записи,
сделанной в шаге \fB2\fP, и это событие будет обработано в шаге \fB3\fP. Так как
операция в шаге \fB4\fP, не прочитала все данные из буфера, вызов
\fBepoll_wait\fP(2) в шаге \fB5\fP может заблокироваться навсегда.
.PP
Приложение, которое применяет флаг \fBEPOLLET\fP, должно использовать
неблокирующие файловые дескрипторы, чтобы избежать приостановки задания,
обрабатывающего множество файловых дескрипторов, из\-за блокировок чтения или
записи. Предлагаемый способ использования \fBepoll\fP с интерфейсом Edge
Triggered (\fBEPOLLET\fP):
.RS
.TP  4
\fBi\fP
неблокирующие файловые дескрипторы; и
.TP 
\fBii\fP
ожидание события только после того, как \fBread\fP(2) или \fBwrite\fP(2) возвратят
\fBEAGAIN\fP.
.RE
.PP
Напротив, при использовании интерфейса level\-triggered (по умолчанию, если
не указан \fBEPOLLET\fP) \fBepoll\fP проще и быстрее \fBpoll\fP(2), и может быть
использован везде, где используется последний, так как имеет ту же
семантику.
.PP
Так как даже с edge\-triggered \fBepoll\fP при получении нескольких порций
данных могут генерироваться множественные события, вызывающий может задать
флаг \fBEPOLLONESHOT\fP, который указывает \fBepoll\fP отключить связанный
файловый дескриптор после приёма события с помощью \fBepoll_wait\fP(2). Если
указан флаг \fBEPOLLONESHOT\fP, то вызывающий должен переустановить файловый
дескриптор с помощью \fBepoll_ctl\fP(2) с флагом \fBEPOLL_CTL_MOD\fP.
.PP
.\"
Если несколько нитей (или процессов, если дочерние процессы унаследовали
файловый дескриптор \fBepoll\fP при \fBfork\fP(2)) блокируются в ожидании
\fBepoll_wait\fP(2) одного и того же файлового дескриптора и файловый
дескриптор в списке interest, помеченный для уведомления edge\-triggered
(\fBEPOLLET\fP), становится готовым, то только одна из нитей (или процессов)
пробуждается из \fBepoll_wait\fP(2). Такая полезная оптимизация в некоторых
случаях помогает избежать «лавины» пробуждений.
.SS "Взаимодействие с autosleep"
Если система в режиме \fBautosleep\fP посредством \fI/sys/power/autosleep\fP и
происходит событие, которое пробуждает устройство, то драйвер устройства
держит устройство проснувшимся только, пока событие ставится в
очередь. Чтобы устройство не заснуло пока не обработает событие, необходимо
использовать флаг \fBepoll_ctl\fP(2) \fBEPOLLWAKEUP\fP.
.PP
Флаг \fBEPOLLWAKEUP\fP задаётся в поле \fBevents\fP для \fIstruct epoll_event\fP;
система будет оставаться разбуженной с момента когда событие поступает в
очередь, пока не закончится работа вызова \fBepoll_wait\fP(2), возвращающий
событие, и до последующего вызова \fBepoll_wait\fP(2). Если событие должно
держать систему разбуженной дольше, то нужно применить отдельный
\fIwake_lock\fP перед вторым вызовом \fBepoll_wait\fP(2).
.SS "Интерфейсы /proc"
.\" Following was added in 2.6.28, but them removed in 2.6.29
.\" .TP
.\" .IR /proc/sys/fs/epoll/max_user_instances " (since Linux 2.6.28)"
.\" This specifies an upper limit on the number of epoll instances
.\" that can be created per real user ID.
Для ограничения потребления epoll памяти ядра, можно использовать следующие
интерфейсы:
.TP 
\fI/proc/sys/fs/epoll/max_user_watches\fP (начиная с Linux 2.6.28)
.\" 2.6.29 (in 2.6.28, the default was 1/32 of lowmem)
Задаёт ограничение на общее количество файловых дескрипторов, которые
пользователь может зарегистрировать во всех экземплярах epoll в
системе. Ограничение привязывается к реальному идентификатору
пользователя. Каждый зарезервированный файловый дескриптор занимает,
приблизительно, 90 байт в 32\-битном ядре, и, приблизительно, 160 байт в
64\-битном ядре. В настоящее время, значение по умолчанию для
\fImax_user_watches\fP равно 1/25 (4%) доступной памяти ядра (low memory),
поделённое на значение размера дескриптора в байтах.
.SS "Примеры использования"
При применении \fBepoll\fP с интерфейсом level\-triggered он имеет ту же
семантику что и \fBpoll\fP(2), а при edge\-triggered требует больших проверок
для избежания зависаний приложения в событийном цикле. В этом примере,
слушающим является неблокирующий сокет, для которого был вызван
\fBlisten\fP(2). Функция \fIdo_use_fd\fP() использует новый готовый файловый
дескриптор до тех пор, пока не возвратится \fBEAGAIN\fP от \fBread\fP(2) или
\fBwrite\fP(2). Приложение на основе машины состояний должно после получения
\fBEAGAIN\fP записать своё текущее состояние так, чтобы последующий вызов
\fIdo_use_fd\fP() продолжил выполнять \fBread\fP(2) или \fBwrite\fP(2) с места
остановки.
.PP
.in +4n
.EX
#define MAX_EVENTS 10
struct epoll_event ev, events[MAX_EVENTS];
int listen_sock, conn_sock, nfds, epollfd;

/* Код для настройки слушающего сокета, \(aqlisten_sock\(aq,
   (socket(), bind(), listen()) не показаны */

epollfd = epoll_create1(0);
if (epollfd == \-1) {
    perror("epoll_create1");
    exit(EXIT_FAILURE);
}

ev.events = EPOLLIN;
ev.data.fd = listen_sock;
if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &ev) == \-1) {
    perror("epoll_ctl: listen_sock");
    exit(EXIT_FAILURE);
}

for (;;) {
    nfds = epoll_wait(epollfd, events, MAX_EVENTS, \-1);
    if (nfds == \-1) {
        perror("epoll_wait");
        exit(EXIT_FAILURE);
    }

    for (n = 0; n < nfds; ++n) {
        if (events[n].data.fd == listen_sock) {
            conn_sock = accept(listen_sock,
                               (struct sockaddr *) &addr, &addrlen);
            if (conn_sock == \-1) {
                perror("accept");
                exit(EXIT_FAILURE);
            }
            setnonblocking(conn_sock);
            ev.events = EPOLLIN | EPOLLET;
            ev.data.fd = conn_sock;
            if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,
                        &ev) == \-1) {
                perror("epoll_ctl: conn_sock");
                exit(EXIT_FAILURE);
            }
        } else {
            do_use_fd(events[n].data.fd);
        }
    }
}
.EE
.in
.PP
При использовании интерфейса edge\-triggered для большей производительности
можно однократно добавить файловый дескриптор внутрь интерфейса \fBepoll\fP
(\fBEPOLL_CTL_ADD\fP), указав (\fBEPOLLIN\fP|\fBEPOLLOUT\fP). Это позволит вам
избежать постоянного переключения между \fBEPOLLIN\fP и \fBEPOLLOUT\fP,
вызывающими \fBepoll_ctl\fP(2) c \fBEPOLL_CTL_MOD\fP.
.SS "Вопросы и ответы"
.IP 0. 4
По какому ключу различать зарегистрированные файловые дескрипторы в списке
interest?
.IP
Уникальной комбинацией является номер файлового дескриптора и описание
открытого файла (так называемый «описатель открытого файла» — внутреннее
представление открытого файла в ядре).
.IP 1.
Что случится, если зарегистрировать один файловый дескриптор в экземпляре
\fBepoll\fP дважды?
.IP
.\" But a file descriptor duplicated by fork(2) can't be added to the
.\" set, because the [file *, fd] pair is already in the epoll set.
.\" That is a somewhat ugly inconsistency.  On the one hand, a child process
.\" cannot add the duplicate file descriptor to the epoll set.  (In every
.\" other case that I can think of, file descriptors duplicated by fork have
.\" similar semantics to file descriptors duplicated by dup() and friends.)  On
.\" the other hand, the very fact that the child has a duplicate of the
.\" file descriptor means that even if the parent closes its file descriptor,
.\" then epoll_wait() in the parent will continue to receive notifications for
.\" that file descriptor because of the duplicated file descriptor in the child.
.\"
.\" See http://thread.gmane.org/gmane.linux.kernel/596462/
.\" "epoll design problems with common fork/exec patterns"
.\"
.\" mtk, Feb 2008
Вероятно, вы получите \fBEEXIST\fP. Однако возможно добавить дубликат файлового
дескриптора (\fBdup\fP(2), \fBdup2\fP(2), \fBfcntl\fP(2)  \fBF_DUPFD\fP) в тот же
экземпляр \fBepoll\fP. Это может быть полезно для фильтрующих событий, если
дубликаты файловых дескрипторов регистрируются с разными масками \fIevents\fP.
.IP 2.
Могут ли два экземпляра \fBepoll\fP ожидать один файловый дескриптор? Если да,
то сообщаются ли события в оба файловых дескриптора \fBepoll\fP?
.IP
Да, и события будут доходить в оба. Однако, чтобы сделать это правильно,
нужна внимательность к деталям.
.IP 3.
Могут ли операции poll/epoll/select применяться к самому файловому
дескриптору \fBepoll\fP?
.IP
Да. Если файловый дескриптор \fBepoll\fP имеет ожидающие события, то он будет
помечен как доступный для чтения.
.IP 4.
Что случится, если попытаться поместить файловый дескриптор \fBepoll\fP в свой
собственный набор файловых дескрипторов?
.IP
Вызов \fBepoll_ctl\fP(2) завершается ошибкой (\fBEINVAL\fP). Однако вы можете
добавить файловый дескриптор \fBepoll\fP внутрь другого набора файлового
дескриптора \fBepoll\fP.
.IP 5.
Можно ли отправить файловый дескриптор \fBepoll\fP через доменный сокет UNIX
другому процессу?
.IP
Да, но это не имеет смысла, так как принимающий процесс не имеет копий
файловых дескрипторов в списке interest.
.IP 6.
Приводит ли закрытие файлового дескриптора к его удалению из всех списков
interest \fBepoll\fP?
.IP
Да, но учтите следующий момент. Файловый дескриптор является ссылкой на
открытое файловое описание (смотрите \fBopen\fP(2)). При создании дубля
файлового дескриптора с помощью \fBdup\fP(2), \fBdup2\fP(2), \fBfcntl\fP(2)
\fBF_DUPFD\fP или \fBfork\fP(2) созданный новый файловый дескриптор указывает на
то же открытое файловое описание. Открытое файловое описание продолжает
существовать до тех пор, пока все указывающие на него файловые дескрипторы
не будут закрыты.
.IP
Файловый дескриптор удаляется из списка interest только после того, как
будут закрыты все файловые дескрипторы, ссылающиеся на открытое файловое
описание. Это означает, что даже после закрытия файлового дескриптора,
являющегося частью списка interest, могут поступать события от файлового
дескриптора, если остались открытыми другие файловые дескрипторы,
ссылающиеся на тоже файловое описание. Чтобы такого не случалось, файловый
дескриптор должен быть удалён из списка interest явным образом (с помощью
\fBepoll_ctl\fP(2) \fBEPOLL_CTL_DEL\fP) до создания его дубликата. Или же
приложение может проверить,что закрыты все файловые дескрипторы (что может
быть трудно, если дубли файлового дескриптора неявно создавались где\-то в
библиотечных функциях с помощью \fBdup\fP(2) или \fBfork\fP(2)).
.IP 7.
Если между вызовами \fBepoll_wait\fP(2) придёт более одного события, то они
будут объединены или о них будет сообщено по отдельности?
.IP
Они будут объединены.
.IP 8.
Влияет ли операция над файловым дескриптором на уже собранные, но пока ещё
не сообщенные события?
.IP
Вы можете выполнить две операции на существующем файловом
дескрипторе. Удаление в этом случае бессмысленно. Изменение приведёт к
повторному чтению доступного ввода/вывода.
.IP 9.
Должен ли я читать/записывать файловый дескриптор до пор пока, не получу
\fBEAGAIN\fP при использовании флага \fBEPOLLET\fP (поведение edge\-triggered)?
.IP
Получение события от \fBepoll_wait\fP(2) должно сообщить вам, что файловый
дескриптор готов для запрошенной операции ввода/вывода. Вы должны
предполагать, что он готов до тех пор, пока вы не получите следующий
\fBEAGAIN\fP от (неблокирующего) чтения/записи. Когда и как вы будете
использовать файловый дескриптор — полностью зависит от вас.
.IP
Для пакетных/метко ориентированных файлов (например, датаграмных сокетов,
терминал в каноническом режиме) единственным способом обнаружить конец
чтения/записи пространства ввода\-вывода — это продолжать чтение/записи до
получения \fBEAGAIN\fP.
.IP
Для потокоориентированных файлов (например, каналы, FIFO, потоковые сокеты)
условие, при которых чтение/запись пространства ввода/вывода закончилось,
может быть определено проверкой количества считанных/записанных данных из/в
целевого файлового дескриптора. Например, если вы вызвали \fBread\fP(2) для
чтения определённого количества данных и \fBread\fP(2) вернул меньшее
количество байтов, то можно быть уверенным, что пространство чтения
ввода/вывода этого файлового дескриптора закончилось. То же самое
справедливо для записи посредством \fBwrite\fP(2) (не используйте последнее,
если вы не можете гарантировать, что отслеживаемый файловый дескриптор
всегда ссылается на потокоориентированный файл).
.SS "Возможные ловушки и способы их обхода"
.TP 
\fBo Информационный голод (edge\-triggered)\fP
.PP
Если существует большое пространство ввода/вывода, то возможно, что пока вы
его читаете, другие файлы не будут обрабатываться и возникнет недостаток
данных (этого, обычно, не происходит с \fBepoll\fP).
.PP
Решением будет поддержка списка готовности и маркировка файлового
дескриптора как готового в связанной с ним структуре данных, тем самым
позволяя приложению запоминать какие файлы требуют обработки, но всё ещё не
обработанных среди уже готовых файлов. Это также поддерживает игнорирование
последующих событий готовности файловых дескрипторов, получаемых вами.
.TP 
\fBo Если использовать кэш событий…\fP
.PP
Если вы используете кэш событий или храните все файловые дескрипторы,
возвращённые от \fBepoll_wait\fP(2), то убедитесь, что вы обеспечили способ его
динамического закрытия (например, вызванное обработкой предыдущего
события). Предположим, что вы получили 100 событий от \fBepoll_wait\fP(2), и
что в событии №47 некоторое условие определяет, что событие №13 должно быть
закрыто. Если вы удалите структуру и выполните \fBclose\fP(2) файлового
дескриптора для события №13, то кэш событий всё ещё может сообщать о том,
что есть ожидаемые события для этого файлового дескриптора, что приводит к
путнице.
.PP
Одним из решений будет вызов, во время обработки события №47,
\fBepoll_ctl\fP(\fBEPOLL_CTL_DEL\fP) для удаления файлового дескриптора 13 и вызов
\fBclose\fP(2), а затем маркировка связанной с ним структуры данных как
удалённой и связки его со списком очистки. Если при пакетной обработке
найдется другое событие для файлового дескриптора 13, то обнаружится, что
файловый дескриптор уже был удалён и конфликтов не будет.
.SH ВЕРСИИ
.\" Its interface should be finalized in Linux kernel 2.5.66.
Программный интерфейс \fBepoll\fP был добавлен в ядро Linux версии
2.5.44. Поддержка в glibc доступна с версии 2.3.2.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
Программный интерфейс \fBepoll\fP есть только в Linux. В некоторых других
системах есть подобные механизмы, например, в FreeBSD есть \fIkqueue\fP, а в
Solaris — \fI/dev/poll\fP.
.SH ЗАМЕЧАНИЯ
Набор файловых дескрипторов, которые отслеживаются через файловый дескриптор
epoll, можно найти в записи для файлового дескриптора epoll в каталоге
процесса \fI/proc/[pid]/fdinfo\fP. Подробности смотрите в \fBproc\fP(5).
.PP
Вызов The \fBkcmp\fP(2) с операцией \fBKCMP_EPOLL_TFD\fP можно использовать для
проверки, что файловый дескриптор присутствует в экземпляре epoll.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBepoll_create\fP(2), \fBepoll_create1\fP(2), \fBepoll_ctl\fP(2), \fBepoll_wait\fP(2),
\fBpoll\fP(2), \fBselect\fP(2)
