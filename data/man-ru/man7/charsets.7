.\" -*- mode: troff; coding: UTF-8 -*-
'\" t -*- coding: UTF-8 -*-
.\" Copyright (c) 1996 Eric S. Raymond <esr@thyrsus.com>
.\" and Copyright (c) Andries Brouwer <aeb@cwi.nl>
.\"
.\" %%%LICENSE_START(GPLv2+_DOC_ONEPARA)
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\" %%%LICENSE_END
.\"
.\" This is combined from many sources, including notes by aeb and
.\" research by esr.  Portions derive from a writeup by Roman Czyborra.
.\"
.\" Changes also by David Starner <dstarner98@aasaa.ofe.org>.
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH CHARSETS 7 2019\-03\-06 Linux "Руководство программиста Linux"
.SH ИМЯ
charsets \- стандарты наборов символов и интернационализация
.SH ОПИСАНИЕ
В этой справочной странице представлен обзор различных стандартов наборов
символов и их использование в Linux до повсеместного распространения
Юникода. Часть данной информации будет полезна людям, работающим в старых
системах или со старыми документами.
.PP
Обсуждаемые стандарты: ASCII, GB 2312, ISO 8859, JIS, KOI8\-R, KS и Юникод.
.PP
В основном, описываются наборы символов, реально используемые в локалях, и
опускается всё огромное количество наборов, существующих в других системах.
.SS ASCII
ASCII (American Standard Code For Information Interchange; американский
стандартный код для обмена информацией) — первоначальный 7\-битный набор
символов, разработанный для американского варианта английского языка. Также
известен как US\-ASCII. В настоящее время описан в стандарте ISO 646:1991 IRV
(International Reference Version).
.PP
Существуют различные варианты (из 7 бит) ASCII, в которых американский
символ доллара и знаки пунктуации заменяются на знаки валют различных стран
(Германия, Франция, Испания и другие). Все эти наборы устарели; в glibc не
поддерживаются локали, которые в действительности не содержат набор ASCII.
.PP
Юникод, при использовании UTF\-8, является совместимым с ASCII; простой
(plain) текст ASCII по\-прежнему отображается корректно в современных
системах, использующих UTF\-8.
.SS "ISO 8859"
ISO 8859 — это серия из 15\-и 8\-битных наборов символов, каждый из которых
имеет в своей нижней (7\-битной) половине коды ASCII, невидимые управляющие
символы в позициях от 128 до 159 и 96 графических символов фиксированной
ширины в позициях 160\(en255.
.PP
Из них самой важной является последовательность ISO 8859\-1 («Latin Alphabet
No .1» / Latin\-1). Она широко распространена, поддерживается различными
системами и постепенно заменяется Юникодом. Символы ISO 8859\-1 также
являются первыми 256 символами Юникода.
.PP
Поддержка в консоли других наборов символов 8859 осуществляется в Linux с
помощью пользовательских утилит (таких, как \fBsetfont\fP(8)), меняющих
привязки клавиатуры, таблицу графики EGA и передающих драйверу консоли
таблицу соответствий символов шрифтам.
.PP
Ниже приводится краткое описание каждого набора:
.TP 
8859\-1 (Latin\-1)
Latin\-1 охватывается большинство западноевропейских языков, таких, как:
албанский, баскский, датский, английский, фарезский, галисийский,
исландский, ирландский, итальянский, норвежский, португальский, испанский и
шведский. Отсутствие лигатуры Ĳ/ĳ голландского языка, œ французского языка и
старых „немецких“ кавычек считается приемлемым.
.TP 
8859\-2 (Latin\-2)
Latin\-2 охватывает множество славянских и центрально и восточно\-европейских
языков: боснийский, хорватский, чешский, немецкий, венгерский, польский,
словацкий и словенский. Замена румынского ș/ț на ş/ţ считается приемлемым.
.TP 
8859\-3 (Latin\-3)
Latin\-3 охватывает эсперанто, мальтийский и турецкий языки (но турецкий
сейчас охватывается 8859\-9).
.TP 
8859\-4 (Latin\-4)
Latin\-4 охватывает северо\-европейские языки: эстонский, латвийский и
литовский языки. Но сейчас они охватываются 8859\-10 и 8859\-13.
.TP 
8859\-5
Кириллические символы болгарского, белорусского, македонского, русского,
сербского и (почти полностью) украинского языков. Никогда широко не
использовался, смотрите ниже описание KOI8\-R/KOI8\-U.
.TP 
8859\-6
Был создан для арабского языка. Таблица начертаний (глифов) 8859\-6 — это
шрифт отдельных форм букв постоянной ширины; корректная программа
отображения должна объединить их, используя корректные начальные,
промежуточные и конечные формы.
.TP 
8859\-7
Был создан для современного греческого языка в 1987 году, обновлён в 2003
году.
.TP 
8859\-8
Поддерживает современный иврит без niqud (знаки пунктуации). Niqud и полный
библейский иврит не входят в этот набор.
.TP 
8859\-9 (Latin\-5)
Это вариант Latin\-1, в котором исландские буквы заменены турецкими.
.TP 
8859\-10 (Latin\-6)
Latin\-6 добавляет последние инуитские (гренландские) буквы и буквы сами
(Sami Lappish), отсутствующие в Latin\-4, для того, чтобы объединить шрифты
всех нордических языков.
.TP 
8859\-11
Поддерживает тайский алфавит и очень похож на стандарт TIS\-620.
.TP 
8859\-12
Этот набор не существует.
.TP 
8859\-13 (Latin\-7)
Поддерживает балтийские языки, в частности, латвийские символы не вошедшие в
Latin\-4.
.TP 
8859\-14 (Latin\-8)
Это кельтский набор символов для старого ирландского, мэнского, гаэлльского,
уэльского, корнуэльского и бретонского языков.
.TP 
8859\-15 (Latin\-9)
Latin\-9 похож на широко используемый Latin\-1, но в нём заменены некоторые
мало используемые символы на знак евро, а также французские и финские
лигатуры, отсутствующие в Latin\-1.
.TP 
8859\-16 (Latin\-10)
Этот набор включает в себя многие южно\-европейские языки, и самое главное,
румынский язык поддерживается более полно чем в Latin\-2.
.SS "KOI8\-R / KOI8\-U"
KOI8\-R — набор символов не ISO, являлся популярным в России до
Юникода. Нижняя часть таблицы описывает ASCII, верхняя — набор символов
кириллицы, более совершенный по сравнению с ISO 8859\-5. KOI8\-U, основанный
на KOI8\-R, имеет более полную поддержку украинского языка. Ни один из этих
наборов не совместим с ISO\-2022 (в отличии от ISO 8859).
.PP
Поддержка символов KOI8\-R в консоли осуществляется Linux с помощью
пользовательских утилит, меняющих привязки клавиатуры, таблицу графики EGA и
передающих драйверу консоли таблицу соответствий символов шрифтам.
.SS "GB 2312"
GB 2312 это национальный китайский стандартный набор символов для
упрощенного китайского. Как и в JIS X 0208, символы берутся из массива 94x94
и состоят из двух байт. Набор символов используется для кодировки
EUC\-CN. EUC\-CN является наиболее важной кодировкой для Linux и включает в
себя ASCII и GB 2312. Заметим, что EUC\-CN часто называют GB, GB 2312 или
CN\-GB.
.SS Big5
.\" Thanks to Tomohiro KUBOTA for the following sections about
.\" national standards.
Big5 — ранее популярный набор в Тайване для отображения традиционного
китайского языка (Big5 является и кодировкой и набором символов). Он
включает в себя ASCII. Символы, не входящие в ASCII, представлены двумя
байтами. Первый байт (символ представлен двумя байтами) берётся из диапазона
xa1\(en0xfe. Big5 и его расширение широко используются в Тайване и
Гонконге. Он не совместим с ISO 2022.
.SS "JIS X 0208"
JIS X 208 является стандартным набором для японского языка. Существуют
несколько других японских стандартов, например, JIS X 0201, JIS X 0212 и JIS
X 0213, но первый — самый распространенный. Символы берутся из массива 94x94
и представлены двумя байтами, каждый из которых находится в интервале
0x21\(en0x7e. Заметьте, что JIS X 0208 является набором символов, а не
кодировкой. Это означает, что JIS X 0208 не может представлять текстовую
информацию самостоятельно, а является лишь компонентом для кодировок, таких
как EUC\-JP, Shift_JIS и ISO\-2022\-JP. EUC\-JP — наиболее важная кодировка для
Linux и включает в себя ASCII и JIS X 0208. В EUC\-JP для символов JIS X 0208
отводится по 2 байта, значение каждого из которых равно коду JIS X 0208 плюс
0x80.
.SS "KS X 1001"
KS X 1001 это корейский национальный стандарт для наборов символов. Как и в
JIS X 0208, символы берутся из матрицы 94x94 и состоят из двух байт. KS X
1001, так же как и JIS X 0208, является компонентом для кодировок EUC\-KR,
Johab и ISO\-2022\-KR. EUC\-KR является наиболее важной кодировкой для Linux и
включает в себя ASCII и KS X 1001. KS C 5601 это старое название KS X 1001.
.SS "ISO 2022 и ISO 4873"
Стандарты ISO 2022 и 4873 описывают модель управления шрифтами, основанную
на практике работы с VT100. Эта модель (частично) поддерживается ядром Linux
и \fBxterm\fP(1). Были определены некоторые наборы символов на основе ISO 2022,
особенно популярного в Японии.
.PP
Имеется 4 набора графических символов, называемых G0, G1, G2 и G3. Один из
них является текущим набором символов для кодов со старшим битом, равным
нулю (изначально G0), другой — текущим набором для кодов со старшим битом,
равным единице (изначально G1). Каждый набор графических символов имеет 94
или 96 символов и, по сути, является 7\-битным набором символов. Используются
либо коды 040\(en0177 (041\(en0176), либо 0240\(en0377
(0241\(en0376). Размер G0 всегда равен 94\-м символам и содержит коды
041\(en0176.
.PP
Переключение с одного набора символов на другой производится с помощью
функций сдвига \fB^N\fP (SO или LS1), \fB^O\fP (SI или LS0), ESC n (LS2), ESC o
(LS3), ESC N (SS2), ESC O (SS3), ESC ~ (LS1R), ESC } (LS2R), ESC |
(LS3R). Функция LS\fIn\fP делает набор символов G\fIn\fP текущим для кодов со
старшим битом, равным нулю. Функция LS\fIn\fPR делает набор символов G\fIn\fP
текущим для кодов со старшим битом, равным единице. Функция SS\fIn\fP делает
набор символов G\fIn\fP (\fIn\fP=2 или 3) текущим только для следующего символа
(независимо от значения старшего бита).
.PP
94\-символьный набор становится набором символов G\fIn\fP c помощью
последовательности ESC ( xx (для G0), ESC ) xx (для G1), ESC * xx (для G2),
ESC + xx (для G3), где xx является символом или парой символов, которая
содержится в ISO 2375 International Register of Coded Character Sets
(международном реестре кодированных наборов символов). Например, ESC ( @
выбирает в качестве G0 набор символов ISO 646, ESC ( A выбирает стандартный
набор символов UK (со знаком фунта вместо знака номера), ESC ( B выбирает
ASCII (со знаком доллара вместо знака валюты), ESC ( M выбирает набор
символов для африканских языков, ESC ( ! A выбирает кубинский набор символов
и т.д. и т.п.
.PP
96\-символьный набор назначается набором символов G\fIn\fP с помощью
последовательности ESC \- xx (для G1), ESC . xx (для G2) или ESC / xx (для
G3). Например, ESC \- G выбирает иврит в качестве G1.
.PP
Мультибайтный набор символов назначается набором символов G\fIn\fP управляющей
последовательностью ESC $ xx или ESC $ ( xx (для G0), ESC $ ) xx (для G1),
ESC $ * xx (для G2), ESC $ + xx (для G3). Например, ESC $ ( C выбирает
корейский набор символов для G0. Набор японских символов выбирается при
помощи ESC $ B, а его более новая версия — при помощи ESC & @ ESC $ B.
.PP
ISO 4873 оговаривает более направленное использование наборов символов, при
котором G0 постоянен (всегда ASCII), так что G1, G2 и G3 могут быть заданы
только для кодов с установленным старшим битом. При этом \fB^N\fP и \fB^O\fP
больше не используются, ESC ( xx может быть использована только с xx=B, а
ESC ) xx, ESC * xx и ESC + xx эквивалентны ESC \- xx, ESC . xx и ESC / xx,
соответственно.
.SS TIS\-620
TIS \-62 — это национальный стандартный набор тайских символов, включающий
ASCII. Как и в стандартах ISO 8859, тайские символы находятся в интервале
0xa1\(en0xfe.
.SS Юникод
Юникод (ISO 10646) — стандарт, которым можно представить любой символ из
всех известных человеку языков. В структуре Юникода на кодирование каждого
символа выделяется 20.1 бит. Так как большинство компьютеров не поддерживают
целых чисел размерностью 20.1 бит, то Юникод, обычно, кодируется в 32\-битных
целых, а также или серией 16\-ти битных целых (UTF\-16, 2 16\-битных целых
требуется только при кодировании редких символов), или серией 8\-битных байт
(UTF\-8).
.PP
Для представления Юникода в Linux используется 8\-битный формат
преобразования Юникода (UTF\-8 \- 8\-bit Unicode Transformation Format). UTF\-8
— это формат непостоянной длины для кодирования Юникода. В нём используется
1 байт для кодирования 7\-и битов, 2 байта для 11\-и битов, 3 байта для 16\-и
битов, 4 байта для 21\-ого бита, 5 байтов для 26\-и битов, 6 байтов для 31\-ого
бита.
.PP
Пусть 0, 1, x соответствует нулю, единице и случайному биту. Байт 0xxxxxxx
соответствует Юникоду 00000000 0xxxxxxx, что, в свою очередь, соответствует
символу в ASCII 0xxxxxxxx. То есть, коды ASCII совпадают с кодами UTF\-8 и
людям, использующим только ASCII, ничего делать не нужно: ни в коде, ни в
файлах.
.PP
Байт 110xxxxx является началом 2\-байтного кода, и 110xxxxx 10yyyyyy
преобразуется в 00000xxx xxyyyyyy. Байт 1110xxxx — начало 3\-байтного кода, и
1110xxxx 10yyyyyy 10zzzzzz преобразуется в xxxxyyyy yyzzzzzz (если UTF\-8
используется для кодирования 31\-битного ISO 10646, то это прогрессия
продолжается до 6\-байтных кодов).
.PP
Для большинства текстов, кодированных наборами ISO 8859, это означает, что
символы, не входящие в ASCII, теперь кодируются двумя байтами. Это приводит
к тому, что обычный текстовый файл становится больше на 1\-2
процента. Обычные текстовые файлы на греческом или русском языке
увеличиваются на 100%, так как почти все символы в этих языках находятся за
пределами ASCII. Для пользователей японского языка 16\-ти битные символы
теперь, в основном, представляются 3\-мя байтами. Хотя для некоторых наборов
символов (особенно ISO\-8859\-1) и есть алгоритмы преобразования в Юникод, в
большинстве случаев для преобразований требуются таблицы соответствий,
которые могут быть большими для 16\-битных кодов.
.PP
Заметим, что UTF\-8 является самосинхронизирующимся: 10xxxxxx — это «хвост»,
а любой другой байт — «голова» кода. Только байты ASCII в потоке UTF\-8
представлены без изменений. В частности, в поток не встраиваются NUL
(\(aq\e0\(aq) или \(aq/\(aq для формирования части какого\-то большего кода.
.PP
Так как символы ASCII, в частности, NUL и \(aq/\(aq, не изменяются, то ядро
не замечает, что используется UTF\-8. В нём никак не учитывается для чего
используются эти байты.
.PP
Визуализация потоков данных Юникода обычно производится с помощью таблицы
«подшрифтов», переводящей единицы набора Юникода в образы символов
(глифы). Внутри ядра Юникод используется для описания подшрифта,
загруженного в видеопамять. Это означает, что в консоли Linux в режиме UTF\-8
можно использовать набор символов с 512\-ю различными символами. Этого
недостаточно для японского, китайского и корейского языков, но достаточно
для большинства других.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBiconv\fP(1), \fBascii\fP(7), \fBiso_8859\-1\fP(7), \fBunicode\fP(7), \fButf\-8\fP(7)
