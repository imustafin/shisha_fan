.\" -*- mode: troff; coding: UTF-8 -*-
'\" t
.\" Copyright (c) 1993 by Thomas Koenig (ig25@rz.uni-karlsruhe.de)
.\" and Copyright (c) 2002, 2006 by Michael Kerrisk <mtk.manpages@gmail.com>
.\" and Copyright (c) 2008 Linux Foundation, written by Michael Kerrisk
.\"     <mtk.manpages@gmail.com>
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"
.\" Modified Sat Jul 24 17:34:08 1993 by Rik Faith (faith@cs.unc.edu)
.\" Modified Sun Jan  7 01:41:27 1996 by Andries Brouwer (aeb@cwi.nl)
.\" Modified Sun Apr 14 12:02:29 1996 by Andries Brouwer (aeb@cwi.nl)
.\" Modified Sat Nov 13 16:28:23 1999 by Andries Brouwer (aeb@cwi.nl)
.\" Modified 10 Apr 2002, by Michael Kerrisk <mtk.manpages@gmail.com>
.\" Modified  7 Jun 2002, by Michael Kerrisk <mtk.manpages@gmail.com>
.\"	Added information on real-time signals
.\" Modified 13 Jun 2002, by Michael Kerrisk <mtk.manpages@gmail.com>
.\"	Noted that SIGSTKFLT is in fact unused
.\" 2004-12-03, Modified mtk, added notes on RLIMIT_SIGPENDING
.\" 2006-04-24, mtk, Added text on changing signal dispositions,
.\"		signal mask, and pending signals.
.\" 2008-07-04, mtk:
.\"     Added section on system call restarting (SA_RESTART)
.\"     Added section on stop/cont signals interrupting syscalls.
.\" 2008-10-05, mtk: various additions
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH SIGNAL 7 2019\-08\-02 Linux "Руководство программиста Linux"
.SH ИМЯ
signal \- обзор сигналов
.SH ОПИСАНИЕ
В Linux поддерживаются надёжные (reliable) сигналы POSIX (далее,
«стандартные сигналы») и сигналы реального времени POSIX.
.SS "Обработчики сигнала"
Каждый сигнал имеет текущий \fIобработчик\fP, который определяет, что будет
делать процесс при поступлении сигнала.
.PP
В таблице далее есть столбец «Действие», в котором указан обработчик по
умолчанию для каждого сигнала:
.IP Term
Действие по умолчанию — завершение процесса.
.IP Ign
Действие по умолчанию — игнорирование сигнала.
.IP Core
Действие по умолчанию — завершение процесса и вывод дампа в файл (смотрите
\fBcore\fP(5)).
.IP Stop
Действие по умолчанию — остановка процесса.
.IP Cont
Действие по умолчанию — продолжение работы процесса, если он в данный момент
остановлен.
.PP
Процесс может изменить обработчик сигнала с помощью \fBsigaction\fP(2) или
\fBsignal\fP(2) (последний менее переносим, если используется для установки
обработчика сигнала; дополнительную информацию смотрите в
\fBsignal\fP(2)). Используя данные системные вызовы процесс может выбрать одно
из следующих действий при получении сигнала: выполнить действие по
умолчанию, игнорировать сигнал, поймать сигнал \fIобработчиком сигнала\fP —
функцией, задаваемой программистом, которая автоматически вызывается при
получении сигнала.
.PP
По умолчанию обработчик сигнала использует обычный стек процесса. Возможно
сделать так, чтобы обработчик сигнала использовал альтернативный стек; как
это делается и когда это может быть полезно смотрите в \fBsigaltstack\fP(2).
.PP
Реакция на сигналы является атрибутом процесса: в многонитевом приложении
реакция на определённый сигнал одинакова для всех нитей.
.PP
Потомок, созданный с помощью \fBfork\fP(2), наследует реакцию на сигналы от
своего родителя. При \fBexecve\fP(2) реакция на сигналы устанавливается в
значение по умолчанию; реакция на игнорируемые сигналы не изменяется.
.SS "Отправка сигнала"
Для отправки сигнала можно использовать следующие системные вызовы и
библиотечные функции:
.TP  16
\fBraise\fP(3)
Посылает сигнал вызвавшей нити.
.TP 
\fBkill\fP(2)
Посылает сигнал указанному процессу, всем членам указанной группы процессов
или всем процессам в системе.
.TP 
\fBkillpg\fP(3)
Посылает сигнал всем членам указанной группы процессов.
.TP 
\fBpthread_kill\fP(3)
Посылает сигнал указанной нити POSIX в том же процессе, что и вызывающий.
.TP 
\fBtgkill\fP(2)
Посылает сигнал указанной нити в указанном процессе (данный системный вызов
используется в реализации \fBpthread_kill\fP(3)).
.TP 
\fBsigqueue\fP(3)
Посылает сигнал реального времени указанному процессу с сопроводительными
данными.
.SS "Ожидание сигнала для обработки"
Следующие системные вызовы приостанавливают выполнение вызывающей нити до
тех пор, пока не будет пойман сигнал (или необработанный сигнал не завершит
процесс):
.TP  16
\fBpause\fP(2)
Приостанавливает выполнение до тех пор, пока не будет пойман любой сигнал.
.TP 
\fBsigsuspend\fP(2)
Временно изменяет маску сигналов (смотрите далее) и приостанавливает
выполнение до получения одного из незамаскированных сигналов.
.SS "Синхронный приём сигнала"
В отличие от асинхронного получения сигнала через обработчик, возможно
синхронно получить сигнал, то есть блокировать выполнение до поступления
сигнала в некоторой точке, в которой ядро вернёт информацию о сигнале
вызывающему. Для этого существует два пути:
.IP * 2
С помощью \fBsigwaitinfo\fP(2), \fBsigtimedwait\fP(2) и \fBsigwait\fP(3). Они
приостанавливают выполнение до поступления одного из заданного набора
сигналов. Каждый из этих вызовов возвращает информацию о полученном сигнале.
.IP *
С помощью \fBsignalfd\fP(2). Данный вызов возвращает файловый дескриптор,
который можно использовать для чтения информации о сигналах, доставляемых
вызывающему. Каждое выполнение \fBread\fP(2) с этим файловым дескриптором
блокируется до тех пор, пока один из сигналов набора, указанного в вызове
\fBsignalfd\fP(2), не будет послан вызывающему. В возвращаемом \fBread\fP(2)
буфере содержится структура, описывающая сигнал.
.SS "Сигнальная маска и ожидающие сигналы"
Сигнал может быть \fIзаблокирован\fP. Это означает, что он не будет доставлен
до тех пор, пока не будет разблокирован. В промежуток времени от генерации
сигнала и до его доставки о сигнале говорят как об \fIожидающем\fP.
.PP
В каждой нити процесса имеется независимая \fIсигнальная маска\fP, определяющая
набор сигналов, которые нить, в данный момент, блокирует. Нить может
управлять сигнальной маской с помощью \fBpthread_sigmask\fP(3). В обычном
однонитевом приложении для работы с сигнальной маской можно использовать
вызов \fBsigprocmask\fP(2).
.PP
Потомок, создаваемый с помощью \fBfork\fP(2), наследует копию родительской
маски сигналов; маска сигналов сохраняется при вызове \fBexecve\fP(2).
.PP
Сигнал может быть направлен процессу или нити. Направленный процессу сигнал
предназначен (и ожидается) для процесса в целом. Сигнал может быть направлен
процессу ядром из\-за аппаратного исключения или с помощью \fBkill\fP(2) или
\fBsigqueue\fP(3). Направленный нити сигнал предназначен определённой
нити. Сигнал может быть направлен нити, так как был сгенерирован при
выполнении определённой инструкции машинного языка, которая привела к
аппаратному исключению (например, \fBSIGSEGV\fP при некорректном доступен к
памяти или \fBSIGFPE\fP при математической ошибке), или направлен определённой
нити с помощью интерфейса \fBtgkill\fP(2) или \fBpthread_kill\fP(3).
.PP
Направленный процессу сигнал может быть доставлен в любую из нитей, у
которой сигнал не заблокирован. Если имеется несколько таких нитей, то ядро
выбирает произвольную нить, которой и доставит сигнал.
.PP
Нить может получить набор сигналов, которые находятся в состоянии ожидания с
помощью вызова \fBsigpending\fP(2). Этот набор будет состоять из объединения
набора ожидающих сигналов, направленных процессу, и набора ожидающих
сигналов для вызвавшей нити.
.PP
Потомок, созданный с помощью \fBfork\fP(2), первоначально имеет пустой набор
ожидающих сигналов; набор ожидающих сигналов сохраняется при вызове
\fBexecve\fP(2).
.SS "Стандартные сигналы"
Linux поддерживает стандартные сигналы, перечисленные далее. Во второй
колонке таблицы указан стандарт (если есть), которым введён сигнал,
например, «P1990» — сигнал описан в первоначальной версии стандарта
POSIX.1\-1990; «P2001» — сигнал добавлен в SUSv2 и POSIX.1\-2001.
.TS
l c c l
____
lB c c l.
Сигнал	Стандарт	Действие	Комментарий
SIGABRT	P1990	Core	Сигнал аварии (abort), посланный \fBabort\fP(3)
SIGALRM	P1990	Term	Сигнал таймера, посланный \fBalarm\fP(2)
SIGBUS	P2001	Core	Ошибка шины (некорректный адрес доступа)
SIGCHLD	P1990	Ign	Потомок остановлен или завершился
SIGCLD	\-	Ign	Синоним \fBSIGCHLD\fP
SIGCONT	P1990	Cont	Продолжить, если остановлен
SIGEMT	\-	Term	Ловушка эмулятора
SIGFPE	P1990	Core	Ошибка операций с плавающей запятой
SIGHUP	P1990	Term	Обнаружен обрыв связи с управляющим
			терминалом, либо завершение управляющего терминалом процесса
SIGILL	P1990	Core	Недопустимая инструкция
SIGINFO	\-		Синоним \fBSIGPWR\fP
SIGINT	P1990	Term	Прерывание с клавиатуры
SIGIO	\-	Term	Теперь возможен ввод/вывод (4.2BSD)
SIGIOT	\-	Core	Ловушка IOT. Синоним \fBSIGABRT\fP
SIGKILL	P1990	Term	Kill\-сигнал
SIGLOST	\-	Term	Утрачена блокировка файла (не используется)
SIGPIPE	P1990	Term	Обрыв канала: запись в канал без
			читателей; смотрите \fBpipe\fP(7)
SIGPOLL	P2001	Term	Опрашиваемое событие (Sys V)
			Синоним \fBSIGIO\fP
SIGPROF	P2001	Term	Время профилирования истекло
SIGPWR	\-	Term	Отказ питания (System V)
SIGQUIT	P1990	Core	Выход с клавиатуры
SIGSEGV	P1990	Core	Некорректная ссылка в память
SIGSTKFLT	\-	Term	Ошибка стека на сопроцессоре (не используется)
SIGSTOP	P1990	Stop	Остановить процесс
SIGTSTP	P1990	Stop	Останов введён с терминала
SIGSYS	P2001	Core	Неправильный системный вызов (SVr4);
			смотрите также \fBseccomp\fP(2)
SIGTERM	P1990	Term	Сигнал завершения
SIGTRAP	P2001	Core	Прерывание из\-за трассировки/останова
SIGTTIN	P1990	Stop	Ввод с терминала для фонового процесса
SIGTTOU	P1990	Stop	Вывод с терминала для фонового процесса
SIGUNUSED	\-	Core	Синоним \fBSIGSYS\fP
SIGURG	P2001	Ign	Требующее внимание условие сокета (4.2BSD)
SIGUSR1	P1990	Term	Определяемый пользователем сигнал 1
SIGUSR2	P1990	Term	Определяемый пользователем сигнал 2
SIGVTALRM	P2001	Term	Виртуальный будильник (4.2BSD)
SIGXCPU	P2001	Core	Превышен предел процессорного времени (4.2BSD);
			смотрите \fBsetrlimit\fP(2)
SIGXFSZ	P2001	Core	Превышен предел размера файла (4.2BSD);
			смотрите \fBsetrlimit\fP(2)
SIGWINCH	\-	Ign	Сигнал изменения размера окна (4.3BSD, Sun)
.TE
.PP
Сигналы \fBSIGKILL\fP и \fBSIGSTOP\fP нельзя поймать, заблокировать или
проигнорировать.
.PP
В Linux до версии 2.2 включительно поведением по умолчанию для сигналов
\fBSIGSYS\fP, \fBSIGXCPU\fP, \fBSIGXFSZ\fP и \fBSIGBUS\fP (на всех архитектурах кроме
SPARC и MIPS) было завершение процесса без создания дампа (в некоторых
системах UNIX действием по умолчанию для \fBSIGXCPU\fP и \fBSIGXFSZ\fP является
завершение процесса без создания дампа). Linux версии 2.4 соответствует
требованиям POSIX.1\-2001 для этих сигналов и завершает процесс с созданием
дампа.
.PP
.PP
Сигнал \fBSIGEMT\fP не определён в POSIX.1\-2001, но, тем не менее, появляется
почти во всех системах UNIX, где действием по умолчанию для него является
завершение процесса с созданием дампа.
.PP
Сигнал \fBSIGPWR\fP (не определён в POSIX.1\-2001) по умолчанию, обычно,
игнорируется (в других системах UNIX).
.PP
.\"
Для сигнала \fBSIGIO\fP (не определён в POSIX.1\-2001) в других системах UNIX
действием по умолчанию является игнорирование.
.SS "Семантика очерёдности и доставки стандартных сигналов"
Если несколько стандартных сигналов ожидают обработки процессом, то порядок
доставки сигналов не определён.
.PP
.\"
Стандартные сигналы не упорядочиваются. Если генерируется несколько
экземпляров стандартного сигнала заблокированному процессу, то только один
экземпляр сигнала помечается как ожидающий (и сигнал будет доставлен только
после разблокировки). В случае, если уже есть ожидающий стандартный сигнал,
структура \fIsiginfo_t\fP (смотрите \fBsigaction\fP(2)), связанная с этим
сигналом, не перезаписывается при поступлении последующих экземпляров того
же сигнала. То есть, процесс получит информацию, связанную с первым
экземпляром сигнала.
.SS "Нумерация стандартных сигналов"
Числовое значение каждого сигнала показано в таблице ниже. У многих сигналов
номера различаются на разных архитектурах. Первое числовое значение в каждой
строке таблицы описывает номер сигнала на x86, ARM и большинстве других
архитектур; второе значение для Alpha и SPARC, третье для MIPS, последнее
для PARISC. Символ минус (\-) означает, что сигнал отсутствует в
соответствующей архитектуре.
.TS
l c c c c l
l c c c c l
______
lB c c c c l.
Сигнал	x86/ARM	Alpha/	MIPS	PARISC	Примечания
	большинство других	SPARC
SIGHUP	\01	\01	\01	\01
SIGINT	\02	\02	\02	\02
SIGQUIT	\03	\03	\03	\03
SIGILL	\04	\04	\04	\04
SIGTRAP	\05	\05	\05	\05
SIGABRT	\06	\06	\06	\06
SIGIOT	\06	\06	\06	\06
SIGBUS	\07	10	10	10
SIGEMT	\-	\07	\07	\-
SIGFPE	\08	\08	\08	\08
SIGKILL	\09	\09	\09	\09
SIGUSR1	10	30	16	16
SIGSEGV	11	11	11	11
SIGUSR2	12	31	17	17
SIGPIPE	13	13	13	13
SIGALRM	14	14	14	14
SIGTERM	15	15	15	15
SIGSTKFLT	16	\-	\-	\07
SIGCHLD	17	20	18	18
SIGCLD	\-	\-	18	\-
SIGCONT	18	19	25	26
SIGSTOP	19	17	23	24
SIGTSTP	20	18	24	25
SIGTTIN	21	21	26	27
SIGTTOU	22	22	27	28
SIGURG	23	16	21	29
SIGXCPU	24	24	30	12
SIGXFSZ	25	25	31	30
SIGVTALRM	26	26	28	20
SIGPROF	27	27	29	21
SIGWINCH	28	28	20	23
SIGIO	29	23	22	22
SIGPOLL					Тот же, что SIGIO
SIGPWR	30	29/\-	19	19
SIGINFO	\-	29/\-	\-	\-
SIGLOST	\-	\-/29	\-	\-
SIGSYS	31	12	12	31
SIGUNUSED	31	\-	\-	31
.TE
.PP
Также заметим следующее:
.IP * 3
Если определён сигнал \fBSIGUNUSED\fP, то он является синонимом
\fBSIGSYS\fP. Начиная с glibc 2.26, определение \fBSIGUNUSED\fP удалено из всех
архитектур.
.IP *
.\"
Сигнал с номером 29 на Alpha соответствует \fBSIGINFO\fP/\fBSIGPWR\fP (одинаковый
номер), а на SPARC соответствует \fBSIGLOST\fP.
.SS "Сигналы реального времени"
Начиная с версии 2.2, Linux поддерживает сигналы реального времени согласно
первоначальному описанию расширений реального времени в POSIX.1b (теперь
включено в POSIX.1\-2001). Диапазон поддерживаемых сигналов реального времени
определяется макросами \fBSIGRTMIN\fP и \fBSIGRTMAX\fP. Согласно POSIX.1\-2001
требуется, чтобы реализация поддерживала не менее \fB_POSIX_RTSIG_MAX\fP (8)
сигналов реального времени.
.PP
Ядро Linux поддерживает 33 таких сигнала, начиная с номера 32 до номера
64. Однако внутри реализации нитей POSIX в glibc используется два (для NPTL)
или три (для LinuxThreads) сигнала реального времени (смотрите
\fBpthreads\fP(7)), а значение \fBSIGRTMIN\fP корректируется должным образом (до
34 или 35). Так как диапазон доступных сигналов реального времени
различается в зависимости от реализации нитей в glibc (и это может
происходить во время выполнения при смене ядра и glibc), и, более того,
диапазон сигналов реального времени различен в разных системах UNIX, то
программы \fIникогда не должны задавать сигналы реального времени по
номерам\fP, а вместо этого всегда должны записывать их в виде \fBSIGRTMIN\fP+n и
выполнять проверку (во время выполнения), что \fBSIGRTMIN\fP+n не превышает
\fBSIGRTMAX\fP.
.PP
В отличие от стандартных сигналов, сигналы реального времени не имеют
предопределенного назначения: весь набор сигналов реального времени
приложения могут использовать так, как им нужно.
.PP
Действием по умолчанию для необработанных сигналов реального времени
является завершение процесса (terminate).
.PP
Сигналы реального времени отличаются от обычных в следующем:
.IP 1. 4
В очередь можно добавлять несколько экземпляров одного сигнала реального
времени. В случае со стандартными сигналами, если доставляется несколько
экземпляров сигнала, в то время как этот тип сигнала в данный момент
заблокирован, то только один экземпляр будет добавлен в очередь.
.IP 2. 4
Если сигнал отправляется с помощью \fBsigqueue\fP(3), то с сигналом может быть
отправлено некоторое значение (целочисленное, либо указатель). Если
принимающий процесс устанавливает обработчик для сигнала, используя флаг
\fBSA_SIGINFO\fP и вызов \fBsigaction\fP(2), то он может получить это значение
через поле \fIsi_value\fP структуры \fIsiginfo_t\fP, переданной обработчику в виде
второго аргумента. Кроме этого, поля \fIsi_pid\fP и \fIsi_uid\fP данной структуры
можно использовать для получения идентификатора процесса и реального
идентификатора пользователя, отправившего сигнал.
.IP 3. 4
Сигналы реального времени доставляются точно в порядке
поступления. Несколько сигналов одного типа доставляются в порядке,
определяемых их отправлением. Если процессу отправлено несколько разных
сигналов реального времени, то порядок их доставки начинается с сигнала с
наименьшим номером (то есть сигналы с наименьшим номером имеют наивысший
приоритет). Порядок же для стандартных сигналов в такой ситуации не
определён.
.PP
Если процессу передан и стандартный сигнал, и сигнал реального времени, то в
POSIX однозначно не определено, какой из них будет доставлен первым. В
Linux, как и во многих других реализациях в таких случаях, отдан приоритет
стандартным сигналам.
.PP
В соответствии с POSIX, реализация должна позволять ставить в очередь
процесса, как минимум, \fB_POSIX_SIGQUEUE_MAX\fP (32) сигнала реального
времени. Однако в Linux это делается по\-другому. В ядрах до версии 2.6.7
включительно, Linux накладывает общесистемный лимит на количество сигналов
режима реального времени в очереди для всех процессов. Этот лимит может быть
получен и изменён (если есть права) через файл
\fI/proc/sys/kernel/rtsig\-max\fP. Текущее количество сигналов режима реального
времени в очереди можно получить из файла \fI/proc/sys/kernel/rtsig\-nr\fP. В
Linux 2.6.8 данные интерфейсы \fI/proc\fP были заменены на ограничение ресурса
\fBRLIMIT_SIGPENDING\fP, которое устанавливает ограничение на очередь сигналов
на каждого пользователя отдельно; дополнительную информацию можно найти в
\fBsetrlimit\fP(2).
.PP
Для дополнительных сигналов реального времени требуется расширение структуры
набора сигналов (\fIsigset_t\fP) с 32 до 64 бит. В связи с этим, различные
системные вызовы заменены на новые системные вызов, поддерживающие набор
сигналов большего размера. Вот соответствие старых и новых системных
вызовов:
.TS
lb lb
l l.
Linux версии 2.0 и более ранние	Linux версии 2.2 и новее
\fBsigaction\fP(2)	\fBrt_sigaction\fP(2)
\fBsigpending\fP(2)	\fBrt_sigpending\fP(2)
\fBsigprocmask\fP(2)	\fBrt_sigprocmask\fP(2)
\fBsigreturn\fP(2)	\fBrt_sigreturn\fP(2)
\fBsigsuspend\fP(2)	\fBrt_sigsuspend\fP(2)
\fBsigtimedwait\fP(2)	\fBrt_sigtimedwait\fP(2)
.TE
.\"
.SS "Прерывание системных вызовов и библиотечных функций обработчиками сигналов"
Если обработчик сигнала вызван во время заблокированного системного вызова
или библиотечной функции, то может произойти следующее:
.IP * 2
вызов автоматически перезапускается после возврата из обработчика сигнала;
или
.IP *
вызов завершается с ошибкой \fBEINTR\fP.
.PP
Выбираемое поведение зависит от интерфейса и от того, был ли обработчик
сигнала установлен с флагом \fBSA_RESTART\fP (смотрите \fBsigaction\fP(2)). Но в
различных системах UNIX есть другие различия; далее описаны подробности для
Linux.
.PP
.\" The following system calls use ERESTARTSYS,
.\" so that they are restartable
Если заблокированный вызов к одному из следующих интерфейсов прерван
обработчиком сигнала, то вызов автоматически перезапускается после
завершения обработчика сигнала, если задействован флаг \fBSA_RESTART\fP; иначе
вызов завершается ошибкой \fBEINTR\fP:
.IP * 2
Вызовы \fBread\fP(2), \fBreadv\fP(2), \fBwrite\fP(2), \fBwritev\fP(2) и \fBioctl\fP(2) для
«медленных» устройств. «Медленным» называют устройство, которое может
навсегда заблокировать ввод\-вывод, например, терминал, канал или сокет. Если
вызов ввода\-вывода для медленного устройства уже передал немного данных на
момент прерывания обработчиком сигнала, то вызов вернёт состояние успешного
выполнения (обычно, количество переданных байт). Заметим, что диск
(локальный) не подходит под определение медленного устройства; операции
ввода\-вывода с дисками не прерываются сигналами.
.IP *
Вызов \fBopen\fP(2), если он может выполнить блокировку (например, при открытии
FIFO; смотрите \fBfifo\fP(7)).
.IP *
Вызовы \fBwait\fP(2), \fBwait3\fP(2), \fBwait4\fP(2), \fBwaitid\fP(2) и \fBwaitpid\fP(2).
.IP *
.\" If a timeout (setsockopt()) is in effect on the socket, then these
.\" system calls switch to using EINTR.  Consequently, they and are not
.\" automatically restarted, and they show the stop/cont behavior
.\" described below.  (Verified from 2.6.26 source, and by experiment; mtk)
.\" FIXME What about sendmmsg()?
Интерфейсы сокетов: \fBaccept\fP(2), \fBconnect\fP(2), \fBrecv\fP(2), \fBrecvfrom\fP(2),
\fBrecvmmsg\fP(2), \fBrecvmsg\fP(2), \fBsend\fP(2), \fBsendto\fP(2) и \fBsendmsg\fP(2),
если для сокета не указано время ожидания (смотрите далее).
.IP *
Интерфейсы файловой блокировки: \fBflock\fP(2) и операции \fBF_SETLKW\fP и
\fBF_OFD_SETLKW\fP у \fBfcntl\fP(2).
.IP *
Интерфейсы очереди сообщений POSIX: \fBmq_receive\fP(3), \fBmq_timedreceive\fP(3),
\fBmq_send\fP(3) и \fBmq_timedsend\fP(3).
.IP *
.\" commit 72c1bbf308c75a136803d2d76d0e18258be14c7a
Вызов \fBfutex\fP(2) с \fBFUTEX_WAIT\fP (начиная с Linux 2.6.22; до этой версии
вызов завершался с ошибкой \fBEINTR\fP).
.IP *
\fBgetrandom\fP(2).
.IP *
\fBpthread_mutex_lock\fP(3), \fBpthread_cond_wait\fP(3) связанный с этим
программный интерфейс.
.IP *
\fBfutex\fP(2)  \fBFUTEX_WAIT_BITSET\fP.
.IP *
.\" as a consequence of the 2.6.22 changes in the futex() implementation
Интерфейсы семафоров POSIX: \fBsem_wait\fP(3) и \fBsem_timedwait\fP(3) (начиная с
Linux 2.6.22; до этой версии вызовы завершались с ошибкой \fBEINTR\fP).
.IP *
.\" commit 1ca39ab9d21ac93f94b9e3eb364ea9a5cf2aba06
Вызов \fBread\fP(2) из файлового дескриптора \fBinotify\fP(7) (начиная с Linux
3.8; прежде всегда завершался с ошибкой \fBEINTR\fP).
.PP
.\" These are the system calls that give EINTR or ERESTARTNOHAND
.\" on interruption by a signal handler.
Следующие интерфейсы никогда не перезапускаются после прерывания
обработчиком сигнала независимо от наличия \fBSA_RESTART\fP; они всегда
завершаются с ошибкой \fBEINTR\fP, если прерываются обработчиком сигнала:
.IP * 2
«Входные» интерфейсы сокетов, если установлен таймаут (\fBSO_RCVTIMEO\fP) на
сокете с помощью \fBsetsockopt\fP(2): \fBaccept\fP(2), \fBrecv\fP(2), \fBrecvfrom\fP(2),
\fBrecvmmsg\fP(2) (также с аргументом \fItimeout\fP, не равным NULL) и
\fBrecvmsg\fP(2).
.IP *
.\" FIXME What about sendmmsg()?
«Выходные» интерфейсы сокетов, если установлен таймаут (\fBSO_RCVTIMEO\fP) на
сокете с помощью \fBsetsockopt\fP(2): \fBconnect\fP(2), \fBsend\fP(2), \fBsendto\fP(2) и
\fBsendmsg\fP(2).
.IP *
Интерфейсы, используемые для ожидания сигналов: \fBpause\fP(2),
\fBsigsuspend\fP(2), \fBsigtimedwait\fP(2) и \fBsigwaitinfo\fP(2).
.IP *
Интерфейсы комбинирования (multiplexing) файловых дескрипторов:
\fBepoll_wait\fP(2), \fBepoll_pwait\fP(2), \fBpoll\fP(2), \fBppoll\fP(2), \fBselect\fP(2) и
\fBpselect\fP(2).
.IP *
.\" On some other systems, SA_RESTART does restart these system calls
IPC\-интерфейсы System V: \fBmsgrcv\fP(2), \fBmsgsnd\fP(2), \fBsemop\fP(2) и
\fBsemtimedop\fP(2).
.IP *
Интерфейсы сна: \fBclock_nanosleep\fP(2), \fBnanosleep\fP(2) и \fBusleep\fP(3).
.IP *
\fBio_getevents\fP(2).
.PP
Функция \fBsleep\fP(3) также никогда не перезапускается, если прервана
обработчиком сигнала, но сообщает об успешном выполнении: возвращает
количество оставшиеся для сна секунд.
.SS "Прерывание системных вызовов и библиотечных функций сигналами останова"
В Linux, даже в отсутствии обработчиков сигнала, некоторые блокирующие
интерфейсы могут завершаться с ошибкой \fBEINTR\fP, если процесс
останавливается одним из сигналов останова и затем возобновляет работу при
получении сигнала \fBSIGCONT\fP. Такое поведение не предусмотрено POSIX.1 и в
других системах отсутствует.
.PP
Интерфейсы Linux, к которым это относится:
.IP * 2
«Входные» интерфейсы сокетов, если установлен таймаут (\fBSO_RCVTIMEO\fP) на
сокете с помощью \fBsetsockopt\fP(2): \fBaccept\fP(2), \fBrecv\fP(2), \fBrecvfrom\fP(2),
\fBrecvmmsg\fP(2) (также с аргументом \fItimeout\fP, не равным NULL) и
\fBrecvmsg\fP(2).
.IP *
.\" FIXME What about sendmmsg()?
«Выходные» интерфейсы сокетов, если установлен таймаут (\fBSO_RCVTIMEO\fP) на
сокете с помощью \fBsetsockopt\fP(2): \fBconnect\fP(2), \fBsend\fP(2), \fBsendto\fP(2) и
\fBsendmsg\fP(2), если установлен таймаут отправления (\fBSO_SNDTIMEO\fP).
.IP * 2
\fBepoll_wait\fP(2), \fBepoll_pwait\fP(2).
.IP *
\fBsemop\fP(2), \fBsemtimedop\fP(2).
.IP *
\fBsigtimedwait\fP(2), \fBsigwaitinfo\fP(2).
.IP *
.\" commit 1ca39ab9d21ac93f94b9e3eb364ea9a5cf2aba06
Linux 3.7 и старее: \fBread\fP(2) из файлового дескриптора \fBinotify\fP(7)
.IP *
Linux версии 2.6.21 и более ранних: \fBfutex\fP(2) с \fBFUTEX_WAIT\fP,
\fBsem_timedwait\fP(3), \fBsem_wait\fP(3).
.IP *
Linux версии 2.6.8 и более ранних: \fBmsgrcv\fP(2), \fBmsgsnd\fP(2).
.IP *
Linux версии 2.4 и более ранних: \fBnanosleep\fP(2).
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
.\" It must be a *very* long time since this was true:
.\" .SH BUGS
.\" .B SIGIO
.\" and
.\" .B SIGLOST
.\" have the same value.
.\" The latter is commented out in the kernel source, but
.\" the build process of some software still thinks that
.\" signal 29 is
.\" .BR SIGLOST .
POSIX.1, кроме описанных исключений.
.SH ЗАМЕЧАНИЯ
Описание безопасных асинхронных функций при работе с сигналами смотрите в
\fBsignal\-safety\fP(7).
.PP
В файле \fI/proc/[pid]/task/[tid]/status\fP содержатся различные поля о
сигналах, которые нить блокирует (\fISigBlk\fP), ловит (\fISigCgt\fP) или
игнорирует (\fISigIgn\fP). Набор отлавливаемые или игнорируемых сигналов
одинаков для всех нитей процесса. Остальные поля отражают набор ожидающих
сигналов, которые непосредственно направляются нити (\fISigPnd\fP), а также
набор ожидающих сигналов, которые направляются непосредственно процессу
(\fIShdPnd\fP). Соответствующие поля в \fI/proc/[pid]/status\fP содержат
информацию для главной нити. Дополнительную информацию смотрите в
\fBproc\fP(5).
.SH "СМОТРИТЕ ТАКЖЕ"
\fBkill\fP(1), \fBclone\fP(2), \fBgetrlimit\fP(2), \fBkill\fP(2), \fBrestart_syscall\fP(2),
\fBrt_sigqueueinfo\fP(2), \fBsetitimer\fP(2), \fBsetrlimit\fP(2), \fBsgetmask\fP(2),
\fBsigaction\fP(2), \fBsigaltstack\fP(2), \fBsignal\fP(2), \fBsignalfd\fP(2),
\fBsigpending\fP(2), \fBsigprocmask\fP(2), \fBsigreturn\fP(2), \fBsigsuspend\fP(2),
\fBsigwaitinfo\fP(2), \fBabort\fP(3), \fBbsd_signal\fP(3), \fBkillpg\fP(3),
\fBlongjmp\fP(3), \fBpthread_sigqueue\fP(3), \fBraise\fP(3), \fBsigqueue\fP(3),
\fBsigset\fP(3), \fBsigsetops\fP(3), \fBsigvec\fP(3), \fBsigwait\fP(3), \fBstrsignal\fP(3),
\fBsysv_signal\fP(3), \fBcore\fP(5), \fBproc\fP(5), \fBnptl\fP(7), \fBpthreads\fP(7),
\fBsigevent\fP(7)
