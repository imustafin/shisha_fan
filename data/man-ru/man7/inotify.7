.\" -*- mode: troff; coding: UTF-8 -*-
'\" t
.\" Copyright (C) 2006, 2014 Michael Kerrisk <mtk.manpages@gmail.com>
.\" Copyright (C) 2014 Heinrich Schuchardt <xypron.glpk@gmx.de>
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH INOTIFY 7 2019\-03\-06 Linux "Руководство программиста Linux"
.SH ИМЯ
inotify \- наблюдает за событиями файловой системы
.SH ОПИСАНИЕ
Программный интерфейс \fIinotify\fP предоставляет механизм для слежения за
событиями в файловой системе. Его можно использовать для слежения за
отдельными файлами или каталогами. При слежении за каталогами inotify
возвращает события как для самого каталога, так и для файлов внутри
каталога.
.PP
В программный интерфейс входят следующие системные вызовы:
.IP * 3
Вызов \fBinotify_init\fP(2) создаёт экземпляр inotify и возвращает файловый
дескриптор, ссылающийся на экземпляр inotify. Более новый
\fBinotify_init1\fP(2) подобен \fBinotify_init\fP(2), но имеет аргумент \fIflags\fP,
который предоставляет доступ к некоторым дополнительным возможностям.
.IP *
Вызов \fBinotify_add_watch\fP(2) изменяет «список наблюдения», связанный с
экземпляром inotify. Каждый элемент (сторожок (watch)) в списке задаёт путь
к файлу или каталогу и некоторый набор событий, которые ядро должно
отслеживать для файла, на который указывает этот путь. Вызов
\fBinotify_add_watch\fP(2) или создаёт новый сторожок, или изменяет
существующий. Каждый сторожок имеет уникальный «дескриптор сторожка» — целое
число, возвращаемое \fBinotify_add_watch\fP(2) при создании сторожка.
.IP *
При возникновении событий с отслеживаемыми файлами и каталогами, эти события
становятся доступны приложению в виде структурированных данных, которые
можно прочитать из файлового дескриптора inotify с помощью \fBread\fP(2)
(смотрите ниже).
.IP *
Вызов \fBinotify_rm_watch\fP(2) удаляет элемент из списка наблюдения inotify.
.IP *
При закрытии (с помощью \fBclose\fP(2)) файловых дескрипторов, ссылающихся на
экземпляр inotify, этот объект и его ресурсы освобождаются для повторного
использования ядром; все связанные сторожки освобождаются автоматически.
.PP
При корректном программировании, приложение может эффективно использовать
inotify для слежения и кэширования состояния набора объектов файловой
системы. Однако, в тщательно проработанных приложениях нужно предполагать
наличие ошибок в логике слежения или состязательности, описанных далее,
которые могут приводить к рассогласованности кэша с состоянием файловой
системы. Вероятно, лучше сделать некоторую проверку и перестроить кэш при
обнаружении рассогласованности.
.SS "Чтение событий из файлового дескриптора inotify"
Чтобы определить, что события произошли, приложение должно прочитать
(\fBread\fP(2)) файловый дескриптор inotify. Если событий не было, то
предполагая, что это блокирующий файловый дескриптор, вызов \fBread\fP(2)
заблокирует работу до возникновения, по крайней мере, одного события (если
не будет прерван сигналом; в этом случае вызов завершается с ошибкой
\fBEINTR\fP, смотрите \fBsignal\fP(7)).
.PP
При успешном выполнении \fBread\fP(2) возвращает буфер с одной или более
структурами следующего вида:
.PP
.in +4n
.EX
.\" FIXME . The type of the 'wd' field should probably be "int32_t".
.\" I submitted a patch to fix this.  See the LKML thread
.\" "[patch] Fix type errors in inotify interfaces", 18 Nov 2008
.\" Glibc bug filed: http://sources.redhat.com/bugzilla/show_bug.cgi?id=7040
struct inotify_event {
    int      wd;       /* дескриптор наблюдаемого */
    uint32_t mask;     /* маска, описывающая событие */
    uint32_t cookie;   /* уникальный cookie, связывающий относящиеся
                          друг к другу события (для rename(2)) */
    uint32_t len;      /* размер поля \fIname\fP */
    char     name[];   /* необязательное имя, завершающееся null */
};
.EE
.in
.PP
В \fIwd\fP указывается сторожок, к которому относится событие. Это один из
дескрипторов сторожка, полученный из вызова \fBinotify_add_watch\fP(2).
.PP
В \fImask\fP содержатся биты, описывающие возникшее событие (смотрите ниже).
.PP
Значение \fIcookie\fP — это уникальное целое, которое объединяет связанные
события. В настоящее время используется только для событий переименования и
позволяет приложению объединить возвращаемые \fBIN_MOVED_FROM\fP и
\fBIN_MOVED_TO\fP в пару событий. Для остальных типов событий значение
\fIcookie\fP равно 0.
.PP
Поле \fIname\fP существует только когда событие возвращается для файла внутри
отслеживаемого каталога; им определяется имя файла внутри отслеживаемого
каталога. Это имя завершается null и может включать дополнительные байты
null («\e0») для выравнивания на подходящую границу адреса при последующих
операций чтения.
.PP
Поле \fIlen\fP содержит количество всех байт в \fIname\fP, включая байты null;
длина каждой структуры \fIinotify_event\fP равна \fIsizeof(struct
inotify_event)+len\fP.
.PP
Если буфер, заданный в \fBread\fP(2), слишком мал для возврата информации о
следующем событии, то поведение зависит от версии ядра: в ядрах до версии
2.6.21, \fBread\fP(2) возвращает 0; начиная с версии 2.6.21, \fBread\fP(2)
завершается с ошибкой \fBEINVAL\fP. Указание размера буфера
.PP
    sizeof(struct inotify_event) + NAME_MAX + 1
.PP
будет достаточно для чтения, по крайней мере, одного события.
.SS "События inotify"
В аргументе \fBinotify_add_watch\fP(2) \fImask\fP и поле \fImask\fP структуры
\fIinotify_event\fP, возвращаемых при чтении файлового дескриптора inotify,
содержатся битовые маски, определяющие события inotify. Следующие биты могут
быть заданы в \fImask\fP при вызове \fBinotify_add_watch\fP(2) и возвращены в поле
\fImask\fP, возвращаемом \fBread\fP(2):
.RS 4
.TP 
\fBIN_ACCESS\fP (+)
Был произведён доступ к файлу (например, \fBread\fP(2), \fBexecve\fP(2)).
.TP 
\fBIN_ATTRIB\fP (*)
.\" FIXME .
.\" Events do not occur for link count changes on a file inside a monitored
.\" directory. This differs from other metadata changes for files inside
.\" a monitored directory.
Изменились метаданные — например, права доступа (например, \fBchmod\fP(2)),
отметки времени (например, \fButimensat\fP(2)), расширенные атрибуты
(\fBsetxattr\fP(2)), счётчик ссылок (начиная с Linux 2.6.25; например, для
аргумента назначения \fBlink\fP(2) и \fBunlink\fP(2)) и идентификатор
пользователя/группы (например, \fBchown\fP(2)).
.TP 
\fBIN_CLOSE_WRITE\fP (+)
Файл, открытый для записи, был закрыт.
.TP 
\fBIN_CLOSE_NOWRITE\fP (*)
Файл или каталог, не открытый для записи, был закрыт.
.TP 
\fBIN_CREATE\fP (+)
В отслеживаемом каталоге был создан файл/каталог (например, \fBopen\fP(2)
\fBO_CREAT\fP, \fBmkdir\fP(2), \fBlink\fP(2), \fBsymlink\fP(2), \fBbind\fP(2) для доменного
сокета UNIX).
.TP 
\fBIN_DELETE\fP (+)
В отслеживаемом каталоге был удалён файл/каталог.
.TP 
\fBIN_DELETE_SELF\fP
Отслеживаемый файл/каталог был удалён (это событие также возникает, если
объект перемещён в другую файловую систему, так как \fBmv\fP(1), фактически,
копирует файл в другую файловую систему и удаляет его из исходной). Также
затем будет создано событие \fBIN_IGNORED\fP для дескриптора сторожка.
.TP 
\fBIN_MODIFY\fP (+)
Файл был изменён (например, \fBwrite\fP(2), \fBtruncate\fP(2)).
.TP 
\fBIN_MOVE_SELF\fP
Отслеживаемый файл/каталог был перемещён.
.TP 
\fBIN_MOVED_FROM\fP (+)
При переименовании генерируется для каталога, содержащего старое имя файла.
.TP 
\fBIN_MOVED_TO\fP (+)
При переименовании генерируется для каталога, содержащего новое имя файла.
.TP 
\fBIN_OPEN\fP (*)
Файл или каталог был открыт.
.RE
.PP
Наблюдение inotify ведётся за inode: при наблюдении за файлом (но не когда
наблюдение ведётся за каталогом, содержащим файл) событие может
генерироваться при активности по любой ссылке на файл (находящейся в том же
или в другом каталоге).
.PP
При наблюдении за каталогом:
.IP * 3
события, помеченные звёздочкой (*), могут возникать как для самого каталога,
так и для файлов в каталоге; и
.IP *
события, помеченные знаком плюс (+), могут возникать только для объектов
внутри каталога (но не самого каталога).
.PP
\fIЗамечание\fP: при слежении за каталогом события не генерируются для файлов
каталога, если событие возникает по пути (т. е., по ссылке), который
находится вне отслеживаемого каталога.
.PP
Когда события генерируются для объектов внутри отслеживаемого каталога, поле
\fIname\fP, возвращаемое в структуре \fIinotify_event\fP, хранит имя файла внутри
этого каталога.
.PP
Макрос \fBIN_ALL_EVENTS\fP определён как битовая маска всех перечисленных выше
событий. Данный макрос можно использовать в качестве аргумента \fImask\fP в
вызове \fBinotify_add_watch\fP(2).
.PP
Дополнительно, два удобных макроса:
.RS 4
.TP 
\fBIN_MOVE\fP
То же, что и \fBIN_MOVED_FROM | IN_MOVED_TO\fP.
.TP 
\fBIN_CLOSE\fP
То же, что и \fBIN_CLOSE_WRITE | IN_CLOSE_NOWRITE\fP.
.RE
.PP
Также, при вызове \fBinotify_add_watch\fP(2) в \fImask\fP могут быть указаны
следующие биты:
.RS 4
.TP 
\fBIN_DONT_FOLLOW\fP (начиная с Linux 2.6.15)
Не разыменовывать \fIpathname\fP, если это символическая ссылка.
.TP 
\fBIN_EXCL_UNLINK\fP (начиная с Linux 2.6.36)
.\" commit 8c1934c8d70b22ca8333b216aec6c7d09fdbd6a6
По умолчанию, при слежении за событиями для потомков каталога, события
генерируются для потомков даже после того, как они будут удалены из
каталога. Это может привести к большому количеству ненужных для приложения
событий (например, если следить за \fI/tmp\fP, в котором многие приложения
создают и сразу удаляют временные файлы). Указание \fBIN_EXCL_UNLINK\fP
изменяет поведение по умолчанию, и такие события не генерируются для
потомков после удаления из отслеживаемого каталога.
.TP 
\fBIN_MASK_ADD\fP
Если экземпляр слежения уже существует для объекта файловой системы
соответствующего \fIpathname\fP, то выполнять добавление (OR) событий в \fImask\fP
к маске слежения (вместо замены маски); если также указан \fBIN_MASK_CREATE\fP,
то возвращается ошибка \fBEINVAL\fP.
.TP 
\fBIN_ONESHOT\fP
Отслеживать объект файловой системы, соответствующий \fIpathname\fP до одного
события, затем удалить объект из списка слежения.
.TP 
\fBIN_ONLYDIR\fP (начиная с Linux 2.6.15)
Следить за \fIpathname\fP, только если это каталог; если \fIpathname\fP не
является каталогом, то возвращается ошибка \fBENOTDIR\fP. Этот флаг
предоставляет приложению бессостязательный способ убедиться, что
отслеживаемый объект — каталог.
.TP 
\fBIN_MASK_CREATE\fP (начиная с Linux 4.18)
Следить за \fIpathname\fP только, если за ним никто не следит; если уже
выполняется слежение за \fIpathname\fP, то возвращается ошибка \fBEEXIST\fP.
.IP
С помощью этого флага приложение может быть уверено, что новые слежения не
изменят существующих. Это полезно, так как несколько путей могут ссылаться
на одну иноду, а несколько вызовов \fBinotify_add_watch\fP(2) без этого флага
могут затереть существующие маски слежения.
.RE
.PP
Следующие биты могут быть установлены в поле \fImask\fP при возврате из
\fBread\fP(2):
.RS 4
.TP 
\fBIN_IGNORED\fP
Слежение было снято явно (\fBinotify_rm_watch\fP(2)) или автоматически (файл
был удалён или размонтирована файловая система). Также смотрите ДЕФЕКТЫ.
.TP 
\fBIN_ISDIR\fP
Объект этого события — каталог.
.TP 
\fBIN_Q_OVERFLOW\fP
Переполнена очередь событий (для этого события значение \fIwd\fP равно \-1).
.TP 
\fBIN_UNMOUNT\fP
Файловая система, содержащая отслеживаемый объект, была
размонтирована. Также, будет сгенерировано событие \fBIN_IGNORED\fP для
дескриптора сторожка.
.RE
.SS Примеры
Предположим, приложение следит за всеми событиями для каталога \fIdir\fP и
файла \fIdir/myfile\fP. В примере ниже показаны некоторые события, которые
будут сгенерированы для этих двух объектов.
.RS 4
.TP 
fd = open("dir/myfile", O_RDWR);
Генерируется событие \fBIN_OPEN\fP и для \fIdir\fP, и для \fIdir/myfile\fP.
.TP 
read(fd, buf, count);
Генерируется событие \fBIN_ACCESS\fP и для \fIdir\fP, и для \fIdir/myfile\fP.
.TP 
write(fd, buf, count);
Генерируется событие \fBIN_MODIFY\fP и для \fIdir\fP, и для \fIdir/myfile\fP.
.TP 
fchmod(fd, mode);
Генерируется событие \fBIN_ATTRIB\fP и для \fIdir\fP, и для \fIdir/myfile\fP.
.TP 
close(fd);
Генерируется событие \fBIN_CLOSE_WRITE\fP и для \fIdir\fP, и для \fIdir/myfile\fP.
.RE
.PP
Предположим, приложение следит за всеми событиями для каталогов \fIdir1\fP и
\fIdir2\fP и файла \fIdir1/myfile\fP. В примере ниже показаны некоторые события,
которые могут быть сгенерированы.
.RS 4
.TP 
link("dir1/myfile", "dir2/new");
Генерируется событие \fBIN_ATTRIB\fP для \fImyfile\fP и событие \fBIN_CREATE\fP для
\fIdir2\fP.
.TP 
rename("dir1/myfile", "dir2/myfile");
Генерируется событие \fBIN_MOVED_FROM\fP для \fIdir1\fP, событие \fBIN_MOVED_TO\fP
для \fIdir2\fP и событие \fBIN_MOVE_SELF\fP для \fImyfile\fP. События
\fBIN_MOVED_FROM\fP и \fBIN_MOVED_TO\fP будут содержать одинаковое значение
\fIcookie\fP.
.RE
.PP
Предположим, что \fIdir1/xx\fP и \fIdir2/yy\fP только ссылки на один файл и
приложение следит за \fIdir1\fP, \fIdir2\fP, \fIdir1/xx\fP и \fIdir2/yy\fP. При
выполнение следующих вызовов в порядке, указанном ниже, будут  сгенерированы
следующие события:
.RS 4
.TP 
unlink("dir2/yy");
Генерируется событие \fBIN_ATTRIB\fP для \fIxx\fP (так как изменился его счётчик
ссылок) и событие \fBIN_DELETE\fP для \fIdir2\fP.
.TP 
unlink("dir1/xx");
Генерируется событие \fBIN_ATTRIB\fP, \fBIN_DELETE_SELF\fP и \fBIN_IGNORED\fP для
\fIxx\fP и событие \fBIN_DELETE\fP для \fIdir1\fP.
.RE
.PP
Предположим, приложение следит за каталогом \fIdir\fP и пустым каталогом
\fIdir/subdir\fP. В примере ниже показаны некоторые события, которые могут быть
сгенерированы.
.RS 4
.TP 
mkdir("dir/new", mode);
Генерируется событие \fBIN_CREATE | IN_ISDIR\fP для \fIdir\fP.
.TP 
rmdir("dir/subdir");
Генерируются события \fBIN_DELETE_SELF\fP и \fBIN_IGNORED\fP для \fIsubdir\fP и
событие \fBIN_DELETE | IN_ISDIR\fP для \fIdir\fP.
.RE
.SS "Интерфейсы в /proc"
Для ограничения потребления inotify памяти ядра, можно использовать
следующие интерфейсы:
.TP 
\fI/proc/sys/fs/inotify/max_queued_events\fP
Значение в этом файле используется когда приложение вызывает
\fBinotify_init\fP(2) для установки верхнего порога количества событий, которые
могут поместиться в очередь соответствующего экземпляра inotify. События,
превысившие это ограничение, отбрасываются, но событие \fBIN_Q_OVERFLOW\fP
генерируется всегда.
.TP 
\fI/proc/sys/fs/inotify/max_user_instances\fP
В этом файле задаётся ограничение на количество экземпляров inotify, которые
могут быть созданы для одного реального идентификатора пользователя.
.TP 
\fI/proc/sys/fs/inotify/max_user_watches\fP
В этом файле задаётся ограничение на количество сторожков, которые могут
быть созданы для одного реального идентификатора пользователя.
.SH ВЕРСИИ
Программный интерфейс inotify был добавлен в ядро Linux версии
2.6.13. Необходимые библиотечные интерфейсы добавлены в glibc версии 2.4
(\fBIN_DONT_FOLLOW\fP, \fBIN_MASK_ADD\fP и \fBIN_ONLYDIR\fP добавлены в glibc версии
2.5).
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
Программный интерфейс inotify есть только в Linux.
.SH ЗАМЕЧАНИЯ
За файловыми дескрипторами inotify можно наблюдать с помощью \fBselect\fP(2),
\fBpoll\fP(2), и \fBepoll\fP(7). Когда возникает событие, файловый дескриптор
указывает на возможность чтения.
.PP
Начиная с Linux 2.6.25, для файловых дескрипторов inotify стали доступны
уведомления ввода\-вывода посредством сигналов; смотрите обсуждение
\fBF_SETFL\fP (для установки флага \fBO_ASYNC\fP), \fBF_SETOWN\fP и \fBF_SETSIG\fP в
\fBfcntl\fP(2). Структура \fIsiginfo_t\fP (описана в \fBsigaction\fP(2)),
передаваемая обработчику сигнала, содержит следующие настройки полей: в
\fIsi_fd\fP указывается номер файлового дескриптора inotify; в \fIsi_signo\fP
указывается номер сигнала; в \fIsi_code\fP указывается \fBPOLL_IN\fP; в \fIsi_band\fP
указывается \fBPOLLIN\fP.
.PP
Если последующие события inotify, выводимые в файловый дескриптор inotify,
одинаковы (содержат одинаковые значения \fIwd\fP, \fImask\fP, \fIcookie\fP и
\fIname\fP), то они сливаются в одно событие, если самое старое событие ещё не
прочитано (но смотрите ДЕФЕКТЫ). Это сокращает требуемое количество памяти
ядра для очереди событий, но также означает, что приложение не может
использовать inotify для надёжного подсчёта файловых событий.
.PP
События, возвращаемые при чтении из файлового дескриптора inotify, формируют
упорядоченную очередь. То есть, например, это гарантирует, что при
переименовании одного каталога в другой, события в файловом дескрипторе
inotify будут созданы в правильном порядке.
.PP
Набор наблюдаемых дескрипторов, которые отслеживаются через файловый
дескриптор inotify, можно увидеть из записи для файлового дескриптора
inotify в каталоге процесса \fI/proc/[pid]/fdinfo\fP. Дополнительную информацию
смотрите в \fBproc\fP(5). Вызов \fBFIONREAD\fP \fBioctl\fP(2) возвращает количество
байт, доступных для чтения из файлового дескриптора inotify.
.SS "Ограничения и подводные камни"
Программный интерфейс inotify не предоставляет информацию о пользователе или
процессе, из\-за которого возникло событие. В частности, для процесса,
отслеживающего события через inotify, нет простого способа определить,
возникли события из\-за его действий или из\-за действий других процессов.
.PP
Inotify сообщает только о событиях, которые возникли из\-за пользовательских
программ, использовавших программный интерфейс файловой системы. То есть, не
возникает событий для файловых систем, доступных по сети (приложения должны
использовать старый метод опроса файловой системы для слежения за такими
событиями). Кроме того, различные псевдо\-файловый системы, такие как
\fI/proc\fP, \fI/sys\fP и \fI/dev/pts\fP, не отслеживаются через inotify.
.PP
Программный интерфейс inotify не сообщает о доступе и изменениях, которые
могут произойти из\-за \fBmmap\fP(2), \fBmsync\fP(2) и \fBmunmap\fP(2).
.PP
Программный интерфейс inotify в качестве идентификаторов объектов использует
имена файлов. Однако, в момент обработки приложением события inotify, имя
файла может быть уже удалено или переименовано.
.PP
Программный интерфейс inotify различает события по их дескрипторам
сторожков. Приложение само должно кэшировать сопоставление (если нужно)
дескрипторов сторожков и имён. Имейте в виду, что переименование каталога
может повлиять на несколько кэшированных путей.
.PP
Отслеживание каталогов через inotify ведётся не рекурсивно: чтобы
отслеживать подкаталоги, нужно создать дополнительные сторожки. Это может
занять много времени при большом дереве каталога.
.PP
Если отслеживается полное дерево каталога и создаётся новый каталог в этом
дереве или существующий каталог переименовывается в этом дереве, учтите, что
на момент создания сторожка за новым подкаталогом, в подкаталоге могут уже
существовать новые файлы (и подкаталоги). Поэтому вам может потребоваться
сканировать содержимое подкаталога сразу после добавления сторожка (и, если
нужно, рекурсивно добавить сторожки для всех подкаталогов, которые в нём
есть).
.PP
Заметим, что очередь событий может переполниться. В этом случае события
теряются. Корректные приложения должны учитывать возможность пропажи
событий. Например, может потребоваться перестроить часть или весь кэш
приложения (один простой, но, возможно, затратный способ, это закрыть
файловый дескриптор inotify, опустошить кэш, создать новый файловый
дескриптор inotify и затем пересоздать сторожки и записи в кэше для
отслеживаемых объектов).
.PP
.\"
Если файловая система смонтирована поверх отслеживаемого каталога, то
событие не генерируются, а также не генерируются события для объектов,
находящихся в новой точке монтирования на первом уровне. Если в дальнейшем
файловая система отмонтируется, то события начнут генерироваться для
каталога и содержащихся в нём объектов.
.SS "Работа с событиями rename()"
Как указывалось выше, из событий \fBIN_MOVED_FROM\fP и \fBIN_MOVED_TO\fP,
генерируемых \fBrename\fP(2), можно определить пару по их одинаковому значению
cookie. Однако, с этой задачей есть несколько проблем.
.PP
Эти два события, обычно, стоят друг за другом в потоке событий, если читать
из файлового дескриптора inotify. Однако, это не гарантируется. Если
несколько процессов создают события для отслеживаемых объектов, то (в редких
случаях) произвольное количество других событий может появиться между
событиями \fBIN_MOVED_FROM\fP и \fBIN_MOVED_TO\fP. Кроме того, не гарантируется,
что пара событий вставляется в очередь атомарно: может существовать короткий
интервал, в котором \fBIN_MOVED_FROM\fP уже появилось, а \fBIN_MOVED_TO\fP ещё
нет.
.PP
Соответствие \fBIN_MOVED_FROM\fP и \fBIN_MOVED_TO\fP паре событий, сгенерированных
\fBrename\fP(2), по сути, просто (не забудьте, что если объект
переименовывается вне отслеживаемого каталога, то может не быть даже события
\fBIN_MOVED_TO\fP). Можно использовать эвристические предположения (например,
что события всегда следуют друг за другом), что работает в большинстве
случаев, но неминуемо не сработает в некоторых случаях, в которых приложение
посчитает события \fBIN_MOVED_FROM\fP и \fBIN_MOVED_TO\fP несвязными. Если в
результате дескрипторы сторожков будут уничтожены и пересозданы, то такие
дескрипторы будут несогласованны с дескрипторами сторожков для любых
ожидающих событий (пересоздание файлового дескриптора inotify и пересборка
кэша может быть полезна в этом случае).
.PP
Также приложения должны учитывать возможность того, что событие
\fBIN_MOVED_FROM\fP — последнее событие, которое попало в буфер, возвращаемый
текущим вызовом \fBread\fP(2), и сопутствующее событие \fBIN_MOVED_TO\fP может
быть получено только при следующем чтении \fBread\fP(2), которое должно быть
выполнено с (коротким) промежутком, позволяющим фактическую не атомарную
вставку пары событий \fBIN_MOVED_FROM\fP\-\fBIN_MOVED_TO\fP, и также возможность
того, что может отсутствовать событие \fBIN_MOVED_TO\fP.
.SH ДЕФЕКТЫ
.\" commit 820c12d5d6c0890bc93dd63893924a13041fdc35
До Linux 3.19, \fBfallocate\fP(2) не создавал события inotify. Начиная с Linux
3.19, вызов \fBfallocate\fP(2) генерирует событие \fBIN_MODIFY\fP.
.PP
.\" FIXME . kernel commit 611da04f7a31b2208e838be55a42c7a1310ae321
.\" implies that unmount events were buggy 2.6.11 to 2.6.36
.\"
В ядрах до 2.6.16 флаг \fBIN_ONESHOT\fP в \fImask\fP не работает.
.PP
В первоначальной задумке и реализации флаг \fBIN_ONESHOT\fP не приводил к
генерации события \fBIN_IGNORED\fP, если наблюдение отменялось после одного
события. Однако, как непреднамеренный эффект других изменений, начиная с
Linux 2.6.36, событие \fBIN_IGNORED\fP в этом случае генерируется.
.PP
.\" commit 1c17d18e3775485bf1e0ce79575eb637a94494a2
До ядра версии 2.6.25, код ядра, который отвечал за объединение последующих
одинаковых событий (т. е., два самых новых события могли быть объединены,
если старое событие ещё не было прочитано), вместо этого проверял, можно ли
объединить самое новое событие с \fIсамым старым\fP непрочитанным событием.
.PP
.\" FIXME . https://bugzilla.kernel.org/show_bug.cgi?id=77111
Когда дескриптор сторожка удаляется вызовом \fBinotify_rm_watch\fP(2) (или
из\-за удаления отслеживаемого файла, или размонтирования содержащей его
файловой системы), все ожидающие непрочитанные события для этого дескриптора
сторожка остаются доступными для чтения. Так как дескрипторы сторожков в
дальнейшем циклически выделяются \fBinotify_add_watch\fP(2), ядро поступательно
проходит через диапазон возможных дескрипторов сторожков (от 0 до
\fBINT_MAX\fP). При выделении свободного дескриптора сторожка для выбранного
номера не производится проверка того, есть ли какие\-то ожидающие
непрочитанные события в очереди inotify с таким номером или нет. То есть
может случиться так, что дескриптор сторожка выделяется повторно даже когда
существуют ожидающие непрочитанные события, оставшиеся от предыдущего
выделения дескриптора сторожка с тем же номером; в результате приложение
может прочесть эти события и посчитать их как принадлежащие файлу,
связанному с новым повторно задействованным дескриптором сторожка. На
практике, вероятность столкновения с этой ошибкой может быть чрезвычайно
низка, так как для этого требуется, чтобы приложения циклически перебрало
все \fBINT_MAX\fP дескрипторов сторожков, освободило дескриптор сторожка и
оставило непрочитанные события этого дескриптора сторожка в очереди, а затем
повторно задействовало этот дескриптор сторожка. По этой причине и из\-за
того, что ещё никто не сообщал об этой ошибке в реальности, на момент
актуальности Linux 3.15, в ядре ничего не было сделано для того, чтобы
устранить этот дефект.
.SH ПРИМЕР
Следующая программа демонстрирует использование программного интерфейса
inotify. Она помечает каталоги, переданной в аргументах командной строки, и
ждёт событий с типом \fBIN_OPEN\fP, \fBIN_CLOSE_NOWRITE\fP и \fBIN_CLOSE_WRITE\fP.
.PP
Следующий вывод был записан при редактировании файла \fI/home/user/temp/foo\fP
и просмотра каталога \fI/tmp\fP. Перед открытием файла и каталога произошли
события \fBIN_OPEN\fP. После закрытия файла произошло событие
\fBIN_CLOSE_WRITE\fP. После закрытия каталога произошло событие
\fBIN_CLOSE_NOWRITE\fP. Выполнение программы закончилось после нажатия
пользователем клавиши ENTER.
.SS "Пример вывода"
.in +4n
.EX
$ \fB./a.out /tmp /home/user/temp\fP
Нажмите ENTER для завершения работы.
Ожидание событий.
IN_OPEN: /home/user/temp/foo [файл]
IN_CLOSE_WRITE: /home/user/temp/foo [файл]
IN_OPEN: /tmp/ [каталог]
IN_CLOSE_NOWRITE: /tmp/ [каталог]

Ожидание событий прекращено.
.EE
.in
.SS "Исходный код программы"
\&
.EX
#include <errno.h>
#include <poll.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/inotify.h>
#include <unistd.h>

/* Читаем все доступные события из файлового дескриптора «fd».
   wd — таблица дескрипторов сторожков для каталогов из argv.
   argc — длина wd и argv.
   argv — список наблюдаемых каталогов.
   Элемент 0 в wd и argv не используется. */

static void
handle_events(int fd, int *wd, int argc, char* argv[])
{
    /* В некоторых системах невозможно прочитать целые переменные, если
       они неправильно выровнены. В других системах некорректное
       выравнивание может снижать производительность. Таким образом, буфер,
       используемый для чтения из файлового дескриптора inotify, должен быть
       выровнен также как структура struct inotify_event. */

    char buf[4096]
        __attribute__ ((aligned(__alignof__(struct inotify_event))));
    const struct inotify_event *event;
    int i;
    ssize_t len;
    char *ptr;

    /* проходим по всем событиям, которые можем прочитать
       из файлового дескриптора inotify */

    for (;;) {

        /* читаем несколько событий */

        len = read(fd, buf, sizeof buf);
        if (len == \-1 && errno != EAGAIN) {
            perror("read");
            exit(EXIT_FAILURE);
        }

        /* Если неблокирующий read() не найдёт событий для чтения, то
           вернёт \-1 с errno равным EAGAIN. В этом случае
           выходим из цикла. */

        if (len <= 0)
            break;

        /* проходим по всем событиям в буфере */

        for (ptr = buf; ptr < buf + len;
                ptr += sizeof(struct inotify_event) + event\->len) {

            event = (const struct inotify_event *) ptr;

            /* печатаем тип события */

            if (event\->mask & IN_OPEN)
                printf("IN_OPEN: ");
            if (event\->mask & IN_CLOSE_NOWRITE)
                printf("IN_CLOSE_NOWRITE: ");
            if (event\->mask & IN_CLOSE_WRITE)
                printf("IN_CLOSE_WRITE: ");

            /* печатаем имя наблюдаемого каталога */

            for (i = 1; i < argc; ++i) {
                if (wd[i] == event\->wd) {
                    printf("%s/", argv[i]);
                    break;
                }
            }

            /* печатаем имя файла */

            if (event\->len)
                printf("%s", event\->name);

            /* печатаем тип объекта файловой системы */

            if (event\->mask & IN_ISDIR)
                printf(" [каталог]\en");
            else
                printf(" [файл]\en");
        }
    }
}

int
main(int argc, char* argv[])
{
    char buf;
    int fd, i, poll_num;
    int *wd;
    nfds_t nfds;
    struct pollfd fds[2];

    if (argc < 2) {
        printf("Использование: %s ПУТЬ [ПУТЬ …]\en", argv[0]);
        exit(EXIT_FAILURE);
    }

    printf("Нажмите ENTER для завершения работы.\en");

    /* Создаём файловый дескриптор для доступа к inotify API */

    fd = inotify_init1(IN_NONBLOCK);
    if (fd == \-1) {
        perror("inotify_init1");
        exit(EXIT_FAILURE);
    }

    /* выделяем память под дескрипторы сторожков */

    wd = calloc(argc, sizeof(int));
    if (wd == NULL) {
        perror("calloc");
        exit(EXIT_FAILURE);
    }

    /* помечаем каталоги для событий
       \- файл был открыт
       \- файл был закрыт */

    for (i = 1; i < argc; i++) {
        wd[i] = inotify_add_watch(fd, argv[i],
                                  IN_OPEN | IN_CLOSE);
        if (wd[i] == \-1) {
            fprintf(stderr, "Невозможно пронаблюдать '%s'\en", argv[i]);
            perror("inotify_add_watch");
            exit(EXIT_FAILURE);
        }
    }

    /* подготовка к опросу */

    nfds = 2;

    /* ввод с консоли  */

    fds[0].fd = STDIN_FILENO;
    fds[0].events = POLLIN;

    /* ввод inotify */

    fds[1].fd = fd;
    fds[1].events = POLLIN;

    /* ждём события и/или ввода с терминала */

    printf("Ожидание событий.\en");
    while (1) {
        poll_num = poll(fds, nfds, \-1);
        if (poll_num == \-1) {
            if (errno == EINTR)
                continue;
            perror("poll");
            exit(EXIT_FAILURE);
        }

        if (poll_num > 0) {

            if (fds[0].revents & POLLIN) {

                /* доступен ввод с консоли: опустошаем stdin и выходим */

                while (read(STDIN_FILENO, &buf, 1) > 0 && buf != '\en')
                    continue;
                break;
            }

            if (fds[1].revents & POLLIN) {

                /* доступны события inotify */

                handle_events(fd, wd, argc, argv);
            }
        }
    }

    printf("Ожидание событий прекращено.\en");

    /* закрываем файловый дескриптор inotify */

    close(fd);

    free(wd);
    exit(EXIT_SUCCESS);
}
.EE
.SH "СМОТРИТЕ ТАКЖЕ"
\fBinotifywait\fP(1), \fBinotifywatch\fP(1), \fBinotify_add_watch\fP(2),
\fBinotify_init\fP(2), \fBinotify_init1\fP(2), \fBinotify_rm_watch\fP(2), \fBread\fP(2),
\fBstat\fP(2), \fBfanotify\fP(7)
.PP
Файл \fIDocumentation/filesystems/inotify.txt\fP в дереве исходного кода ядра
Linux
