.\" -*- mode: troff; coding: UTF-8 -*-
.\" Copyright (c) 2002 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"
.\" 6 Aug 2002 - Initial Creation
.\" Modified 2003-05-23, Michael Kerrisk, <mtk.manpages@gmail.com>
.\" Modified 2004-05-27, Michael Kerrisk, <mtk.manpages@gmail.com>
.\" 2004-12-08, mtk Added O_NOATIME for CAP_FOWNER
.\" 2005-08-16, mtk, Added CAP_AUDIT_CONTROL and CAP_AUDIT_WRITE
.\" 2008-07-15, Serge Hallyn <serue@us.bbm.com>
.\"     Document file capabilities, per-process capability
.\"     bounding set, changed semantics for CAP_SETPCAP,
.\"     and other changes in 2.6.2[45].
.\"     Add CAP_MAC_ADMIN, CAP_MAC_OVERRIDE, CAP_SETFCAP.
.\" 2008-07-15, mtk
.\"     Add text describing circumstances in which CAP_SETPCAP
.\"     (theoretically) permits a thread to change the
.\"     capability sets of another thread.
.\"     Add section describing rules for programmatically
.\"     adjusting thread capability sets.
.\"     Describe rationale for capability bounding set.
.\"     Document "securebits" flags.
.\"     Add text noting that if we set the effective flag for one file
.\"     capability, then we must also set the effective flag for all
.\"     other capabilities where the permitted or inheritable bit is set.
.\" 2011-09-07, mtk/Serge hallyn: Add CAP_SYSLOG
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH CAPABILITIES 7 2019\-08\-02 Linux "Руководство программиста Linux"
.SH ИМЯ
capabilities \- обзор мандатов Linux
.SH ОПИСАНИЕ
Для выполнения проверки прав доступа в обычных реализациях UNIX процессы
разделяют на две категории: \fIпривилегированные\fP (ID эффективного
пользователя равен 0, как у суперпользователя или root), и \fIне
привилегированные\fP (ID эффективного пользователя не равен нулю). Для
привилегированных процессов все проверки прав в ядре не выполняются, а для
не привилегированных процессов выполняется полная проверка на основе
мандатов процесса (обычно, эффективного UID, эффективного GID и списка
дополнительных групп).
.PP
.\"
В ядре Linux начиная с версии 2.2, все привилегии, обычно связываемые с
суперпользователем, разделены на несколько частей, называемых \fIмандатами\fP
(capabilities), которые можно разрешать и запрещать независимо друг от
друга. Мандаты являются атрибутом нити.
.SS "Список мандатов"
В следующим списке показаны мандаты, реализованные в Linux, а также операции
или поведение, которые эти мандаты разрешают:
.TP 
\fBCAP_AUDIT_CONTROL\fP (начиная с Linux 2.6.11)
Позволяет включать или выключать аудит ядра; изменять фильтрующие правила
аудита; получать состояние аудита и фильтрующие правила.
.TP 
\fBCAP_AUDIT_READ\fP (начиная с Linux 3.16)
.\" commit a29b694aa1739f9d76538e34ae25524f9c549d59
.\" commit 3a101b8de0d39403b2c7e5c23fd0b005668acf48
Позволяет читать протокол аудита через многоадресный сокет netlink.
.TP 
\fBCAP_AUDIT_WRITE\fP (начиная с Linux 2.6.11)
.\" FIXME Add FAN_ENABLE_AUDIT
Позволяет записывать данные в журнал аудита ядра.
.TP 
\fBCAP_BLOCK_SUSPEND\fP (начиная с Linux 3.5)
Позволяет использовать возможности, которые могут приводить к блокированию
приостановки системы (\fBepoll\fP(7)  \fBEPOLLWAKEUP\fP, \fI/proc/sys/wake_lock\fP).
.TP 
\fBCAP_CHOWN\fP
Позволяет выполнять произвольные изменения файловых UID и GID (смотрите
\fBchown\fP(2)).
.TP 
\fBCAP_DAC_OVERRIDE\fP
Позволяет пропускать проверки доступа к файлу на чтение, запись и выполнение
(DAC (discretionary access control) — избирательный контроль доступа).
.TP 
\fBCAP_DAC_READ_SEARCH\fP
.PD 0
.RS
.IP * 2
Позволяет пропускать проверки доступа к файлу на чтение и доступа к каталогу
на чтение и выполнение;
.IP *
Позволяет вызывать \fBopen_by_handle_at\fP(2);
.IP *
Позволяет использовать \fBlinkat\fP(2) с флагом \fBAT_EMPTY_PATH\fP для создания
ссылки на файл, заданным файловым дескриптором.
.RE
.PD
.TP 
\fBCAP_FOWNER\fP
.PD 0
.RS
.IP * 2
Позволяет пропускать проверки доступа для операций, которые обычно требуют
совпадения UID файловой системы процесса и UID файла (например, \fBchmod\fP(2),
\fButime\fP(2)), исключая операции, охватываемые \fBCAP_DAC_OVERRIDE\fP и
\fBCAP_DAC_READ_SEARCH\fP;
.IP *
Позволяет изменять флаги иноды (смотрите \fBioctl_iflags\fP(2)) у произвольных
файлов;
.IP *
Позволяет устанавливать списки контроля доступа (ACL) произвольных файлов;
.IP *
Позволяет игнорировать закрепляющий бит при удалении файла;
.IP *
Позволяет изменять расширенные \fIпользовательские\fP атрибуты закреплённого
каталога, принадлежащего любому пользователю;
.IP *
Позволяет задавать \fBO_NOATIME\fP для произвольных файлов в \fBopen\fP(2) и
\fBfcntl\fP(2).
.RE
.PD
.TP 
\fBCAP_FSETID\fP
.PD 0
.RS
.IP * 2
Позволяет не очищать биты режима set\-user\-ID и set\-group\-ID при изменении
файла;
.IP *
Позволяет устанавливать бит set\-group\-ID на файл, у которого GID не
совпадает с битом файловой системы или любыми дополнительными GID
вызывающего процесса.
.RE
.PD
.TP 
\fBCAP_IPC_LOCK\fP
.\" FIXME . As at Linux 3.2, there are some strange uses of this capability
.\" in other places; they probably should be replaced with something else.
Позволяет блокировать память (\fBmlock\fP(2), \fBmlockall\fP(2), \fBmmap\fP(2),
\fBshmctl\fP(2)).
.TP 
\fBCAP_IPC_OWNER\fP
Позволяет не выполнять проверки доступа для операций с объектами System V
IPC.
.TP 
\fBCAP_KILL\fP
.\" FIXME . CAP_KILL also has an effect for threads + setting child
.\"       termination signal to other than SIGCHLD: without this
.\"       capability, the termination signal reverts to SIGCHLD
.\"       if the child does an exec().  What is the rationale
.\"       for this?
Позволяет не выполнять проверки при отправке сигналов (смотрите
\fBkill\fP(2)). Сюда относится использование \fBioctl\fP(2) с операцией
\fBKDSIGACCEPT\fP.
.TP 
\fBCAP_LEASE\fP (начиная с Linux 2.4)
Позволяет устанавливать аренду на произвольные файлы (смотрите \fBfcntl\fP(2)).
.TP 
\fBCAP_LINUX_IMMUTABLE\fP
Позволяет устанавливать флаги иноды \fBFS_APPEND_FL\fP и \fBFS_IMMUTABLE_FL\fP
(смотрите \fBioctl_iflags\fP(2)).
.TP 
\fBCAP_MAC_ADMIN\fP (начиная с Linux 2.6.25)
Разрешает изменять настройку MAC или состояние. Реализован в Smack Linux
Security Module (LSM).
.TP 
\fBCAP_MAC_OVERRIDE\fP (начиная с Linux 2.6.25)
Позволяет замещать мандатный контроль доступа (MAC). Реализован в Smack LSM.
.TP 
\fBCAP_MKNOD\fP (начиная с Linux 2.4)
Позволяет создавать специальные файлы с помощью \fBmknod\fP(2).
.TP 
\fBCAP_NET_ADMIN\fP
Позволяет выполнять различные сетевые операции:
.PD 0
.RS
.IP * 2
настройку интерфейса;
.IP *
управление IP МЭ, трансляцией адресов и ведением учёта;
.IP *
изменять таблицы маршрутизации;
.IP *
привязываться к любому адресу для прозрачного проксирования;
.IP *
назначать тип сервиса (TOS)
.IP *
очищать статистику драйвера;
.IP *
включать режим захвата (promiscuous);
.IP *
включать многоадресные рассылки (multicasting);
.IP *
использовать \fBsetsockopt\fP(2) для включения следующих параметров сокета:
\fBSO_DEBUG\fP, \fBSO_MARK\fP, \fBSO_PRIORITY\fP (для приоритетов вне диапазона 0 \-
6), \fBSO_RCVBUFFORCE\fP и \fBSO_SNDBUFFORCE\fP.
.RE
.PD
.TP 
\fBCAP_NET_BIND_SERVICE\fP
Позволяет привязывать сокет к привилегированным портам домена интернета
(номера портов меньше 1024).
.TP 
\fBCAP_NET_BROADCAST\fP
.\" FIXME Since Linux 4.2, there are use cases for netlink sockets
.\"    commit 59324cf35aba5336b611074028777838a963d03b
(не используется) Позволяет осуществлять широковещание с сокета и
прослушивание многоадресных рассылок.
.TP 
\fBCAP_NET_RAW\fP
.PD 0
.RS
.IP * 2
Позволяет использовать сокеты RAW и PACKET;
.IP *
позволяет привязываться к любому адресу для прозрачного проксирования.
.RE
.PD
.\" Also various IP options and setsockopt(SO_BINDTODEVICE)
.TP 
\fBCAP_SETGID\fP
.RS
.PD 0
.IP * 2
Позволяет выполнять произвольные действия с GID процесса и списком
дополнительных GID;
.IP *
Позволяет подделывать GID при передаче мандатов сокета через доменные сокеты
UNIX;
.IP *
Позволяет записывать отображение идентификатора группы в пользовательское
пространство (смотрите \fBuser_namespaces\fP(7)).
.PD
.RE
.TP 
\fBCAP_SETFCAP\fP (начиная с Linux 2.6.24)
Устанавливает произвольные мандаты на файл.
.TP 
\fBCAP_SETPCAP\fP
Если файловые мандаты поддерживаются (т. е., начиная с Linux 2.6.24):
позволяет добавлять любой мандат из ограничивающего набора вызывающей нити в
её наследуемый набор; отзывать мандаты из ограничивающего набора (с помощью
\fBprctl\fP(2) с операцией \fBPR_CAPBSET_DROP\fP); изменять флаги \fIsecurebits\fP.
.IP
Если файловые мандаты не поддерживаются (т. е., до Linux 2.6.24): позволяет
предоставлять и отзывать любой мандат в списке разрешённых мандатов
вызывающего или любого другого процесса (это свойство \fBCAP_SETPCAP\fP
недоступно, если ядро собрано с поддержкой файловых мандатов, так как
\fBCAP_SETPCAP\fP имеет полностью другую семантику у таких ядер).
.TP 
\fBCAP_SETUID\fP
.RS
.PD 0
.IP * 2
Позволяет выполнять произвольные действия с UID процесса (\fBsetuid\fP(2),
\fBsetreuid\fP(2), \fBsetresuid\fP(2), \fBsetfsuid\fP(2));
.IP *
Позволяет подделывать UID при передаче мандатов сокета через доменные сокеты
UNIX;
.IP *
Позволяет записывать отображение идентификатора пользователя в
пользовательское пространство (смотрите \fBuser_namespaces\fP(7)).
.PD
.RE
.\" FIXME CAP_SETUID also an effect in exec(); document this.
.TP 
\fBCAP_SYS_ADMIN\fP
\fIЗамечание\fP: данный мандат перегружен; смотрите \fIЗамечания разработчикам
ядра\fP ниже.
.IP
.PD 0
.RS
.IP * 2
Позволяет выполнять следующие задачи управления системой: \fBquotactl\fP(2),
\fBmount\fP(2), \fBumount\fP(2), \fBpivot_root\fP(2), \fBswapon\fP(2), \fBswapoff\fP(2),
\fBsethostname\fP(2), and \fBsetdomainname\fP(2);
.IP *
Позволяет выполнять привилегированные операции \fBsyslog\fP(2) (начиная с Linux
2.6.37, для этих операций нужно использовать \fBCAP_SYSLOG\fP);
.IP *
Позволяет выполнять команду \fBVM86_REQUEST_IRQ\fP \fBvm86\fP(2);
.IP *
Позволяет выполнять операции \fBIPC_SET\fP и \fBIPC_RMID\fP над произвольными
объектами System V IPC;
.IP *
Позволяет перезаписывать ограничение ресурса \fBRLIMIT_NPROC\fP;
.IP *
Позволяет выполнять операции над расширенными атрибутами \fItrusted\fP и
\fIsecurity\fP (смотрите \fBxattr\fP(7));
.IP *
Позволяет использовать \fBlookup_dcookie\fP(2);
.IP *
Позволяет использовать \fBioprio_set\fP(2) для назначения классов планирования
ввода\-вывода \fBIOPRIO_CLASS_RT\fP и (до Linux 2.6.25) \fBIOPRIO_CLASS_IDLE\fP;
.IP *
Позволяет подделывать PID при передаче мандатов сокета через доменные сокеты
UNIX;
.IP *
Позволяет превышать \fI/proc/sys/fs/file\-max\fP, системное ограничение на
количество открытых файлов, в системных вызовах, открывающих файлы
(например, \fBaccept\fP(2), \fBexecve\fP(2), \fBopen\fP(2), \fBpipe\fP(2));
.IP *
Позволяет задействовать флаги \fBCLONE_*\fP, которые создают новые пространства
имён с помощью \fBclone\fP(2) и \fBunshare\fP(2)) (начиная с Linux 3.8 для
создания пользовательских пространств имён больше никаких мандатов не
требуется);
.IP *
Позволяет вызывать \fBperf_event_open\fP(2);
.IP *
Позволяет получать доступ к информации о привилегированном событии \fIperf\fP;
.IP *
Позволяет вызывать \fBsetns\fP(2) (требуется \fBCAP_SYS_ADMIN\fP в пространстве
имён \fIназначения\fP);
.IP *
Позволяет вызывать \fBfanotify_init\fP(2);
.IP *
Позволяет вызывать \fBbpf\fP(2);
.IP *
Позволяет выполнять привилегированные операции \fBKEYCTL_CHOWN\fP и
\fBKEYCTL_SETPERM\fP в \fBkeyctl\fP(2);
.IP *
Позволяет выполнять операцию \fBMADV_HWPOISON\fP в \fBmadvise\fP(2);
.IP *
Позволяет задействовать \fBTIOCSTI\fP в \fBioctl\fP(2) для вставки символов во
входную очередь терминала, отличного от управляющего терминала вызывающего;
.IP *
Позволяет задействовать устаревший системный вызов \fBnfsservctl\fP(2);
.IP *
Позволяет задействовать устаревший системный вызов \fBbdflush\fP(2);
.IP *
Позволяет выполнять различные привилегированные операции \fBioctl\fP(2) над
блочными устройствами;
.IP *
Позволяет выполнять различные привилегированные операции \fBioctl\fP(2) над
файловой системой;
.IP *
Позволяет выполнять привилегированные операции \fBioctl\fP(2) над устройством
\fI/dev/random\fP (смотрите \fBrandom\fP(4));
.IP *
Позволяет устанавливать фильтры \fBseccomp\fP(2) без начальной установки
атрибута нити \fIno_new_privs\fP;
.IP *
Позволяет изменять правила разрешения/запрета для групп управления
устройствами;
.IP *
Позволяет задействовать операцию \fBptrace\fP(2) \fBPTRACE_SECCOMP_GET_FILTER\fP
для получения дампа фильтров seccomp трассируемого;
.IP *
Позволяет задействовать операцию \fBptrace\fP(2) \fBPTRACE_SETOPTIONS\fP для
приостановки защиты seccomp трассируемого (т. е., флаг
\fBPTRACE_O_SUSPEND_SECCOMP\fP);
.IP *
Позволяет выполнять административные операции над многими драйверами
устройств.
.IP *
Позволяет изменять значения уступчивости автогруппы, посредством записи в
\fI/proc/[pid]/autogroup\fP (смотрите \fBsched\fP(7)).
.RE
.PD
.TP 
\fBCAP_SYS_BOOT\fP
Позволяет использовать \fBreboot\fP(2) и \fBkexec_load\fP(2).
.TP 
\fBCAP_SYS_CHROOT\fP
.RS
.PD 0
.IP * 2
Позволяет использовать \fBchroot\fP(2);
.IP *
Позволяет изменять пространство имён монтирования с помощью \fBsetns\fP(2).
.PD
.RE
.TP 
\fBCAP_SYS_MODULE\fP
.RS
.PD 0
.IP * 2
Позволяет загружать и выгружать модули ядра (смотрите \fBinit_module\fP(2) и
\fBdelete_module\fP(2));
.IP *
В ядрах до версии 2.6.25: позволяет отзывать мандаты из системного
ограничивающего набора мандатов.
.PD
.RE
.TP 
\fBCAP_SYS_NICE\fP
.PD 0
.RS
.IP * 2
Позволяет повышать значение уступчивости процесса (\fBnice\fP(2),
\fBsetpriority\fP(2)) и изменять значение уступчивости у произвольных
процессов;
.IP *
Позволяет назначать политики планирования реального времени для вызывающего
процесса и назначать политики планирования и приоритеты для произвольных
процессов (\fBsched_setscheduler\fP(2), \fBsched_setparam\fP(2),
\fBsched_setattr\fP(2));
.IP *
Позволяет выполнять привязку к ЦП для произвольных процессов
(\fBsched_setaffinity\fP(2));
.IP *
Позволяет назначать класс планирования ввода\-вывода и приоритет для
произвольных процессов (\fBioprio_set\fP(2));
.IP *
.\" FIXME CAP_SYS_NICE also has the following effect for
.\" migrate_pages(2):
.\"     do_migrate_pages(mm, &old, &new,
.\"         capable(CAP_SYS_NICE) ? MPOL_MF_MOVE_ALL : MPOL_MF_MOVE);
.\"
.\" Document this.
Позволяет применять \fBmigrate_pages\fP(2) к произвольным процессам для их
перемещения на произвольные узлы;
.IP *
Позволяет применять \fBmove_pages\fP(2) к произвольным процессам;
.IP *
Позволяет использовать флаг \fBMPOL_MF_MOVE_ALL\fP в \fBmbind\fP(2) и
\fBmove_pages\fP(2).
.RE
.PD
.TP 
\fBCAP_SYS_PACCT\fP
Позволяет использовать \fBacct\fP(2).
.TP 
\fBCAP_SYS_PTRACE\fP
.PD 0
.RS
.IP * 2
Позволяет трассировать любой процесс с помощью \fBptrace\fP(2);
.IP *
Позволяет применять \fBget_robust_list\fP(2) к произвольным процессам;
.IP *
Позволяет перемещать данные в/из памяти произвольного процесса с помощью
\fBprocess_vm_readv\fP(2) и \fBprocess_vm_writev\fP(2);
.IP *
Позволяет изучать процессы с помощью \fBkcmp\fP(2).
.RE
.PD
.TP 
\fBCAP_SYS_RAWIO\fP
.PD 0
.RS
.IP * 2
Позволяет выполнять операции ввода\-вывода из портов (\fBiopl\fP(2) и
\fBioperm\fP(2));
.IP *
Разрешает доступ к \fI/proc/kcore\fP;
.IP *
Позволяет задействовать операцию \fBFIBMAP\fP в \fBioctl\fP(2);
.IP *
Позволяет открывать устройства для доступа к специальным регистрам x86 (MSR,
смотрите \fBmsr\fP(4));
.IP *
Позволяет обновлять \fI/proc/sys/vm/mmap_min_addr\fP;
.IP *
Позволяет создавать отображения памяти по адресам меньше значения, заданного
в \fI/proc/sys/vm/mmap_min_addr\fP;
.IP *
Позволяет отображать файлы в \fI/proc/bus/pci\fP;
.IP *
Позволяет открывать \fI/dev/mem\fP и \fI/dev/kmem\fP;
.IP *
Позволяет выполнять различные команды устройств SCSI;
.IP *
Позволяет выполнять определённые операции с устройствами \fBhpsa\fP(4) и
\fBcciss\fP(4);
.IP *
Позволяет выполнять некоторые специальные операции с другими устройствами.
.RE
.PD
.TP 
\fBCAP_SYS_RESOURCE\fP
.PD 0
.RS
.IP * 2
Позволяет использовать зарезервированное пространство файловых систем ext2;
.IP *
Позволяет делать вызовы \fBioctl\fP(2), управляющие журналированием ext3;
.IP *
Позволяет превышать ограничение дисковой квоты;
.IP *
Позволяет увеличивать ограничения по ресурсам (смотрите \fBsetrlimit\fP(2));
.IP *
Позволяет перезаписывать ограничение ресурса \fBRLIMIT_NPROC\fP;
.IP *
Позволяет превышать максимальное количество консолей при выделении консоли;
.IP *
Позволяет превышать максимальное количество раскладок;
.IP *
Позволяет использовать более чем 64hz прерывания из часов реального времени;
.IP *
Позволяет назначать значение \fImsg_qbytes\fP очереди сообщений System V больше
ограничения \fI/proc/sys/kernel/msgmnb\fP (смотрите \fBmsgop\fP(2) и
\fBmsgctl\fP(2));
.IP *
Позволяет обходить ограничитель ресурса \fBRLIMIT_NOFILE\fP для файловых
дескрипторов, находящихся в процессе передачи («в полёте», in\-flight), когда
файловые дескрипторы передаются в другой процесс через доменный сокет UNIX
(смотрите \fBunix\fP(7));
.IP *
Позволяет превышать ограничение \fI/proc/sys/fs/pipe\-size\-max\fP при назначении
вместимости канала с помощью команды \fBF_SETPIPE_SZ\fP у \fBfcntl\fP(2).
.IP *
Позволяет использовать \fBF_SETPIPE_SZ\fP для увеличения вместимости канала
больше чем ограничение, задаваемое в \fI/proc/sys/fs/pipe\-max\-size\fP;
.IP *
Позволяет превышать ограничение \fI/proc/sys/fs/mqueue/queues_max\fP при
создании очередей сообщений POSIX (смотрите \fBmq_overview\fP(7));
.IP *
Позволяет задействовать операцию \fBprctl\fP(2) \fBPR_SET_MM\fP();
.IP *
Позволяет устанавливать \fI/proc/[pid]/oom_score_adj\fP в значение меньшее, чем
последнее установленное значение процессом с помощью \fBCAP_SYS_RESOURCE\fP.
.RE
.PD
.TP 
\fBCAP_SYS_TIME\fP
Позволяет настраивать системные часы (\fBsettimeofday\fP(2), \fBstime\fP(2),
\fBadjtimex\fP(2)) и часы реального времени (аппаратные).
.TP 
\fBCAP_SYS_TTY_CONFIG\fP
Позволяет использовать \fBvhangup\fP(2); задействовать различные
привилегированные операции \fBioctl\fP(2) с виртуальными терминалами.
.TP 
\fBCAP_SYSLOG\fP (начиная с Linux 2.6.37)
.RS
.PD 0
.IP * 2
Позволяет выполнять привилегированные операции \fBsyslog\fP(2). Смотрите в
\fBsyslog\fP(2) какие операции требуют прав.
.IP *
Позволяет просматривать адреса ядра, показываемые в \fI/proc\fP и других
интерфейсах, когда значение \fI/proc/sys/kernel/kptr_restrict\fP равно 1
(смотрите описание \fIkptr_restrict\fP в \fBproc\fP(5)).
.PD
.RE
.TP 
\fBCAP_WAKE_ALARM\fP (начиная с Linux 3.0)
.\"
Позволяет вызывать что\-либо при пробуждении системы (устанавливать таймеры
\fBCLOCK_REALTIME_ALARM\fP и \fBCLOCK_BOOTTIME_ALARM\fP).
.SS "Старая и текущая реализации"
Для полной реализации мандатов требуется:
.IP 1. 3
Для всех привилегированных операций ядро должно проверять, имеет ли нить
требуемый мандат в его эффективном наборе.
.IP 2.
Ядро должно предоставлять системные вызовы, позволяющие получать и изменять
наборы мандатов нити.
.IP 3.
Файловая система должна поддерживать присоединение мандатов к исполняемому
файлу для того, чтобы при исполнении файла у процесса повышались права
согласно этим мандатам.
.PP
.\"
До ядра версии 2.6.24 были реализованы только первые два пункта; начиная с
версии 2.6.24 реализованы все три пункта.
.SS "Замечания разработчикам ядра"
При добавлении новых возможностей ядра, которые должны регулироваться
мандатом, нужно учитывать некоторые моменты.
.IP * 3
Цель мандатов — разделить возможности суперпользователя на части, и если
программа с одним или несколькими мандатами будет скомпрометирована, то её
возможности нанести вред системе будут меньше, чем от такой же программы,
выполняемой с правами суперпользователя.
.IP *
Вы можете создать новый мандат для новой возможности или привязать
возможность к одному из существующих мандатов. Чтобы сохранить набор
мандатов приемлемого размера, последний вариант предпочтителен, если нет
неопровержимых доводов за первый вариант (есть также техническое
ограничение: размер набора мандатов в настоящее время ограничен 64 битами).
.IP *
Для определения какой существующий мандат мог бы лучше подойти новой
возможности, просмотрите список мандатов, представленный выше. Выясните,
есть ли другие возможности, требующие мандатов, которые всегда будут
использоваться вместе с новой возможностью. Если новая возможность
бесполезна без этих других возможностей, то нужно использовать тот же мандат
как у других возможностей.
.IP *
\fIНе\fP используйте \fBCAP_SYS_ADMIN\fP, если этого можно избежать! С ним связана
большая часть существующих проверок мандатов (смотрите часть списка
выше). Его оправданно можно называть «новым суперпользователем», так как с
одной стороны, он даёт широкий спектр полномочий, а с другой его широкий
спектр действия означает, что данный мандат требуется многим
привилегированным программам. Не делайте проблему хуже. Новые возможности,
которые должны быть связаны с \fBCAP_SYS_ADMIN\fP должны \fIсильно\fP совпадать с
существующими, использующими данное хранилище.
.IP *
.\"
Если действительно необходимо создать новый мандат для новой возможности, не
делайте или называйте его как «только для этой возможности». То есть,
например, добавление очень специализированного \fBCAP_SYS_PACCT\fP было бы,
вероятно, ошибкой. Вместо этого попытайтесь идентифицировать и назвать новый
мандат более вместительным понятием, в которое могут войти и другие будущие
возможности.
.SS "Наборы мандатов нити"
Каждая нить имеет следующие наборы мандатов, содержащие ноль или более
перечисленных выше мандатов:
.TP 
\fIPermitted\fP
Ограничивающий набор эффективных мандатов, которыми наделяется нить. Этот
набор также ограничивает список мандатов, которые могут быть добавлены в
наследуемый набор для нити, которая не имеет мандата \fBCAP_SETPCAP\fP в своём
эффективном наборе.
.IP
Если нить сбрасывает мандат в своём разрешительном наборе, то она не сможет
получить его назад (если только не выполняется \fBexecve\fP(2) для программы с
set\-user\-ID\-root или программа, чьи соответствующие мандаты файла
предоставляют этот мандат).
.TP 
\fIInheritable\fP
Этот набор мандатов сохраняется при вызове \fBexecve\fP(2). Наследуемые мандаты
остаются наследуемыми при выполнении любой программы, и наследуемые мандаты
добавляются в разрешительный набор, если выполняющаяся программа имеет
соответствующие установленные биты в файловом наследуемом наборе.
.IP
Так как наследуемые мандаты, обычно, не сохраняются после \fBexecve\fP(2), если
выполнение происходит не от суперпользователя, то для приложений, которым
нужно выполнять вспомогательные программы с повышенными мандатами, нужно
использовать наружные мандаты (ambient capabilities), описанные ниже.
.TP 
\fIEffective\fP
Данный набор мандатов используется ядром при выполнении проверок прав нити.
.TP 
\fIBounding\fP (в каждой нити начиная с Linux 2.6.25)
Ограничивающий набор мандатов — это механизм, который можно использовать для
ограничения мандатов, которые могут быть получены при \fBexecve\fP(2).
.IP
Начиная с Linux 2.6.25 данный набор мандатов есть у каждой нити. В старых
ядрах ограничивающий набор мандатов был системным свойством, единым для всех
нитей в системе.
.IP
.IP
Дополнительную информацию об ограничивающем наборе мандатов смотрите далее.
.TP 
\fIAmbient\fP (начиная с Linux 4.3)
.\" commit 58319057b7847667f0c9585b9de0e8932b0fdb08
Данный набор мандатов сохраняется после \fBexecve\fP(2) для непривилегированных
программ. Для набора наружных мандатов (ambient capability set) соблюдается
правило, что ни один мандат не сможет быть наружным, если он одновременно
разрешающий и наследуемый.
.IP
Набор наружных мандатов можно непосредственно изменять с помощью
\fBprctl\fP(2). Наружные мандаты автоматически понижаются, если понижаются
соответствующие разрешительные или наследуемые мандаты.
.IP
При запуске программы, у которой изменяются UID или GID из\-за set\-user\-ID
или set\-group\-ID, или у которой установлен любой набор файловых мандатов,
наружный набор будет очищен. Наружные мандаты добавляются в разрешающий
набори назначаются в эффективный набор при вызове \fBexecve\fP(2). Если из\-за
наружных мандатов увеличиваются разрешающий и эффективный наборы при
\fBexecve\fP(2), то это не вызывает режима безопасного выполнения, описанного в
\fBld.so\fP(8).
.PP
Потомок, созданный \fBfork\fP(2), наследует копии наборов мандатов своего
родителя. Далее смотрите описание отношения к мандатами при \fBexecve\fP(2).
.PP
С помощью \fBcapset\fP(2) нить может изменять свои наборы мандатов (смотрите
далее).
.PP
.\" commit 73efc0394e148d0e15583e13712637831f926720
.\"
Начиная с Linux 3.2, файл \fI/proc/sys/kernel/cap_last_cap\fP содержит числовое
значение самого большого мандата, поддерживаемого работающим ядром; это
может быть использовано для определения наибольшего бита, который может быть
установлен в наборе мандатов.
.SS "Файловые мандаты"
Начиная с ядра версии 2.6.24, с помощью \fBsetcap\fP(8) поддерживается связь
наборов мандатов с исполняемым файлом. Наборы мандатов файла хранятся в
расширенном атрибуте (смотрите \fBsetxattr\fP(2) и \fBxattr\fP(7)) с именем
\fIsecurity.capability\fP. Для записи в этот расширенный атрибут требуется
мандат \fBCAP_SETFCAP\fP. Наборы файловых мандатов вместе с наборами мандатов
нити определяют наборы мандатов нити после выполнения \fBexecve\fP(2).
.PP
Три файловых набора мандатов:
.TP 
\fIPermitted\fP (ранее называвшийся \fIforced\fP):
Эти мандаты автоматически разрешаются нити независимо от унаследованных
мандатов нити.
.TP 
\fIInheritable\fP (ранее называвшийся \fIallowed\fP):
Этот набор объединяется (AND) с унаследованным набором нити для определения,
какие унаследованные мандаты будут включены в разрешительный набор нити
после \fBexecve\fP(2).
.TP 
\fIEffective\fP:
В действительности, это не набор, а одиночный бит. Если бит включён, то при
вызове \fBexecve\fP(2) все новые разрешённые мандаты нити будут также добавлены
в эффективный набор. Если бит выключен, то после \fBexecve\fP(2) ни один из
новых разрешённых мандатов не будет добавлен в новый эффективный набор.
.IP
.\"
Включение эффективного файлового мандатного бита подразумевает, что любой
файловый разрешительный или наследуемый мандат, который позволяет нити
получить соответствующий разрешительный мандат при \fBexecve\fP(2) (смотрите
правила преобразования, описанные далее), также получит этот мандат в
эффективном наборе. Поэтому, когда назначаются мандаты файлу (\fBsetcap\fP(8),
\fBcap_set_file\fP(3), \fBcap_set_fd\fP(3)), если мы укажем эффективный флаг как
включённый для любого мандата, то эффективный флаг должен также быть указан
включённым для всех остальных мандатов, для которых включён соответствующий
разрешительный или наследуемый флаги.
.SS "Версии расширенного атрибута файловых мандатов"
С целью расширяемости ядро поддерживает схему кодирования номера версии
внутри расширенного атрибута \fIsecurity.capability\fP, который используется в
реализации файловых мандатов. Эти номера версий введены только для
реализации и непосредственно не видны приложениям пользовательского
пространства. В настоящее время поддерживаются следующие версии:
.TP 
\fBVFS_CAP_REVISION_1\fP
Первоначальная реализация файловых мандатов, поддерживает 32\-битные маски
файловых мандатов.
.TP 
\fBVFS_CAP_REVISION_2\fP (начиная с Linux 2.6.25)
.\" commit e338d263a76af78fe8f38a72131188b58fceb591
В данной версии поддерживаются 64\-битные маски файловых мандатов, и и новый
номер версии стал необходим для поддержки мандатов более 32. Ядро продолжает
прозрачно поддерживать выполнение файлов с 32\-битными масками мандатов 1\-й
версии, но при добавлении мандатов к файлам, у которых их ещё не было, или
при изменение мандатов существующих файлов, оно автоматически использует
схему 2\-й версии (или, возможно, схему 3\-ей версии как описано далее).
.TP 
\fBVFS_CAP_REVISION_3\fP (начиная с Linux 4.14)
.\" commit 8db6c34f1dbc8e06aa016a9b829b06902c3e1340
Версия 3 файловые мандатов предоставляет поддержку файловых мандатов
пространства имён (описано далее).
.IP
Как и в версии 2, версия 3 имеет 64\-битную маску файловых мандатов. Но в
дополнении, в расширенном атрибуте \fIsecurity.capability\fP кодируется ID
суперпользователя пространства имён (ID суперпользователя пространства имён
— это значение, на которое отображается пользовательский ID 0 этого
пространства имён в изначальном пользовательском пространстве имён).
.IP
Файловые мандаты версии 3 могут сосуществовать с мандатами версии 2; то есть
в современной системе Linux одни файлы могут быть с мандатами версии 2, а
другие с версией 3.
.PP
До Linux 4.14 типом мандата расширенного атрибута, который мог быть
присоединён к файлу, был только атрибут \fBVFS_CAP_REVISION_2\fP. Начиная с
Linux 4.14 версия расширенного атрибута \fIsecurity.capability\fP,
присоединённого к файлу, зависит от обстоятельств, при которых был создан
атрибут.
.PP
Начиная с Linux 4.14, расширенный атрибут \fIsecurity.capability\fP
автоматически создаётся (или преобразуется) как атрибут версии 3
(\fBVFS_CAP_REVISION_3\fP), если оба условия истинны:
.IP (1) 4
Нить, записывающая атрибут, расположена не в изначальном пользовательском
пространстве имён (более точно: нить располагается в пользовательском
пространстве имён отличном от того, из которого смонтирована нижележащая
файловая система).
.IP (2)
Нить имеет мандат \fBCAP_SETFCAP\fP поверх файловой иноды, то есть (a) нит
имеет мандат \fBCAP_SETFCAP\fP в своём собственном пользовательском
пространстве имён; и (b) UID и GID файловой иноды отображаются в
пользовательское пространство имён записывающего.
.PP
При создании расширенного атрибута \fIsecurity.capability\fP с типом
\fBVFS_CAP_REVISION_3\fP ID суперпользователя пользовательского пространства
имён создающей нити сохраняется в расширенном атрибуте.
.PP
Но при создании или изменении расширенного атрибута \fIsecurity.capability\fP
из привилегированной (\fBCAP_SETFCAP\fP) нити, находящейся в пространстве имён,
в котором смонтирована нижележащая файловая система (обычно, это изначальное
пользовательское пространство имён), автоматически вызывает создание
атрибута с версией 2 (\fBVFS_CAP_REVISION_2\fP).
.PP
Заметим, что создании расширенного атрибута \fIsecurity.capability\fP версии 3
происходит автоматически. То есть когда приложение пользовательского
пространства записывает (\fBsetxattr\fP(2)) атрибут \fIsecurity.capability\fP в
формате версии 2 ядра автоматически создаёт версию атрибут версии 3, если
атрибут создаётся в условиях, описанных выше. И, соответственно, кода
атрибут \fIsecurity.capability\fP версии 3 возвращается (\fBgetxattr\fP(2))
процессу, расположенному в пользовательском пространстве имён, которое было
создано с ID суперпользователя (или потомком этого пользовательского
пространства имён), атрибут (автоматически) упрощается до версии 2 (т. е.,
возвращаемое значение имеет размер атрибута версии 2 и не включает ID
суперпользователя). Эти автоматические преобразования позволяют не
переписывать требуемые инструменты пользовательского пространства (например,
\fBsetcap\fP(1) и \fBgetcap\fP(1)) для создания и получения атрибута
\fIsecurity.capability\fP версии 3.
.PP
.\"
Заметим, что файл может иметь расширенный атрибут \fIsecurity.capability\fP
версии 2 или версии 3, но не оба одновременно: создание или изменение
расширенного атрибута \fIsecurity.capability\fP автоматически приведёт к
изменению версии согласно условиям, в которых он изменяется.
.SS "Преобразование мандатов при execve()"
.PP
При \fBexecve\fP(2) ядро вычисляет новые мандаты процесса по следующему
алгоритму:
.PP
.in +4n
.EX
P'(ambient) =     (привилегированный файл) ? 0 : P(ambient)

P'(permitted)   = (P(inheritable) & F(inheritable)) |
                  (F(permitted) & P(bounding)) | P'(ambient)

P'(effective) =   F(effective) ? P'(permitted) : P'(ambient)

P'(inheritable) = P(inheritable)    [т. е., не изменяется]

P'(bounding)    = P(bounding)       [т. е., не изменяется]
.EE
.in
.PP
где:
.RS 4
.IP P() 6
значение набора мандатов нити до \fBexecve\fP(2)
.IP P'()
значение набора мандатов нити после \fBexecve\fP(2)
.IP F()
файловый набор мандатов
.RE
.PP
Опишем подробней правила преобразования описанного выше мандата:
.IP * 3
Набор мандатов ambient появился начиная с Linux 4.3. При определении
преобразования набора ambient в \fBexecve\fP(2) привилегированный файл — это
файл, имеющий один из этих мандатов, или у него установлен бит set\-user\-ID
или set\-group\-ID.
.IP *
До Linux 2.6.25 ограничивающий набор мандатов был общесистемным атрибутом,
общим для всех нитей. Его значение использовалось для вычисления нового
разрешительного набора в \fBexecve\fP(2) таким же образом как для
\fIP(bounding)\fP, показанном выше.
.PP
\fIЗамечание\fP: во время изменений мандатов, описанных выше, файловые мандаты
могут игнорироваться (считаться пустыми) по тем же причинам что и
игнорируются биты set\-user\-ID и set\-group\-ID; смотрите
\fBexecve\fP(2). Файловые мандаты также игнорируются, если ядро было загружено
с параметром \fIno_file_caps\fP.
.PP
.\"
\fIЗамечание\fP: в соответствии с правилами выше, если процесс ненулевым
идентификатором пользователя выполняет \fBexecve\fP(2), то все его мандаты в
разрешительном и действующим наборах будут очищены. Учёт мандатов в случае,
когда процесс имеет нулевой идентификатор пользователя и выполняет
\fBexecve\fP(2), описан далее в разделе \fIМандаты и выполнение программы с
правами root\fP.
.SS "Проверка на безопасность двоичных файлов, не отзывчивых к мандатам"
Двоичный файл, не отзывчивый к мандатам (capability\-dumb binary) — это
приложение, которое помечено как имеющее файловые мандаты, но не
преобразованное для работы с программным интерфейсом \fBlibcap\fP(3) для
управления своими мандатами (иначе говоря, это обычная set\-user\-ID\-root
программа, у которой указали файловые мандаты, но код которой не был изменён
для понимания мандатов). У таких приложений на файле установлен эффективный
файловый мандатный бит, из\-за чего при исполнении файла у его процесса в
эффективном наборе автоматически включаются разрешительные мандаты. Если
ядро считает файл с установленным эффективным файловым мандатным битом не
отзывчивым к мандатам, то выполняются проверки, описанные далее.
.PP
.\"
При запуске выполняемого файла, не отзывчивого к мандатам, ядро проверяет
получил ли процесс все разрешительные мандаты, указанные в файловом
разрешительном наборе, после преобразований мандатов, описанных выше
(обычной причиной, почему это может \fIне\fP произойти, является то, что
ограничивающий набор мандатов перекрывает некоторые мандаты из файлового
разрешительного набора). Если процесс не получил полный набор файловых
разрешительных мандатов, то \fBexecve\fP(2) завершится с ошибкой \fBEPERM\fP. Это
предотвращает возникновение проблем с безопасностью, которые могли бы
появиться, если приложение, не отзывчивое к мандатам, выполняется с меньшими
правами чем требуется. Заметим, что по определению само приложение не может
увидеть эту проблему, так как не используется программный интерфейс
\fBlibcap\fP(3).
.SS "Мандаты и выполнение программ с правами root"
.\" See cap_bprm_set_creds(), bprm_caps_from_vfs_cap() and
.\" handle_privileged_root() in security/commoncap.c (Linux 5.0 source)
Чтобы отразить обычную семантику UNIX, ядро выполняет специальные действия с
файловыми мандатами, когда процесс с UID 0 (корневой) выполняет программу и
когда выполняется программа с set\-user\-ID\-root.
.PP
После применения изменений к эффективному ID процесса, которые возникли
из\-за режимного бита set\-user\-ID у исполняемого файла — например,
переключение действующего ID пользователя на 0 (root) из\-за запуска
программы с set\-user\-ID\-root — ядро вычисляет набор файловых мандатов
следующим образом:
.IP 1. 3
Если реальный и эффективный ID пользователя процесса равен 0 (root), то
файловый разрешительные или наследуемые наборы игнорируются; вместо этого
условно считается, что все их биты установлены (т. е., разрешены все
мандаты). (Существует одно исключение из этого правила, описано в
\fIПрограммы set\-user\-ID\-root с файловыми мандатами\fP.)
.IP 2.
Если эффективный ID пользователя процесса равен 0 (root) или файловый
эффективный бит фактически установлен, то файловый эффективный бит условно
считается равным единице (включен).
.PP
Затем эти условные значения файлового набора мандатов используются, как
описано выше, для вычисления преобразования мандатов процесса при
\fBexecve\fP(2).
.PP
Таким образом, когда процесс с ненулевым UID запускает с помощью
\fBexecve\fP(2) программу с set\-user\-ID\-root, у которой нет присоединённых
мандатов, или когда процесс, чей реальный и эффективный UID равны нулю,
запускают программу через \fBexecve\fP(2), вычисление новых разрешённых
мандатов упрощается до:
.PP
.in +4n
.EX
P'(permitted)   = P(inheritable) | P(bounding)

P'(effective)   = P'(permitted)
.EE
.in
.PP
В связи с этим, процесс получает все мандаты в своих разрешительном и
эффективном наборе мандатов , за исключением заглушаемых ограничивающим
набором мандатов. (В вычислении P'(permitted), значение P'(ambient) можно
сократить, так как оно определяется корректным поднабором P(inheritable).)
.PP
.\"
.\"
Специальное действие для ID пользователя 0 (root), описанное в этом абзаце,
можно отключить с помощью механизма securebits, описанного далее.
.SS "Программы set\-user\-ID\-root с файловыми мандатами"
Есть одно исключение в поведении, описанном в \fIМандаты и выполнение
программ с правами root\fP. Если (a) к исполняемому двоичному файлу
присоединены мандаты и (b) реальный пользовательский ID процесса \fIне\fP равен
0 (root) и (c) эффективный пользовательский ID процесса \fIравен\fP 0 (root),
то биты файловых мандатов учитываются (т. е., они не условно считаются
установленными в единицы). Обычно, эта ситуация может возникать при
исполнении программы с set\-UID\-root, у которой также заданы файловые
мандаты. При выполнении такой программы процесс получает только мандаты,
данные программе (т. е., не все мандаты, как это происходит, когда
выполняемая программа с set\-user\-ID\-root не имеет связанных файловых
мандатов).
.PP
.\"
Заметим, что файлу программы можно назначить пустой набор мандатов, и таким
образом возможно создать программу с set\-user\-ID\-root, которая изменяет
эффективный и сохранённый set\-user\-ID процесса, исполняющего программу, на
0, но не даёт мандаты этому процессу.
.SS "Ограничивающий набор мандатов"
Ограничивающий набор мандатов — это механизм безопасности, который можно
использовать для ограничения мандатов, которые могут быть получены при
\fBexecve\fP(2).  Ограничивающий набор используется так:
.IP * 2
При \fBexecve\fP(2) ограничивающий набор мандатов складывается (AND) с файловым
разрешительным набором мандатов, и результат этой операции назначается
разрешительному набору мандатов нити. Таким образом, ограничивающий набор
мандатов ограничивает разрешённые мандаты, которые может предоставить
исполняемый файл.
.IP *
(начиная с Linux 2.6.25) Ограничивающий набор мандатов служит ограничивающим
набором мандатов, которые нить может добавить в свой наследуемый набор с
помощью \fBcapset\fP(2). Это означает, что если мандат отсутствует в
ограничивающем наборе мандатов, то нить не может добавить этот мандат в свой
наследуемый набор даже, если он есть в разрешительном наборе мандатов и
поэтому не может сохранить данный мандат в разрешительный набор при вызове
\fBexecve\fP(2) для файла, который имеет мандат в своём наследуемом наборе.
.PP
Заметим, что ограничивающий набор скрывает файловые разрешительные мандаты,
но не наследуемые мандаты. Если нить имеет мандат в своём наследуемом
наборе, который отсутствует в ограничивающем наборе, то она по\-прежнему
обладает этим мандатом в своём разрешительном наборе при выполнении файла,
который имеет мандат в своём наследуемом наборе.
.PP
В зависимости от версии ядра ограничивающий набор мандатов является либо
системным свойством, либо атрибутом процесса.
.PP
\fBОграничивающий набор мандатов начиная с Linux 2.6.25\fP
.PP
Начиная с Linux 26.25, \fIограничивающий набор мандатов\fP является атрибутом
нити (системного ограничивающего набора мандатов, описываемого далее, больше
нет).
.PP
Ограничивающий набор наследуется при \fBfork\fP(2) от нити родителя и
сохраняется при \fBexecve\fP(2).
.PP
Нить может удалять мандаты из своего ограничивающего набора мандатов с
помощью вызова \fBprctl\fP(2) с операцией \fBPR_CAPBSET_DROP\fP при наличии
мандата \fBCAP_SETPCAP\fP. После удаления мандата из ограничивающего набора
обратно его восстановить невозможно. Нить может определить наличие мандата в
своём ограничивающем наборе с помощью вызова \fBprctl\fP(2) с операцией
\fBPR_CAPBSET_READ\fP.
.PP
.\" commit b3a222e52e4d4be77cc4520a57af1a4a0d8222d1
Удаление мандатов из ограничивающего набора доступно только, если ядро
собрано с поддержкой файловых мандатов. В ядре Linux до версии 2.6.33
файловые мандаты являлись необязательным свойством, настраиваемым параметром
\fBCONFIG_SECURITY_FILE_CAPABILITIES\fP. Начиная с Linux 2.6.33, параметр
настройки был удалён и теперь файловые мандаты всегда являются частью
ядра. Когда файловые мандаты в ядре, процесс \fBinit\fP (предок всех процессов)
запускается с полным ограничивающим набором. Если файловые мандаты не
добавлены в ядро, то \fBinit\fP запускается с полным ограничивающим набором
минус \fBCAP_SETPCAP\fP, так как этот мандат имеет другое значение, если
файловые мандаты отсутствуют.
.PP
Удаление мандата из ограничивающего набора не удаляет его из наследуемого
набора нити. Однако это предотвращает от добавления мандата обратно в
наследуемый набор нити в будущем.
.PP
\fBОграничивающий набор мандатов до Linux 2.6.25\fP
.PP
В ядрах до версии 2.6.25 ограничивающий набор мандатов был системным
атрибутом, который влиял на все нити системы. Ограничивающий набор доступен
через файл \fI/proc/sys/kernel/cap\-bound\fP (по непонятной причине, данный
параметр, битовая маска, в \fI/proc/sys/kernel/cap\-bound\fP записывался в виде
знакового десятичного числа).
.PP
Только процесс \fBinit\fP может задавать мандаты в ограничивающем наборе
мандатов; помимо этого, суперпользователь (точнее, процесс с мандатом
\fBCAP_SYS_MODULE\fP) может только удалять мандаты из набора.
.PP
В стандартной системе в ограничивающем наборе мандатов всегда удаляется
мандат \fBCAP_SETPCAP\fP. Чтобы убрать это ограничение (опасно!), нужно
изменить определение \fBCAP_INIT_EFF_SET\fP в \fIinclude/linux/capability.h\fP и
пересобрать ядро.
.PP
.\"
.\"
.\"
Системное свойство, ограничивающий набор мандатов, было добавлено в ядро
Linux версии 2.2.11.
.SS "Влияние изменения пользовательского ID на мандаты"
Для сохранения привычной семантики при переходе от 0 к ненулевым
пользовательским ID, ядро делает следующие изменения наборов мандатов нити
при изменении у нити реального, эффективного, сохранённого ID и
пользовательского ID файловой системы (с помощью \fBsetuid\fP(2),
\fBsetresuid\fP(2) или подобных):
.IP 1. 3
Если ранее реальный, эффективный или сохранённый пользовательский ID не был
равен 0, и в результате изменения UID все эти ID получили ненулевое
значение, то все мандаты удаляются из разрешительного, эффективного, и
наружного набора мандатов.
.IP 2.
Если эффективный пользовательский ID изменяется с 0 на ненулевое значение,
то все мандаты удаляются из эффективного набора мандатов.
.IP 3.
Если эффективный пользовательский ID изменяется с ненулевого значения на 0,
то разрешительный набор копируется в эффективный набор.
.IP 4.
Если пользовательский ID файловой системы изменяется с 0 на ненулевое
значение (смотрите \fBsetfsuid\fP(2)), то следующие мандаты удаляются из
эффективного набора: \fBCAP_CHOWN\fP, \fBCAP_DAC_OVERRIDE\fP,
\fBCAP_DAC_READ_SEARCH\fP, \fBCAP_FOWNER\fP, \fBCAP_FSETID\fP, \fBCAP_LINUX_IMMUTABLE\fP
(начиная с Linux 2.6.30), \fBCAP_MAC_OVERRIDE\fP и \fBCAP_MKNOD\fP (начиная с
Linux 2.6.30). Если пользовательский ID файловой системы изменяется с
ненулевого значения на 0, то любой из мандатов, включённых в разрешительный
набор, включается в эффективном наборе.
.PP
.\"
Если нить, у которой один или более пользовательских ID равно 0, хочет
предотвратить удаление разрешительных мандатов при сбросе всех
пользовательских ID в ненулевые значения, то она может использовать флаг
\fBSECBIT_KEEP_CAPS\fP в securebits, описанный далее.
.SS "Программное изменение наборов мандатов"
Нить может получать и изменять свои разрешительные, действующие и
наследуемые наборы мандатов с помощью системных вызовов \fBcapget\fP(2) и
\fBcapset\fP(2). Однако для этой цели лучше использовать \fBcap_get_proc\fP(3) и
\fBcap_set_proc\fP(3) из пакета \fIlibcap\fP. Следующие правила применяются при
изменении наборов нити:
.IP 1. 3
Если вызывающий не имеет мандата \fBCAP_SETPCAP\fP, то новый наследуемый набор
должен быть поднабором комбинации существующего наследуемого и
разрешительного наборов.
.IP 2.
(начиная с Linux 2.6.25) Новый наследуемый набор должен быть поднабором
комбинации существующего наследуемого и ограничивающего наборов.
.IP 3.
Новый разрешительный набор должен быть поднабором существующего
разрешительного набора (т. е., невозможно приобрести разрешительные мандаты,
которых нить не имеет).
.IP 4.
Новый эффективный набор должен быть поднабором нового разрешительного
набора.
.SS "Флаги securebits: организация исключительно мандатного окружения"
.\" For some background:
.\"       see http://lwn.net/Articles/280279/ and
.\"       http://article.gmane.org/gmane.linux.kernel.lsm/5476/
Начиная с ядра версии 2.6.26 с включённой поддержкой файловых мандатов, в
Linux реализован набор флагов \fIsecurebits\fP (для каждой нити), который можно
использовать для отключения специальных действий мандатов для UID 0
(\fIroot\fP). К этим флагам относятся:
.TP 
\fBSECBIT_KEEP_CAPS\fP
Установка этого флага позволяет нити иметь один или более 0 UIDов, чтобы
оставить мандаты в разрешительном наборе, когда она переключается все свои
UIDы в ненулевые значения. Если этот флаг не установлен, то переключение
такого UID приводит к тому, что нить теряет все мандаты в этих наборах. Этот
флаг всегда сбрасывается при \fBexecve\fP(2).
.IP
Заметим, что даже с установленным флагом \fBSECBIT_KEEP_CAPS\fP эффективные
мандаты нити очищаются, когда она переключает свой эффективный UID на
ненулевое значение. Однако, если нить устанавливает этот флаг и её
эффективный UID уже не равен нулю и затем нить переключает все другие UID в
ненулевые значения, то эффективные мандаты не будут очищены.
.IP
Установка флага \fBSECBIT_KEEP_CAPS\fP игнорируется, если указан флаг
\fBSECBIT_NO_SETUID_FIXUP\fP (этот флаг предоставляет надмножество свойств
первого флага).
.IP
Этот флаг предоставляет возможности старой операции \fBPR_SET_KEEPCAPS\fP
вызова \fBprctl\fP(2).
.TP 
\fBSECBIT_NO_SETUID_FIXUP\fP
Установка этого флага не даёт ядру изменить разрешительный, эффективный и
наружный набор мандатов при изменении эффективного UID и UID файловой
системы нити с 0 на ненулевое значение (смотрите раздел \fIВлияние изменения
пользовательского ID на мандаты\fP).
.TP 
\fBSECBIT_NOROOT\fP
Если этот бит установлен, то ядро не предоставляет мандаты при исполнении
программы, имеющей бит set\-user\-ID\-root, или когда процесс с эффективным или
реальным UID равным 0 вызывает \fBexecve\fP(2) (смотрите раздел \fIМандаты и
выполнение программа от root\fP).
.TP 
\fBSECBIT_NO_CAP_AMBIENT_RAISE\fP
Установка этого флага запрещает повышение наружных мандатов посредством
\fBprctl\fP(2)с операцией \fBPR_CAP_AMBIENT_RAISE\fP.
.PP
Каждый из перечисленных выше «базовых» флагов имеет дополнительный флаг
«блокировки». Установка любого из флагов «блокировки» необратима и запрещает
дальнейшие изменения соответствующего «базового» флага. Флаги блокировки:
\fBSECBIT_KEEP_CAPS_LOCKED\fP, \fBSECBIT_NO_SETUID_FIXUP_LOCKED\fP,
\fBSECBIT_NOROOT_LOCKED\fP и \fBSECBIT_NO_CAP_AMBIENT_RAISE_LOCKED\fP.
.PP
Флаги \fIsecurebits\fP можно изменять и получать с помощью вызова \fBprctl\fP(2) с
операциями \fBPR_SET_SECUREBITS\fP и \fBPR_GET_SECUREBITS\fP. Для изменения флагов
требуется мандат \fBCAP_SETPCAP\fP. Заметим, что константы \fBSECBIT_*\fP доступны
только после включения в код заголовочного файла
\fI<linux/securebits.h>\fP.
.PP
Флаги \fIsecurebits\fP наследуются дочерними процессами. При \fBexecve\fP(2) все
флаги сохраняются, за исключением \fBSECBIT_KEEP_CAPS\fP, который всегда
сбрасывается.
.PP
Приложение может использовать следующий вызов для собственной блокировки и
помещение всех своих потомков в окружение, в котором есть только один способ
добавить права — запустить программу со связанными с ней файловыми
мандатами:
.PP
.in +4n
.EX
prctl(PR_SET_SECUREBITS,
        /* SECBIT_KEEP_CAPS off */
        SECBIT_KEEP_CAPS_LOCKED |
        SECBIT_NO_SETUID_FIXUP |
        SECBIT_NO_SETUID_FIXUP_LOCKED |
        SECBIT_NOROOT |
        SECBIT_NOROOT_LOCKED);
        /* установка/блокировка SECBIT_NO_CAP_AMBIENT_RAISE
           не требуется */
.EE
.in
.\"
.\"
.SS "Программы set\-user\-ID\-root с отдельными пространствами имён пользователя"
Программе set\-user\-ID, чей UID совпадает с UID создателя пространства имён
пользователя, будут предоставлены мандаты в разрешительном и эффективном
наборах, при выполнении любого процесса внутри этого пространства имён или в
любом дочернем пространстве имён пользователя.
.PP
.\"
.\"
Правила преобразования мандатов процесса при \fBexecve\fP(2) точно такие же как
описаны в подразделах \fIПреобразование мандатов при execve()\fP и \fIМандаты и
выполнение программы с правами root\fP, но с отличием: в последнем подразделе
«root» это UID создателя пространства имён пользователя.
.SS "Файловые мандаты пространства имён"
.\" commit 8db6c34f1dbc8e06aa016a9b829b06902c3e1340
Обычные (т. е., с версией 2) файловые мандаты представляют собой только
связь набора мандатных масок и двоичного исполняемого файла. Когда процесс
выполняет двоичный файл с такими мандатами он получает присоединённые
мандаты (внутри своего пользовательского пространства имён) согласно
правилам, описанным выше в «Преобразование мандатов при execve()».
.PP
Так как файловые мандаты версии 2 предоставляются выполняющемуся процессу
независимо от того, в каком пользовательском пространстве имён он
располагается, то только привилегированным процессам разрешено связывать
мандаты с файлом. Здесь «привилегированным» считается процесс, имеющий
мандат \fBCAP_SETFCAP\fP в пользовательском пространстве имён, в котором была
смонтирована файловая система (обычно, изначальное пользовательское
пространство имён). Это ограничение в определённых случаях делает файловые
мандаты бесполезными. Например, в контейнерах пользовательских пространств
имён может требоваться возможность создания двоичных файлов, которые
предоставляют мандаты только процессам, выполняемым внутри контейнера, но не
процессам, выполняемым вне контейнера.
.PP
В Linux 4.14 добавлены так называемые файловые мандаты пространства имён;
это введено специально для таких случаев. Файловые мандаты пространства имён
записываются в версию 3 (т. е., \fBVFS_CAP_REVISION_3\fP) расширенных атрибутов
\fIsecurity.capability\fP. Данный атрибут автоматически создаётся при условиях,
описанных выше в «Версии расширенного атрибута файловых мандатов». Когда
создаётся расширенный атрибут\fIsecurity.capability\fP версии 3 ядро записывает
в расширенный атрибут не только маску мандатов, но и ID суперпользователя
пространства имён.
.PP
.\"
.\"
Подобно двоичному файлу с файловыми мандатами \fBVFS_CAP_REVISION_2\fP файл с
файловыми мандатами \fBVFS_CAP_REVISION_3\fP предоставляет мандаты процессу при
\fBexecve\fP(). Однако мандаты предоставляются только, если двоичный файл,
выполняемый процессом, располагается в пользовательском пространстве имён, в
котором UID 0 отображается в ID суперпользователя, сохранённого в
расширенном атрибуте, или когда выполняется процессом, располагаемом в
потомке такого пространства имён.
.SS "Взаимодействие с пользовательскими пространствами имён"
Дополнительную информацию о связи мандатов с пространствами пользователя
смотрите в \fBuser_namespaces\fP(7).
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
.PP
Стандарты, описывающие мандаты, отсутствуют, но реализация мандатов в Linux
основывается на изъятом черновике стандарта POSIX.1e; смотрите
.UR https://archive.org\:/details\:/posix_1003.1e\-990310
.UE .
.SH ЗАМЕЧАНИЯ
При попытке запуска \fBstrace\fP(1) над исполняемыми файлами с мандатами (или с
установленным битом set\-user\-ID\-root), вам может понадобиться параметр \fI\-u
<имя_пользователя>\fP. Например так:
.PP
.in +4n
.EX
$ \fBsudo strace \-o trace.log \-u ceci ./myprivprog\fP
.EE
.in
.PP
.\" commit 5915eb53861c5776cfec33ca4fcc1fd20d66dd27 removed
.\" CONFIG_SECURITY_CAPABILITIES
Начиная с ядра версии 2.5.27 по 2.6.26, мандаты являются необязательным
компонентом ядра, и могут быть включены/выключены с помощью параметра
настройки ядра \fBCONFIG_SECURITY_CAPABILITIES\fP.
.PP
.\" 7b9a7ec565505699f503b4fcf61500dceb36e744
Файл \fI/proc/[pid]/task/TID/status\fP можно использовать для просмотра набора
мандатов нити. В файле \fI/proc/[pid]/status\fP отражён набор мандатов главной
нити процесса. До Linux 3.8, несуществующие мандаты в этих наборах
показывались как включённые (1). Начиная с Linux 3.8, все несуществующие
мандаты (после \fBCAP_LAST_CAP\fP) показываются выключенными (0).
.PP
В пакете \fIlibcap\fP содержится набор процедур для установки и получения
мандатов; он удобнее и менее подвержен изменениям, чем интерфейс
предоставляемый \fBcapset\fP(2) и \fBcapget\fP(2). Также данный пакет
предоставляет программы \fBsetcap\fP(8) и \fBgetcap\fP(8) . Его можно найти здесь:
.br
.UR https://git.kernel.org\:/pub\:/scm\:/libs\:/libcap\:/libcap.git\:/refs/
.UE .
.PP
До ядра версии 2.6.24, и начиная с версии 2.6.24 по 2.6.32, если файловые
мандаты не включены, то нить с мандатом \fBCAP_SETPCAP\fP может управлять
мандатами других нитей. Однако, это возможно только теоретически, так как ни
одна из нитей не имеет \fBCAP_SETPCAP\fP в любом из двух случаев:
.IP * 2
Реализация в версии pre\-2.6.25 системного ограничивающего набора мандатов,
\fI/proc/sys/kernel/cap\-bound\fP, всегда запрещала этот мандат, и это нельзя
было изменить без изменения исходного кода ядра и пересборки.
.IP *
Если файловые мандаты выключены в текущей реализации, то у запускаемого
\fBinit\fP данный мандат отозван из ограничивающего набора мандатов нити, и
этот ограничивающий набор наследуется всеми остальными процессами,
создаваемыми в системе.
.SH "СМОТРИТЕ ТАКЖЕ"
.\" from libcap-ng
.\" from libcap-ng
.\" from libcap-ng
.\" from libcap-ng
\fBcapsh\fP(1), \fBsetpriv\fP(1), \fBprctl\fP(2), \fBsetfsuid\fP(2), \fBcap_clear\fP(3),
\fBcap_copy_ext\fP(3), \fBcap_from_text\fP(3), \fBcap_get_file\fP(3),
\fBcap_get_proc\fP(3), \fBcap_init\fP(3), \fBcapgetp\fP(3), \fBcapsetp\fP(3),
\fBlibcap\fP(3), \fBproc\fP(5), \fBcredentials\fP(7), \fBpthreads\fP(7),
\fBuser_namespaces\fP(7), \fBcaptest\fP(8), \fBfilecap\fP(8), \fBgetcap\fP(8),
\fBnetcap\fP(8), \fBpscap\fP(8), \fBsetcap\fP(8)
.PP
Файл \fIinclude/linux/capability.h\fP в дереве исходного кода ядра Linux.
