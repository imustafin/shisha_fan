.\" -*- mode: troff; coding: UTF-8 -*-
.\" Man page generated from reStructuredText.
.\" Copyright (C) All BPF authors and contributors from 2014 to present.
.\" See git log include/uapi/linux/bpf.h in kernel tree for details.
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"
.\" Please do not edit this file. It was generated from the documentation
.\" located in file include/uapi/linux/bpf.h of the Linux kernel sources
.\" (helpers description), and from scripts/bpf_helpers_doc.py in the same
.\" repository (header and footer).
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH BPF\-HELPERS 7 2019\-03\-06 Linux "Руководство программиста Linux"
.SH ИМЯ
BPF\-HELPERS \- список вспомогательных функций eBPF
.nr rst2man-indent-level 0
.de1 rstReportMargin
\e$1 \en[an\-margin] level \en[rst2man\-indent\-level] level margin:
\en[rst2man\-indent\en[rst2man\-indent\-level]] \en[rst2man\-indent0]
\en[rst2man\-indent1] \en[rst2man\-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \$1
. nr rst2man-indent\n[rst2man-indent-level] \n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de  UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.SH ОПИСАНИЕ
.sp
Расширенная подсистема пакетных фильтров Беркли (eBPF) представляет собой
программы, написанные на псевдо\-ассемблерном языке, которые прикрепляются к
одному из перехватчиков ядра (hooks) и запускаются в ответ на определённые
события. Эта инфраструктура отличается от старой, «классической» BPF
(«cBPF»), некоторыми моментами, одним из которых является способность
вызывать из программ специальные функции («помощники» helpers). Эти функции
перечислены в белом списке помощников, который задаётся ядром.
.sp
Эти помощники используются в программах eBPF для взаимодействия с системой
или рабочим контекстом. Например, они могут использоваться для печати
отладочных сообщений, получения времени, прошедшего с момента загрузки
системы, для взаимодействия с картами eBPF или для обработки сетевых
пакетов. Так есть несколько типов программ eBPF и они не могут работать в
одном контексте, каждый тип программ может вызывать только некоторую часть
этих помощников.
.sp
В соответствии с правилами eBPF помощник может иметь не более пяти
аргументов.
.sp
Внутри программы eBPF непосредственно вызывают скомпилированные
функции\-помощники без какого\-либо стороннего интерфейса. В результате вызов
помощников не приводит к накладным расходам, показывая превосходную
производительность.
.sp
В этом документе предпринимается попытка перечислить и описать помощников,
доступных разработчикам eBPF. Они отсортированы в хронологическом порядке
(сначала самые старые).
.SH ПОМОЩНИКИ
.INDENT 0.0
.TP 
\fBvoid *bpf_map_lookup_elem(struct bpf_map *\fP\fImap\fP\fB, const void *\fP\fIkey\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Выполняет в \fImap\fP поиск записи, связанной с \fIkey\fP\&.
.TP 
\fBВозвращает\fP
Значение карты, связанное с \fIkey\fP, или \fBNULL\fP, если запись не найдена.
.UNINDENT
.TP 
\fBint bpf_map_update_elem(struct bpf_map *\fP\fImap\fP\fB, const void *\fP\fIkey\fP\fB, const void *\fP\fIvalue\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Добавляет или обновляет значение записи, связанное с \fIkey\fP в \fImap\fP, равное
\fIvalue\fP\&. Значение \fIflags\fP может быть одним из:
.INDENT 7.0
.TP 
\fBBPF_NOEXIST\fP
Запись для \fIkey\fP не должна существовать в карте.
.TP 
\fBBPF_EXIST\fP
Запись для \fIkey\fP должна существовать в карте.
.TP 
\fBBPF_ANY\fP
Не учитывать условие существования записи для \fIkey\fP\&.
.UNINDENT
.sp
Значение флага \fBBPF_NOEXIST\fP нельзя использовать для карт с типом
\fBBPF_MAP_TYPE_ARRAY\fP или \fBBPF_MAP_TYPE_PERCPU_ARRAY\fP (все элементы всегда
существуют), помощник вернул бы ошибку.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_map_delete_elem(struct bpf_map *\fP\fImap\fP\fB, const void *\fP\fIkey\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Удаляет запись с \fIkey\fP из \fImap\fP\&.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_map_push_elem(struct bpf_map *\fP\fImap\fP\fB, const void *\fP\fIvalue\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Заталкивает элемент \fIvalue\fP в \fImap\fP\&. В \fIflags\fP может быть одно из:
.sp
\fBBPF_EXIST\fP Если очередь/стек полны, то самый старый элемент удаляется,
освобождая место под указанный.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_probe_read(void *\fP\fIdst\fP\fB, u32 \fP\fIsize\fP\fB, const void *\fP\fIsrc\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Для программ трассировки; безопасно попытаться прочитать \fIsize\fP байт по
адресу \fIsrc\fP и сохранить данные в \fIdst\fP\&.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBu64 bpf_ktime_get_ns(void)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Возвращает время, прошедшее с момента запуска системы, в наносекундах.
.TP 
\fBВозвращает\fP
Текущее значение \fIktime\fP\&.
.UNINDENT
.TP 
\fBint bpf_trace_printk(const char *\fP\fIfmt\fP\fB, u32 \fP\fIfmt_size\fP\fB, ...)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Этот помощник подобен printk() и помогает в отладке. Он печатает сообщение,
определяемое форматом \fIfmt\fP (размером \fIfmt_size\fP), в файл
\fI/sys/kernel/debug/tracing/trace\fP из DebugFS, если есть. Принимает до трёх
дополнительных аргументов \fBu64\fP (как и для всех помощников eBPF, общее
количество аргументов ограничено пятью).
.sp
Каждый раз при вызове помощника, он добавляет строку в трассировку. Формат
трассировки можно изменять, и конечный результат зависит от указанных в
\fI/sys/kernel/debug/tracing/trace_options\fP параметров (также смотрите файл
\fIREADME\fP в том же каталоге). Однако, при обычных настройках строка выглядит
так:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
telnet\-470   [001] .N.. 419421.045894: 0x00000001: <formatted msg>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Где:
.INDENT 7.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fBtelnet\fP — имя текущей задачи.
.IP \(bu 2
\fB470\fP — PID текущей задачи.
.IP \(bu 2
\fB001\fP номер ЦП, на котором выполняется текущая задача.
.IP \(bu 2
В \fB\&.N..\fP каждый символ ссылается на набор параметров (разрешены ли irq,
параметры планирования, работает ли hard/softirq, уровень preempt_disabled,
соответственно). \fBN\fP означает, что установлены \fBTIF_NEED_RESCHED\fP и
\fBPREEMPT_NEED_RESCHED\fP.
.IP \(bu 2
\fB419421.045894\fP — метка времени.
.IP \(bu 2
\fB0x00000001\fP — фиктивное значение, используемое BPF как регистр указателя
инструкций.
.IP \(bu 2
\fB<formatted msg>\fP — сообщение, отформатированное согласно \fIfmt\fP\&.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Спецификаторы преобразований, поддерживаемые \fIfmt\fP, похожи, но несколько
ограничены, чем у printk(). Список: \fB%d\fP, \fB%i\fP, \fB%u\fP, \fB%x\fP, \fB%ld\fP,
\fB%li\fP, \fB%lu\fP, \fB%lx\fP, \fB%lld\fP, \fB%lli\fP, \fB%llu\fP, \fB%llx\fP, \fB%p\fP,
\fB%s\fP\&. Нельзя указывать модификатор (размер поля, заполнение нулями и
т. п.) и помощник вернёт \fB\-EINVAL\fP (и ничего не напечатает), если обнаружит
неизвестный спецификаторы.
.sp
Также заметим, что \fBbpf_trace_printk\fP() медленно работает и должна
использоваться только в целях отладки. Поэтому при первом использовании
(точнее, при выделении буферов \fBtrace_printk\fP()) в журнал ядра печатается
блок с уведомлением (охватывающем несколько строк), в котором говорится, что
данный помощник не должен «использоваться в промышленной эксплуатации». Для
передачи значений в пространство пользователя нужно использовать события
perf.
.TP 
\fBВозвращает\fP
Количество байт, записанных в буфер, или отрицательный номер ошибки.
.UNINDENT
.TP 
\fBu32 bpf_get_prandom_u32(void)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Возвращает псевдослучайное число.
.sp
С точки зрения безопасности в помощнике используется собственноевнутреннее
состояние псевдослучайности, по которому нельзя предсказать начальное
случайное число других функций ядра. Однако, стоит отметить, что
используемый в помощнике генератор небезопасен для шифрования.
.TP 
\fBВозвращает\fP
Случайное 32\-битное беззнаковое значение.
.UNINDENT
.TP 
\fBu32 bpf_get_smp_processor_id(void)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Возвращает идентификатор SMP (симметричного мультиобрабатывающего)
процессора. Заметим, что все программы выполняются с выключенным
вытеснением, то есть идентификатор SMP\-процессора не изменяется за всё время
выполнения программы.
.TP 
\fBВозвращает\fP
Идентификатор SMP\-процессора выполняющейся программы.
.UNINDENT
.TP 
\fBint bpf_skb_store_bytes(struct sk_buff *\fP\fIskb\fP\fB, u32 \fP\fIoffset\fP\fB, const void *\fP\fIfrom\fP\fB, u32 \fP\fIlen\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Записывает \fIlen\fP байт из адреса \fIfrom\fP в пакет, связанный с \fIskb\fP, по
смещению \fIoffset\fP\&. Значением \fIflags\fP является комбинация
\fBBPF_F_RECOMPUTE_CSUM\fP (повторное автоматическое вычисление контрольной
суммы пакета после записи байт) и \fBBPF_F_INVALIDATE_HASH\fP (присваивает
\fIskb\fP\fB\->hash\fP, \fIskb\fP\fB\->swhash\fP и \fIskb\fP\fB\->l4hash\fP значение
0).
.sp
Вызов этого помощника приводит к изменению буфера нижележащего
пакета. Поэтому на момент загрузки все проверки указателей, выполненные
ранее верификатором, становятся недействительными и должны быть выполнены
повторно, если кроме помощника используется прямой доступ к пакету.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_l3_csum_replace(struct sk_buff *\fP\fIskb\fP\fB, u32 \fP\fIoffset\fP\fB, u64 \fP\fIfrom\fP\fB, u64 \fP\fIto\fP\fB, u64 \fP\fIsize\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Повторно вычисляет контрольную сумму заголовка 3\-го уровня (например, IP) из
пакета, связанного с \fIskb\fP\&. Вычисление является поступательным, поэтому
помощник должен знать предыдущее значение поля заголовка, которое было
изменено (\fIfrom\fP), новое значение этого поля (\fIto\fP) и количество байт (2
или 4) этого поля, хранящиеся в \fIsize\fP\&. Или же можно сохранить различие
между предыдущим и новым значениями поля заголовка в \fIto\fP, установив
\fIfrom\fP и \fIsize\fP равными 0. В обоих способах в \fIoffset\fP задаётся
расположение контрольной суммы IP внутри пакета.
.sp
Этот помощник работает вместе с \fBbpf_csum_diff\fP(), который не обновляет
непосредственно контрольную сумму, а обладает большей гибкостью и может
обрабатывать большие размеры данных, чем 2 или 4.
.sp
Вызов этого помощника приводит к изменению буфера нижележащего
пакета. Поэтому на момент загрузки все проверки указателей, выполненные
ранее верификатором, становятся недействительными и должны быть выполнены
повторно, если кроме помощника используется прямой доступ к пакету.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_l4_csum_replace(struct sk_buff *\fP\fIskb\fP\fB, u32 \fP\fIoffset\fP\fB, u64 \fP\fIfrom\fP\fB, u64 \fP\fIto\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Повторно вычисляет контрольную сумму заголовка 4\-го уровня (например, TCP,
UDP или ICMP) из пакета, связанного с \fIskb\fP\&. Вычисление является
поступательным, поэтому помощник должен знать предыдущее значение поля
заголовка, которое было изменено (\fIfrom\fP), новое значение этого поля
(\fIto\fP) и количество байт (2 или 4) этого поля, хранящиеся в младших четырёх
битах \fIflags\fP\&. Или же можно сохранить различие между предыдущим и новым
значениями поля заголовка в \fIto\fP, установив \fIfrom\fP и четыре младших бита
\fIflags\fP равными 0. В обоих способах в \fIoffset\fP задаётся расположение
контрольной суммы IP внутри пакета. В дополнении размера поля в \fIflags\fP
можно добавить (побитовым ИЛИ) нужные флаги. При указании
\fBBPF_F_MARK_MANGLED_0\fP контрольная сумма null остаётся неизменяемой (если
также не указан \fBBPF_F_MARK_ENFORCE\fP), а чтобы обновить результат в
контрольной сумме null нужно задать значение \fBCSUM_MANGLED_0\fP. Флаг
\fBBPF_F_PSEUDO_HDR\fP задаёт, что контрольная сумма будет вычислена повторно
на уровне псевдо\-заголовка.
.sp
Этот помощник работает вместе с \fBbpf_csum_diff\fP(), который не обновляет
непосредственно контрольную сумму, а обладает большей гибкостью и может
обрабатывать большие размеры данных, чем 2 или 4.
.sp
Вызов этого помощника приводит к изменению буфера нижележащего
пакета. Поэтому на момент загрузки все проверки указателей, выполненные
ранее верификатором, становятся недействительными и должны быть выполнены
повторно, если кроме помощника используется прямой доступ к пакету.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_tail_call(void *\fP\fIctx\fP\fB, struct bpf_map *\fP\fIprog_array_map\fP\fB, u32 \fP\fIindex\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Это специальный помощник используется для активации «хвостового вызова»,
иначе говоря, прыжка в другую программу eBPF. Используется тот же кадр стека
(но значения в стеке и в регистрах вызывающего недоступны вызываемому). Этот
механизм позволяет образовывать цепочки программ, или для превышения
максимального количества доступных инструкций eBPF, или для выполнения
заданной программы в блоках условий. Из соображений безопасности существует
верхний предел количества последовательных хвостовых вызовов, которые можно
выполнить.
.sp
При вызове из помощника программы пытается прыгнуть в программу согласно
индексу \fIindex\fP в \fIprog_array_map\fP, специальной карте с типом
\fBBPF_MAP_TYPE_PROG_ARRAY\fP, и передать \fIctx\fP, указатель на контекст.
.sp
Если вызов произошёл без ошибок, то ядро сразу выполняет первую инструкцию
новой программы. Это не вызов функции и возврата к старой программе никогда
не происходит. Если при вызове возникла ошибка, то помощник ничего не делает
и вызывающий продолжает выполнение со следующей инструкции. Вызов может
завершиться ошибкой, если прыжок указывает на несуществующую программу
(т. е. значение \fIindex\fP превышает количество элементов \fIprog_array_map\fP),
или если в этой цепочке программ достигнуто максимальное количество
хвостовых вызовов. Данный предел определён в ядре макросом
\fBMAX_TAIL_CALL_CNT\fP (недоступен в пользовательском пространстве) и в данный
момент равен 32.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_clone_redirect(struct sk_buff *\fP\fIskb\fP\fB, u32 \fP\fIifindex\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Клонирует и перенаправляет пакет, связанный с \fIskb\fP, в другое сетевое
устройство с индексом \fIifindex\fP\&. Для перенаправления можно использовать
как входящий так и исходящий интерфейсы. В качестве отличительного признака
в \fIflags\fP используется значение \fBBPF_F_INGRESS\fP (выбирается входящий путь,
если флаг указан, в противном случае — исходящий). В настоящее время
поддерживается только этот флаг.
.sp
По сравнению с помощником \fBbpf_redirect\fP(), работа \fBbpf_clone_redirect\fP()
добавляет накладные расходы по созданию копии пакетного буфера, но это можно
выполнить вне программы eBPF. В свою очередь \fBbpf_redirect\fP() эффективнее,
но вызывается в коде действия, где перенаправление возникает только после
возврата из программы eBPF.
.sp
Вызов этого помощника приводит к изменению буфера нижележащего
пакета. Поэтому на момент загрузки все проверки указателей, выполненные
ранее верификатором, становятся недействительными и должны быть выполнены
повторно, если кроме помощника используется прямой доступ к пакету.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBu64 bpf_get_current_pid_tgid(void)\fP
.INDENT 7.0
.TP 
\fBВозвращает\fP
64\-битное целое, содержащее текущий tgid и pid, создаваемое как:
\fIcurrent_task\fP\fB\->tgid << 32 |\fP \fIcurrent_task\fP\fB\->pid\fP\&.
.UNINDENT
.TP 
\fBu64 bpf_get_current_uid_gid(void)\fP
.INDENT 7.0
.TP 
\fBВозвращает\fP
4\-битное целое, содержащее текущий GID и UID, создаваемое как:
\fIcurrent_gid\fP \fB<< 32 |\fP \fIcurrent_uid\fP\&.
.UNINDENT
.TP 
\fBint bpf_get_current_comm(char *\fP\fIbuf\fP\fB, u32 \fP\fIsize_of_buf\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Копирует атрибут \fBcomm\fP текущей задачи в \fIbuf\fP размером
\fIsize_of_buf\fP\&. Атрибут \fBcomm\fP содержит имя исполняемого файла (без пути)
текущей задачи. Значение \fIsize_of_buf\fP должно быть положительным. При
успешном выполнении помощник проверяет, что \fIbuf\fP заканчивается NUL. При
ошибке заполняется нулями.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBu32 bpf_get_cgroup_classid(struct sk_buff *\fP\fIskb\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Возвращает classid текущей задачи, т. е. net_cls cgroup, которой принадлежит
\fIskb\fP.
.sp
Этот помощник можно использовать на исходящих путях TC, но не на входящих.
.sp
net_cls cgroup предоставляет интерфейс для маркировки сетевых пакетов на
основе пользовательского идентификатора для всего трафика, который поступает
от задач, принадлежащих соответствующей cgroup. Смотрите также
соответствующую документацию ядра в файле исходного кода Linux
\fIDocumentation/cgroup\-v1/net_cls.txt\fP\&.
.sp
В ядре Linux есть две версии cgroups: cgroups v1 и cgroups v2. Они обе
доступны пользователям, их можно использовать одновременно, но заметим, что
net_cls cgroup есть только для cgroup v1. Это приводит к несовместимости с
программами BPF, выполняющимися на cgroups, которые используют только cgroup
v2 (сокет может хранить данные только для одной версии cgroups
одновременно).
.sp
Этот помощник доступен только, если ядро скомпилировано с параметром
настройки \fBCONFIG_CGROUP_NET_CLASSID\fP равным "\fBy\fP" или "\fBm\fP".
.TP 
\fBВозвращает\fP
classid или 0 по умолчанию для ненастроенного classid.
.UNINDENT
.TP 
\fBint bpf_skb_vlan_push(struct sk_buff *\fP\fIskb\fP\fB, __be16 \fP\fIvlan_proto\fP\fB, u16 \fP\fIvlan_tci\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Добавляет \fIvlan_tci\fP (тег управляющей информации VLAN) протокола
\fIvlan_proto\fP в пакет, связанный с \fIskb\fP, а затем обновить контрольную
сумму. Заметим, что если \fIvlan_proto\fP отличается от \fBETH_P_8021Q\fP и
\fBETH_P_8021AD\fP, то будет считаться, что указан \fBETH_P_8021Q\fP\&.
.sp
Вызов этого помощника приводит к изменению буфера нижележащего
пакета. Поэтому на момент загрузки все проверки указателей, выполненные
ранее верификатором, становятся недействительными и должны быть выполнены
повторно, если кроме помощника используется прямой доступ к пакету.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_skb_vlan_pop(struct sk_buff *\fP\fIskb\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Удаляет заголовок VLAN из пакета, связанного с \fIskb\fP\&.
.sp
Вызов этого помощника приводит к изменению буфера нижележащего
пакета. Поэтому на момент загрузки все проверки указателей, выполненные
ранее верификатором, становятся недействительными и должны быть выполнены
повторно, если кроме помощника используется прямой доступ к пакету.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_skb_get_tunnel_key(struct sk_buff *\fP\fIskb\fP\fB, struct bpf_tunnel_key *\fP\fIkey\fP\fB, u32 \fP\fIsize\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Возвращает метаданные туннеля. Этому помощнику передаётся указатель \fIkey\fP
на пустую \fBstruct bpf_tunnel_key\fP размером \fBsize\fP, которая будет заполнена
метаданными туннеля для пакета, связанного с \fIskb\fP\&. В \fIflags\fP можно
указать значение \fBBPF_F_TUNINFO_IPV6\fP, которое показывает, что туннель
основан на протоколе IPv6, а не на IPv4.
.sp
Объект \fBstruct bpf_tunnel_key\fP сводит основные параметры, используемые
различными туннельными протоколами, в одну структуру. Он позволяет легко
принимать решение на основе содержимого инкапсулированного заголовка,
«обобщённого» в этой структуре. В частности, он содержит IP\-адрес ответной
стороны (IPv4 или IPv6) в \fIkey\fP\fB\->remote_ipv4\fP или
\fIkey\fP\fB\->remote_ipv6\fP\&. Также, эта структура предоставляет
\fIkey\fP\fB\->tunnel_id\fP, обычно отображаемый в VNI (идентификатор
виртуальной сети, Virtual Network Identifier), который можно использовать
программировании с помощью помощника \fBbpf_skb_set_tunnel_key\fP().
.sp
Представим, что следующий код — часть программы, присоединённой к входящему
интерфейсу TC, туннель GRE и что нужно фильтровать все сообщения, приходящие
с ответной стороны, у которых адрес IPv4 не равен 10.0.0.1:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
int ret;
struct bpf_tunnel_key key = {};

ret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key), 0);
if (ret < 0)
        return TC_ACT_SHOT;     // отбрасываем пакет

if (key.remote_ipv4 != 0x0a000001)
        return TC_ACT_SHOT;     // отбрасываем пакет

return TC_ACT_OK;               // пропускаем пакет
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Также этот интерфейс можно использовать для всех устройств инкапсуляции,
которые могут работать в режиме «сбора метаданных»: вместо одного сетевого
устройства для каждой специфической конфигурации, в режиме «сбора
метаданных» требуется только одно устройство, конфигурацию которого можно
извлечь из этого заголовка.
.sp
Его можно использовать вместе с различными туннелями, такими как VXLan,
Geneve, GRE или IP в IP (IPIP).
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_skb_set_tunnel_key(struct sk_buff *\fP\fIskb\fP\fB, struct bpf_tunnel_key *\fP\fIkey\fP\fB, u32 \fP\fIsize\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Заполняет метаданные туннеля в пакете, связанном с \fIskb\fP. Метаданные
туннеля представляют собой набор значений \fIkey\fP и \fIsize\fP\&. В \fIflags\fP
можно указать комбинацию следующих значений:
.INDENT 7.0
.TP 
\fBBPF_F_TUNINFO_IPV6\fP
Задаёт, что туннель основан на протоколе IPv6, а не IPv4.
.TP 
\fBBPF_F_ZERO_CSUM_TX\fP
Для пакетов IPv4 добавление этого флага в метаданные туннеля указывает, что
не нужно вычислять контрольную сумму и присвоить ей значение ноль.
.TP 
\fBBPF_F_DONT_FRAGMENT\fP
Добавление этого флага в метаданные туннеля указывает, что пакет не должен
фрагментироваться.
.TP 
\fBBPF_F_SEQ_NUMBER\fP
Добавление этого флага в метаданные туннеля указывает, что перед отправкой
пакета в туннельный заголовок нужно добавить порядковый номер. Этот флаг был
добавлен для протокола GRE, но в будущем может использоваться и для других.
.UNINDENT
.sp
Обычное использование в пути передачи:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
struct bpf_tunnel_key key;
     заполняем ключ …
bpf_skb_set_tunnel_key(skb, &key, sizeof(key), 0);
bpf_clone_redirect(skb, vxlan_dev_ifindex, 0);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Также смотрите описание помощника \fBbpf_skb_get_tunnel_key\fP().
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBu64 bpf_perf_event_read(struct bpf_map *\fP\fImap\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Читает значение счётчика событий perf. Этот помощник использует \fImap\fP с
типом \fBBPF_MAP_TYPE_PERF_EVENT_ARRAY\fP\&. Источник счётчика событий perf
выбирается при обновлении \fImap\fP через файловые дескрипторы событий
perf. Значение \fImap\fP представляет собой массив, размер которого равен
количеству доступных ЦП, а каждая ячейка содержит значение для
соответствующего ЦП. Получаемое значение задаётся в \fIflags\fP, которое
содержит индекс искомого ЦП с наложенной маской \fBBPF_F_INDEX_MASK\fP\&. Или
же \fIflags\fP можно присвоить \fBBPF_F_CURRENT_CPU\fP, которое показывает, что
нужно получать значение для текущего ЦП.
.sp
Заметим, что в до Linux 4.13 можно быть получать только аппаратные события
perf.
.sp
Кроме того, вместо \fBbpf_perf_event_read\fP() рекомендуется использовать новый
помощник \fBbpf_perf_event_read_value\fP(). В старом имеются некоторые
странности в ABI, например в качестве возвращаемого кода используется и
значение ошибки и счётчика (что неправильно, так как эти диапазоны могут
перекрываться). Эта проблема исправлена в \fBbpf_perf_event_read_value\fP(), а
также представляется больше возможностей по сравнению с интерфейсом
\fBbpf_perf_event_read\fP(). Дополнительную информацию смотрите в описании
\fBbpf_perf_event_read_value\fP().
.TP 
\fBВозвращает\fP
Значение счётчика событий perf читается из карты, или отрицательный код
ошибки при невозможности.
.UNINDENT
.TP 
\fBint bpf_redirect(u32 \fP\fIifindex\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Перенаправляет пакет в другое сетевое устройство с индексом
\fIifindex\fP\&. Этот помощник похож на \fBbpf_clone_redirect\fP(), но пакет не
клонируется, что увеличивает производительность.
.sp
Не считая XDP, для перенаправления можно использовать и входящий и исходящий
интерфейсы. Значение \fBBPF_F_INGRESS\fP в \fIflags\fP используется для
направления (если флаг установлен, то выбирается входящий путь, в противном
случае исходящий). В настоящее время, для XDP поддерживается перенаправление
только в исходящий интерфейс, и флаг вообще не учитывается.
.sp
Это действие можно выполнить с помощью большее общего \fBbpf_redirect_map\fP(),
для которого требуются специальные карты, но достигается лучшая
производительность.
.TP 
\fBВозвращает\fP
Для XDP при успешном выполнении помощник возвращает \fBXDP_REDIRECT\fP и
\fBXDP_ABORTED\fP при ошибке. Для других типов программ при успешном выполнении
возвращается \fBTC_ACT_REDIRECT\fP и \fBTC_ACT_SHOT\fP при ошибке.
.UNINDENT
.TP 
\fBu32 bpf_get_route_realm(struct sk_buff *\fP\fIskb\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Находит область (realm) или маршрут, то есть поле \fBtclassid\fP назначения для
\fIskb\fP\&. Найденный идентификатор представляет собой пользовательскую метку,
похожую на используемые в net_cls cgroup (смотрите описание помощника
\fBbpf_get_cgroup_classid\fP()), но здесь эта метка хранится в маршруте
(элементе назначения), а не в задаче.
.sp
Поиск этого идентификатора работает с исходящим перехватчиком (hook) clsact
TC (смотрите также \fBtc\-bpf(8)\fP) или общеупотребительными классовыми
исходящими qdisc, но не на входящих путях TC. В случае с исходящим
перехватчиком clsact TC имеется преимущество, так как внутри элемент
назначения ещё не был отброшен в пути передачи. Поэтому не нужно
искусственно хранить элемент назначения через \fBnetif_keep_dst\fP(), как в
classful qdisc, до тех пор, пока не освобождён \fIskb\fP.
.sp
Этот помощник доступен только, если ядро скомпилировано с параметром
настройки \fBCONFIG_IP_ROUTE_CLASSID\fP.
.TP 
\fBВозвращает\fP
Область маршрута для пакета, связанного с \fIskb\fP или 0, если не найдена.
.UNINDENT
.TP 
\fBint bpf_perf_event_output(struct pt_reg *\fP\fIctx\fP\fB, struct bpf_map *\fP\fImap\fP\fB, u64 \fP\fIflags\fP\fB, void *\fP\fIdata\fP\fB, u64 \fP\fIsize\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Записывает неструктурированные кусок \fIdata\fP в специальное событие BPF perf,
хранящееся в \fImap\fP с типом \fBBPF_MAP_TYPE_PERF_EVENT_ARRAY\fP\&. Это событие
perf должно иметь следующие атрибуты: \fBPERF_SAMPLE_RAW\fP для \fBsample_type\fP,
\fBPERF_TYPE_SOFTWARE\fP для \fBtype\fP и \fBPERF_COUNT_SW_BPF_OUTPUT\fP для
\fBconfig\fP\&.
.sp
Значение \fIflags\fP используется для указания индекса в \fImap\fP, по которому
должно быть записано значение с наложенной маской \fBBPF_F_INDEX_MASK\fP\&. Или
же в \fIflags\fP можно задать \fBBPF_F_CURRENT_CPU\fP для указания того, что
должен использоваться индекс текущего ядра ЦП.
.sp
Записываемое значение размером \fIsize\fP передаётся через стек eBPF и на него
указывает \fIdata\fP\&.
.sp
Помощнику также требуется передать контекст программы \fIctx\fP.
.sp
В пользовательском пространстве программе, которая будет читать значения,
нужно вызвать \fBperf_event_open\fP() при событии perf (или для одного или для
всех ЦП) и сохранить файловый дескриптор в \fImap\fP\&. Это нужно сделать до
того как программа eBPF может послать в него данные. Пример показан в файле
\fIsamples/bpf/trace_output_user.c\fP из дерева исходного кода ядра Linux
(программа eBPF приведена в файле \fIsamples/bpf/trace_output_kern.c\fP).
.sp
У \fBbpf_perf_event_output\fP() большая производительность чем у
\fBbpf_trace_printk\fP() для обмена данными с пользовательским пространством и
он больше подходит для передачи потока данных из программ eBPF.
.sp
Заметим, что этот помощник не ограничен в применении только трассировкой и
может использоваться  также с программами, подключаемыми к TC или XDP, где
позволяет передавать данные слушателям в пользовательском
пространстве. Данными могут быть:
.INDENT 7.0
.IP \(bu 2
Только выборочные структуры,
.IP \(bu 2
Только пакетная полезная нагрузка или
.IP \(bu 2
оба сразу.
.UNINDENT
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_skb_load_bytes(const struct sk_buff *\fP\fIskb\fP\fB, u32 \fP\fIoffset\fP\fB, void *\fP\fIto\fP\fB, u32 \fP\fIlen\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Предназначен для облегчения загрузки данных из пакета. Он загружает \fIlen\fP
байт с адреса \fIoffset\fP из пакета, связанного с \fIskb\fP, в буфер, на который
указывает \fIto\fP\&.
.sp
Начиная с Linux 4.7, использование этого помощника, большей частью заменено
«прямым доступом к пакету», который позволяет управлять данными пакета через
\fIskb\fP\fB\->data\fP и \fIskb\fP\fB\->data_end\fP, указывающими на первый байт
данных пакета и байт, находящийся после последнего байта пакета данных,
соответственно. Однако, помощник всё ещё полезен, если нужно прочитать
большое количество данных за раз из пакета в стек eBPF.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_get_stackid(struct pt_reg *\fP\fIctx\fP\fB, struct bpf_map *\fP\fImap\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Проходит по пользовательскому стеку или стеку ядра и возвращает его id. Для
этого помощнику нужен \fIctx\fP — указатель на контекст, в котором выполняется
трассирующая программа, и указатель на \fImap\fP с типом
\fBBPF_MAP_TYPE_STACK_TRACE\fP\&.
.sp
В последнем параметре, \fIflags\fP, хранится пропускаемое количество кадров
стека (от 0 до 255) с наложенной маской
\fBBPF_F_SKIP_FIELD_MASK\fP\&. Следующие биты можно использовать для задания
комбинации следующих флагов:
.INDENT 7.0
.TP 
\fBBPF_F_USER_STACK\fP
Проходить по стеку пользовательского пространства, а не по стеку ядра.
.TP 
\fBBPF_F_FAST_STACK_CMP\fP
Сравнивать стеки только по хешу.
.TP 
\fBBPF_F_REUSE_STACKID\fP
Если два разных хеша стеков указывают на один \fIstackid\fP, отбросить старый.
.UNINDENT
.sp
Возвращаемый id стека представляет собой 32\-битное длинное целое, которое в
дальнейшем можно объединить с другими данными (включая id других стеков) и
используется как ключ к картам. Он может быть полезен для генерации
различных графиков (например, flame или off\-cpu).
.sp
Для прохода по стеку этот помощник производительнее \fBbpf_probe_read\fP(),
который можно использовать с развёрнутыми циклами, но это не эффективно и
потребляет много инструкций eBPF. Напротив, \fBbpf_get_stackid\fP() может
проходить до \fBPERF_MAX_STACK_DEPTH\fP кадров ядра и пользовательского
стека. Заметим, что это ограничение можно изменить программой \fBsysctl\fP, и
его нужно вручную увеличивать при профилировании длинных пользовательских
стеков (например, от программ Java). Для этого выполните:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
# sysctl kernel.perf_event_max_stack=<новое значение>
.ft P
.fi
.UNINDENT
.UNINDENT
.TP 
\fBВозвращает\fP
При успешном выполнении возвращает положительный или null id стека и
отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBs64 bpf_csum_diff(__be32 *\fP\fIfrom\fP\fB, u32 \fP\fIfrom_size\fP\fB, __be32 *\fP\fIto\fP\fB, u32 \fP\fIto_size\fP\fB, __wsum \fP\fIseed\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Сравнивает контрольную сумму различия неструктурированного буфера, на
который указывает \fIfrom\fP и имеет размер \fIfrom_size\fP (должен быть кратен
4), с неструктурированным буфером, на который указывает \fIto\fP и имеет размер
\fIto_size\fP (тоже примечание). К значению можно добавить необязательный
\fIseed\fP (каскадируется, затравка может поступать из предыдущего вызова
помощника).
.sp
Может использоваться несколькими способами:
.INDENT 7.0
.IP \(bu 2
Если \fIfrom_size\fP == 0, \fIto_size\fP > 0 и \fIseed\fP равно контрольной сумме
— при заталкивании новых данных.
.IP \(bu 2
Если \fIfrom_size\fP > 0, \fIto_size\fP == 0 и \fIseed\fP равно контрольной сумме
— при удалении данных из пакета.
.IP \(bu 2
Если \fIfrom_size\fP > 0, \fIto_size\fP > 0 и \fIseed\fP равно 0 — вычисляет
разницу. Заметим, что \fIfrom_size\fP и \fIto_size\fP могут быть не равны.
.UNINDENT
.sp
Этот помощник можно использовать совместно с \fBbpf_l3_csum_replace\fP() и
\fBbpf_l4_csum_replace\fP(), которым можно передавать различие, вычисленное
\fBbpf_csum_diff\fP().
.TP 
\fBВозвращает\fP
Результат контрольной суммы или отрицательный код ошибки.
.UNINDENT
.TP 
\fBint bpf_skb_get_tunnel_opt(struct sk_buff *\fP\fIskb\fP\fB, u8 *\fP\fIopt\fP\fB, u32 \fP\fIsize\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Возвращает метаданные параметров туннеля для пакета, связанного с \fIskb\fP, и
сохраняет неструктурированные данные параметров туннеля в буфер \fIopt\fP
размером \fIsize\fP\&.
.sp
Этот помощник можно использовать с устройствами инкапсуляции, которые могут
работать в режиме «сбора метаданных» (подробности приведены в замечании к
\fBbpf_skb_get_tunnel_key\fP()). В качестве примера можно привести совместное
использование с протоколом инкапсуляции Geneve, где может вталкивать (с
помощью помощника \fBbpf_skb_get_tunnel_opt\fP()) и получать произвольные TLV
(заголовки Тип\-Длина\-Значение) из программы eBPF. Таким способом можно
изменять эти заголовки полностью.
.TP 
\fBВозвращает\fP
Размер возвращаемых данных.
.UNINDENT
.TP 
\fBint bpf_skb_set_tunnel_opt(struct sk_buff *\fP\fIskb\fP\fB, u8 *\fP\fIopt\fP\fB, u32 \fP\fIsize\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Изменяет метаданные параметров туннеля для пакета, связанного с \fIskb\fP на
данные параметров из неструктурированного буфера \fIopt\fP размером \fIsize\fP\&.
.sp
Также смотрите описание помощника \fBbpf_skb_get_tunnel_opt\fP().
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_skb_change_proto(struct sk_buff *\fP\fIskb\fP\fB, __be16 \fP\fIproto\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Изменяет протокол в \fIskb\fP на \fIproto\fP\&. Пока поддерживается переход с IPv4
на IPv6 и с IPv6 на IPv4. Этот помощник делает всю черновую работу, включая
изменение размера сокетного буфера. Программе eBPF нужно заполнить новые
заголовки, если есть, с помощью \fBskb_store_bytes\fP() и пересчитать
контрольные суммы с помощью \fBbpf_l3_csum_replace\fP() и
\fBbpf_l4_csum_replace\fP(). Основным предназначением этого помощника является
выполнение операций NAT64 вне программы eBPF.
.sp
Внутри, тип GSO помечается как подозрительный, из\-за чего механизм GSO/GRO
проверяется эти заголовки и повторно вычисляет сегменты. Также
подстраивается размер цели GSO.
.sp
Все значения \fIflags\fP зарезервированы для использования в будущем и должны
быть равны нулю.
.sp
Вызов этого помощника приводит к изменению буфера нижележащего
пакета. Поэтому на момент загрузки все проверки указателей, выполненные
ранее верификатором, становятся недействительными и должны быть выполнены
повторно, если кроме помощника используется прямой доступ к пакету.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_skb_change_type(struct sk_buff *\fP\fIskb\fP\fB, u32 \fP\fItype\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Изменяет тип пакета у пакета, связанного с \fIskb\fP\&. При этом только
\fIskb\fP\fB\->pkt_type\fP присваивается \fItype\fP, если программа eBPF не имеет
прав записи в \fIskb\fP\fB\->pkt_type\fP вне этого помощника. При таком
использовании помощник позволяет правильно обработать ошибки.
.sp
В основном, он применяется для изменения входящего \fIskb*s на
**PACKET_HOST*\fP программным методом, а не, например, с помощью перезаписи
через \fBredirect\fP(..., \fBBPF_F_INGRESS\fP).
.sp
Заметим, что \fItype\fP может быть равен только определённым значениям. В
настоящее время это:
.INDENT 7.0
.TP 
\fBPACKET_HOST\fP
Пакет для нас.
.TP 
\fBPACKET_BROADCAST\fP
Послать пакет всем.
.TP 
\fBPACKET_MULTICAST\fP
Послать пакет группе.
.TP 
\fBPACKET_OTHERHOST\fP
Послать пакет кому\-то ещё.
.UNINDENT
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_skb_under_cgroup(struct sk_buff *\fP\fIskb\fP\fB, struct bpf_map *\fP\fImap\fP\fB, u32 \fP\fIindex\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Проверяет, является ли \fIskb\fP потомком cgroup2, хранящейся в \fImap\fP с типом
\fBBPF_MAP_TYPE_CGROUP_ARRAY\fP с индексом \fIindex\fP\&.
.TP 
\fBВозвращает\fP
Возвращаемое значение зависит от результата проверки и может быть:
.INDENT 7.0
.IP \(bu 2
0, если \fIskb\fP не прошло проверку причастности к cgroup2.
.IP \(bu 2
1, если \fIskb\fP прошло проверку причастности к cgroup2.
.IP \(bu 2
Отрицательный код ошибки при её возникновении.
.UNINDENT
.UNINDENT
.TP 
\fBu32 bpf_get_hash_recalc(struct sk_buff *\fP\fIskb\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Возвращает хеш пакета, \fIskb\fP\fB\->hash\fP\&. Если он отсутствует, например,
если хеш очищен при искажении (mangling), то это хеш вычисляется заново. В
последствии к хешу можно обращаться непосредственно, через
\fIskb\fP\fB\->hash\fP\&.
.sp
Вызов \fBbpf_set_hash_invalid\fP(), изменение прототипа пакета с помощью
\fBbpf_skb_change_proto\fP(), или вызов \fBbpf_skb_store_bytes\fP() с
\fBBPF_F_INVALIDATE_HASH\fP приводят к очистке хеша и активируют новое
вычисление при следующем вызове \fBbpf_get_hash_recalc\fP().
.TP 
\fBВозвращает\fP
32\-битный хеш.
.UNINDENT
.TP 
\fBu64 bpf_get_current_task(void)\fP
.INDENT 7.0
.TP 
\fBВозвращает\fP
Указатель на структуру текущей задачи.
.UNINDENT
.TP 
\fBint bpf_probe_write_user(void *\fP\fIdst\fP\fB, const void *\fP\fIsrc\fP\fB, u32 \fP\fIlen\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Пытается безопасным способом записать \fIlen\fP байт из буфера \fIsrc\fP в память
\fIdst\fP. Это работает только для нитей в пользовательском контексте и \fIdst\fP
должен быть корректным адресом пользовательского пространства.
.sp
Этот помощник не нужно использовать для реализации какого\-либо механизма
безопасности в следствии атак TOC\-TOU, а только для отладки, отклонения и
управления выполнением частично сотрудничающих процессов.
.sp
Учтите, что это свойство является экспериментальным и может обрушить систему
и выполняющиеся программы. Поэтому когда присоединяется программа eBPF,
использующая этот помощник, в журнал ядра печатается предупреждение с PID и
именем процесса.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_current_task_under_cgroup(struct bpf_map *\fP\fImap\fP\fB, u32 \fP\fIindex\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Проверяет, выполняется ли тест в контексте заданного поднабора иерархии
cgroup2. Тестируемый cgroup2 задаётся в \fImap\fP, имеет тип
\fBBPF_MAP_TYPE_CGROUP_ARRAY\fP и индекс \fIindex\fP\&.
.TP 
\fBВозвращает\fP
Возвращаемое значение зависит от результата проверки и может быть:
.INDENT 7.0
.IP \(bu 2
0, если задача \fIskb\fP принадлежит cgroup2.
.IP \(bu 2
1, если задача \fIskb\fP не принадлежит cgroup2.
.IP \(bu 2
Отрицательный код ошибки при её возникновении.
.UNINDENT
.UNINDENT
.TP 
\fBint bpf_skb_change_tail(struct sk_buff *\fP\fIskb\fP\fB, u32 \fP\fIlen\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Изменяет размер (обрезает или расширяет) пакета, связанного с  \fIskb\fP, на
новый \fIlen\fP\&. Значения \fIflags\fP зарезервированы для использования в
будущем и должны быть равны нулю.
.sp
По замыслу, помощник выполняет необходимую работу по изменению размера
пакет, затем программа eBPF перезаписывает остальное через помощников
\fBbpf_skb_store_bytes\fP(), \fBbpf_l3_csum_replace\fP(), \fBbpf_l3_csum_replace\fP()
и других. Этот помощник является инструментом для медленного пути и
предназначен для ответов управляющими сообщениями. Из\-за нацелевания на
медленный путь, сам помощник можно было делать медленным: он неявным образом
преобразует к линейному виду, извлекает копии и удаляет нагрузку из
\fIskb\fP\&.
.sp
Вызов этого помощника приводит к изменению буфера нижележащего
пакета. Поэтому на момент загрузки все проверки указателей, выполненные
ранее верификатором, становятся недействительными и должны быть выполнены
повторно, если кроме помощника используется прямой доступ к пакету.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_skb_pull_data(struct sk_buff *\fP\fIskb\fP\fB, u32 \fP\fIlen\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Стягивает в нелинейные данные, если \fIskb\fP является нелинейной и не вся
длина \fIlen\fP является частью линейного раздела. Делает \fIlen\fP байт из \fIskb\fP
доступными для чтения и записи. Если \fIlen\fP равно нулю, то \fIskb\fP
стягивается полностью.
.sp
Этот помощник необходим только для чтения и записи в пакет напрямую.
.sp
При прямом доступе к пакету тест доступа по этим смещениям внутри границ
пакета (до \fIskb\fP\fB\->data_end\fP) завершится ошибкой, если смещения
некорректны, или если запрашиваемые данные находятся в нелинейной части
\fIskb\fP\&. При ошибке программа может просто завершить работу или, в случае
нелинейного буфера, использовать помощник, чтобы сделать данные
доступными. Помощник \fBbpf_skb_load_bytes\fP() — первое средство для доступа к
данным. Также можно использовать \fBbpf_skb_pull_data\fP для стягивания
нелинейных частей в одну, а затем повторить тест и получить доступ к данным.
.sp
Также проверяется, что \fIskb\fP не клонирована, это является необходимым
условием прямой записи. Поскольку постоянство должно быть инвариантом только
для записи, верификатор обнаруживает действие записи и добавляет пролог,
который вызывает \fBbpf_skb_pull_data()\fP для эффективного расклонирования
\fIskb\fP в самом начале, если есть действительно клонирование.
.sp
Вызов этого помощника приводит к изменению буфера нижележащего
пакета. Поэтому на момент загрузки все проверки указателей, выполненные
ранее верификатором, становятся недействительными и должны быть выполнены
повторно, если кроме помощника используется прямой доступ к пакету.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBs64 bpf_csum_update(struct sk_buff *\fP\fIskb\fP\fB, __wsum \fP\fIcsum\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Добавляет контрольную сумму \fIcsum\fP в \fIskb\fP\fB\->csum\fP, если драйвер
вставлял контрольную сумму для всего пакета в этом поле. В противном случае
возвращается ошибка. Этот помощник предназначен для совместной работы с
\fBbpf_csum_diff\fP(), в случае, когда контрольную сумму нужно обновить после
прямой записи в пакет.
.TP 
\fBВозвращает\fP
При успешном выполнении — контрольная сумма или отрицательный код ошибки.
.UNINDENT
.TP 
\fBvoid bpf_set_hash_invalid(struct sk_buff *\fP\fIskb\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Делает текущий \fIskb\fP\fB\->hash\fP недействительным. Это можно использовать
после искажения (mangling) заголовков через прямой доступ к пакету, чтобы
показать, что хэш устарел и активировать пересчёт в следующий раз, когда
ядро попытается обратиться к этому хэшу или когда будет вызван помощник
\fBbpf_get_hash_recalc\fP().
.UNINDENT
.TP 
\fBint bpf_get_numa_node_id(void)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Возвращает id текущего узла NUMA. Основным предназначением помощника
является выбор сокетов локального узла NUMA, когда программа присоединяется
к сокетам посредством параметра \fBSO_ATTACH_REUSEPORT_EBPF\fP (смотрите также
\fBsocket(7)\fP), но помощник доступен и другим типам программ eBPF, например
\fBbpf_get_smp_processor_id\fP().
.TP 
\fBВозвращает\fP
ID текущего узла NUMA.
.UNINDENT
.TP 
\fBint bpf_skb_change_head(struct sk_buff *\fP\fIskb\fP\fB, u32 \fP\fIlen\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Увеличивает место под заголовок пакета, связанного с \fIskb\fP и делает
соответствующее смещение заголовка MAC, добавляя \fIlen\fP байт
пространства. Автоматически расширяет и переразмещает память как нужно.
.sp
Этот помощник также можно использовать в \fIskb\fP на уровне 3, чтобы
затолкнуть заголовок MAC для перенаправления в устройство уровня 2.
.sp
Все значения \fIflags\fP зарезервированы для использования в будущем и должны
быть равны нулю.
.sp
Вызов этого помощника приводит к изменению буфера нижележащего
пакета. Поэтому на момент загрузки все проверки указателей, выполненные
ранее верификатором, становятся недействительными и должны быть выполнены
повторно, если кроме помощника используется прямой доступ к пакету.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_xdp_adjust_head(struct xdp_buff *\fP\fIxdp_md\fP\fB, int \fP\fIdelta\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Подгоняет (перемещает) \fIxdp_md\fP\fB\->data\fP на \fIdelta\fP байт. Заметим, что
можно использовать отрицательное значение \fIdelta\fP\&. Этот помощник можно
использовать при подготовке пакета к вталкиванию и выталкиванию заголовков.
.sp
Вызов этого помощника приводит к изменению буфера нижележащего
пакета. Поэтому на момент загрузки все проверки указателей, выполненные
ранее верификатором, становятся недействительными и должны быть выполнены
повторно, если кроме помощника используется прямой доступ к пакету.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_probe_read_str(void *\fP\fIdst\fP\fB, int \fP\fIsize\fP\fB, const void *\fP\fIunsafe_ptr\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Копирует строку с NUL в конце с опасного адреса \fIunsafe_ptr\fP в \fIdst\fP\&. В
значении \fIsize\fP нужно учитывать конечный байт NUL. Если длина строки меньше
\fIsize\fP, то цель не дополняется байтами NUL. Если длина строки больше
\fIsize\fP, то копируется \fIsize\fP\-1 байт, а в последний байт записывается NUL.
.sp
При успешном выполнении возвращается длина скопированной строки. Это делает
помощник полезным в трассирующих программах для чтения строк, и где важно
получать её длину в время выполнения. Посмотрите следующий фрагмент:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
SEC("kprobe/sys_open")
void bpf_sys_open(struct pt_regs *ctx)
        char buf[PATHLEN]; // PATHLEN равно 256
        int res = bpf_probe_read_str(buf, sizeof(buf),
                                     ctx\->di);

        // Заполняем buf, например, для отдачи в
        // пространство пользователя через bpf_perf_event_output();
        // можно использовать res (длину строки) как размер
        // события после проверки её границ.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
По сравнению с помощником \fBbpf_probe_read()\fP, ему бы здесь вместо чтения
строки потребовалось вычислить длину во время компиляции и в результате
скопировать больше памяти чем нужно.
.sp
Другим полезным применением является разбор отдельных аргументов процесса
или переменных окружения посредством прохода через
\fIcurrent\fP\fB\->mm\->arg_start\fP и \fIcurrent\fP\fB\->mm\->env_start\fP:
используя этот помощник и возвращаемое значение можно быстро обойти область
памяти от правого смещения.
.TP 
\fBВозвращает\fP
При успешном выполнении — только положительная длина строки, включая
конечный символ NUL. При ошибке — отрицательное значение.
.UNINDENT
.TP 
\fBu64 bpf_get_socket_cookie(struct sk_buff *\fP\fIskb\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Если \fBstruct sk_buff\fP, указывающая на \fIskb\fP, содержит известный сокет, то
возвращает куки (cookie, генерируется ядром) сокета. Если куки ещё не
назначена, то генерируется новая куки. После генерации куки сокета не
меняется на всём протяжении жизни сокета. Этот помощник полезен для слежения
за статистикой сетевого трафика отдельных сокетов, так как предоставляет
уникальный идентификатор сокета в каждом пространстве имён.
.TP 
\fBВозвращает\fP
При успешном выполнении — 8\-байтовое длинное неуменьшающееся число, или 0,
если в \fIskb\fP отсутствует поле сокета.
.UNINDENT
.TP 
\fBu64 bpf_get_socket_cookie(struct bpf_sock_addr *\fP\fIctx\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Эквивалентен помощнику bpf_get_socket_cookie(), имеющему параметр \fIskb\fP,
вместо которого принимает сокет из контекста \fBstruct bpf_sock_addr\fP.
.TP 
\fBВозвращает\fP
При успешном выполнении — 8\-байтовое длинное неуменьшающееся число.
.UNINDENT
.TP 
\fBu64 bpf_get_socket_cookie(struct bpf_sock_ops *\fP\fIctx\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Эквивалентен помощнику bpf_get_socket_cookie(), имеющему параметр \fIskb\fP,
вместо которого принимает сокет из контекста \fBstruct bpf_sock_ops\fP.
.TP 
\fBВозвращает\fP
При успешном выполнении — 8\-байтовое длинное неуменьшающееся число.
.UNINDENT
.TP 
\fBu32 bpf_get_socket_uid(struct sk_buff *\fP\fIskb\fP\fB)\fP
.INDENT 7.0
.TP 
\fBВозвращает\fP
Возвращает UID владельца сокета, связанного с \fIskb\fP\&. Если значение сокета
равно \fBNULL\fP, или если это не полный сокет (т. е., если это сокет time\-wait
или request), то возвращает значение \fBoverflowuid\fP (заметим, что
\fBoverflowuid\fP также может действующим UID значением сокета).
.UNINDENT
.TP 
\fBu32 bpf_set_hash(struct sk_buff *\fP\fIskb\fP\fB, u32 \fP\fIhash\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Присваивает значение \fIhash\fP полному хэшу \fIskb\fP (поле \fIskb\fP\fB\->hash\fP).
.TP 
\fBВозвращает\fP
.UNINDENT
.TP 
\fBint bpf_setsockopt(struct bpf_sock_ops *\fP\fIbpf_socket\fP\fB, int \fP\fIlevel\fP\fB, int \fP\fIoptname\fP\fB, char *\fP\fIoptval\fP\fB, int \fP\fIoptlen\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Эмулирует вызов \fBsetsockopt()\fP для сокета, связанного с \fIbpf_socket\fP,
который должен быть полным сокетом. Должны быть заданы уровень \fIlevel\fP, на
котором располагается параметр, и и имя \fIoptname\fP, подробности смотрите в
\fBsetsockopt(2)\fP. Значение параметра \fIoptlen\fP задаётся в \fIoptval\fP\&.
.sp
В действительности этот помощник реализует поднабор \fBsetsockopt()\fP\&. Он
поддерживает следующие уровни \fIlevel\fP:
.INDENT 7.0
.IP \(bu 2
\fBSOL_SOCKET\fP, который поддерживает следующие \fIoptname\fP: \fBSO_RCVBUF\fP,
\fBSO_SNDBUF\fP, \fBSO_MAX_PACING_RATE\fP, \fBSO_PRIORITY\fP, \fBSO_RCVLOWAT\fP,
\fBSO_MARK\fP\&.
.IP \(bu 2
\fBIPPROTO_TCP\fP, который поддерживает следующие \fIoptname\fP:
\fBTCP_CONGESTION\fP, \fBTCP_BPF_IW\fP, \fBTCP_BPF_SNDCWND_CLAMP\fP\&.
.IP \(bu 2
\fBIPPROTO_IP\fP, который поддерживает \fIoptname\fP \fBIP_TOS\fP\&.
.IP \(bu 2
\fBIPPROTO_IPV6\fP, который поддерживает \fIoptname\fP \fBIPV6_TCLASS\fP\&.
.UNINDENT
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_skb_adjust_room(struct sk_buff *\fP\fIskb\fP\fB, s32 \fP\fIlen_diff\fP\fB, u32 \fP\fImode\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Расширяет или сужает место под данные в пакете, связанном с \fIskb\fP, на
\fIlen_diff\fP и в соответствии с выбранным режимом \fImode\fP\&.
.sp
На данный момент поддерживается только один режим:
.INDENT 7.0
.IP \(bu 2
\fBBPF_ADJ_ROOM_NET\fP: изменить пространство на сетевом уровне (пространство
добавляется или удаляется после заголовка 3 уровня).
.UNINDENT
.sp
Все значения \fIflags\fP зарезервированы для использования в будущем и должны
быть равны нулю.
.sp
Вызов этого помощника приводит к изменению буфера нижележащего
пакета. Поэтому на момент загрузки все проверки указателей, выполненные
ранее верификатором, становятся недействительными и должны быть выполнены
повторно, если кроме помощника используется прямой доступ к пакету.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_redirect_map(struct bpf_map *\fP\fImap\fP\fB, u32 \fP\fIkey\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Перенаправляет пакет в конечную точку, на которую указывает \fIkey\fP в
\fImap\fP. В зависимости от её типа, в \fImap\fP могут содержаться ссылки на
сетевые устройства (для пересылки пакетов через другие порты), или ЦП (для
перенаправления кадров XDP в другой ЦП; на момент написания это реализовано
только для родных XDP (с поддержкой драйверов)).
.sp
Все значения \fIflags\fP зарезервированы для использования в будущем и должны
быть равны нулю.
.sp
При использовании перенаправления пакетов в сетевые устройства этот помощник
предоставляет более высокую производительность чем \fBbpf_redirect\fP(). Это
стало возможным из\-за различия в нижележащих механизмах, например,
\fBbpf_redirect_map\fP() пытается отправить пакет в устройство «оптом».
.TP 
\fBВозвращает\fP
При успешном выполнении — \fBXDP_REDIRECT\fP, \fBXDP_ABORTED\fP — при ошибке.
.UNINDENT
.TP 
\fBint bpf_sk_redirect_map(struct bpf_map *\fP\fImap\fP\fB, u32 \fP\fIkey\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Перенаправляет пакет в сокет, на который указывает \fIkey\fP в \fImap\fP (тип
\fBBPF_MAP_TYPE_SOCKMAP\fP). Для перенаправления могут использоваться как
входящий так и исходящий интерфейсы. В качестве отличительного признака в
\fIflags\fP используется значение \fBBPF_F_INGRESS\fP (выбирается входящий путь,
если флаг указан, в противном случае — исходящий). В настоящее время
поддерживается только этот флаг.
.TP 
\fBВозвращает\fP
При успешном выполнении — \fBSK_PASS\fP, \fBSK_DROP\fP — при ошибке.
.UNINDENT
.TP 
\fBint bpf_sock_map_update(struct bpf_sock_ops *\fP\fIskops\fP\fB, struct bpf_map *\fP\fImap\fP\fB, void *\fP\fIkey\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Добавляет или обновляет элемент, ссылающийся на сокет, в \fImap\fP. В качестве
нового значение элемента, связанного с \fIkey\fP, используется
\fIskops\fP. Значением \fIflags\fP может быть одно из:
.INDENT 7.0
.TP 
\fBBPF_NOEXIST\fP
Запись для \fIkey\fP не должна существовать в карте.
.TP 
\fBBPF_EXIST\fP
Запись для \fIkey\fP должна существовать в карте.
.TP 
\fBBPF_ANY\fP
Не учитывать условие существования записи для \fIkey\fP\&.
.UNINDENT
.sp
Если \fImap\fP содержит программы eBPF (анализатор и решение), то они будут
наследоваться сокетом, который добавляется. Если сокет уже присоединён к
программам eBPF, то возвращается ошибка.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_xdp_adjust_meta(struct xdp_buff *\fP\fIxdp_md\fP\fB, int \fP\fIdelta\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Изменяет адрес, указанный в \fIxdp_md\fP\fB\->data_meta\fP, на значение
\fIdelta\fP (положительное или отрицательное). Заметим, что эта операция
изменяет адрес, хранящийся в \fIxdp_md\fP\fB\->data\fP, поэтому последний
должен быть загружен только после того, как был вызван помощник.
.sp
Использование поля \fIxdp_md\fP\fB\->data_meta\fP необязательно и программам
оно не требуется. Когда пакет обрабатывается с помощью XDP (например,
фильтром DoS), перед передачей в стек вместе с ним возможно втолкнуть
дополнительные метаданные и гарантируется, что входящая программа eBPF,
подключённая как классификатор TC к тому же устройству, сможет подобрать их
для дальнейшей пост\-обработки. Так как TC работает с буферами сокетов,
остаётся возможность задать из XDP указатели \fBmark\fP или \fBpriority\fP, или
другие указатели для буфера сокета. Такое рабочее программируемое и
универсальное пространство предоставляет большую гибкость, поскольку
пользователь может хранить любые метаданных какие захочет.
.sp
Вызов этого помощника приводит к изменению буфера нижележащего
пакета. Поэтому на момент загрузки все проверки указателей, выполненные
ранее верификатором, становятся недействительными и должны быть выполнены
повторно, если кроме помощника используется прямой доступ к пакету.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_perf_event_read_value(struct bpf_map *\fP\fImap\fP\fB, u64 \fP\fIflags\fP\fB, struct bpf_perf_event_value *\fP\fIbuf\fP\fB, u32 \fP\fIbuf_size\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Читает значение счётчика событий perf и сохраняет его в \fIbuf\fP размером
\fIbuf_size\fP\&. Этот помощник использует \fImap\fP с типом
\fBBPF_MAP_TYPE_PERF_EVENT_ARRAY\fP\&. Источник счётчика событий perf
выбирается при обновлении \fImap\fP через файловые дескрипторы событий
perf. Значение \fImap\fP представляет собой массив, размер которого равен
количеству доступных ЦП, а каждая ячейка содержит значение для
соответствующего ЦП. Получаемое значение задаётся в \fIflags\fP, которое
содержит индекс искомого ЦП с наложенной маской \fBBPF_F_INDEX_MASK\fP\&. Или
же \fIflags\fP можно присвоить \fBBPF_F_CURRENT_CPU\fP, которое показывает, что
нужно получать значение для текущего ЦП.
.sp
Этот помощник работает почти также как \fBbpf_perf_event_read\fP(), но не
возвращает значение, а помещает его в структуру \fIbuf\fP. Это позволяет
получать дополнительные данные,в частности, копируется время включения и
выполнения (в \fIbuf\fP\fB\->enabled\fP и\fIbuf\fP\fB\->running\fP,
соответственно). В общем, рекомендуется использовать
\fBbpf_perf_event_read_value\fP() вместо \fBbpf_perf_event_read\fP(), у которого
есть проблемы с ABI и который имеет меньше возможностей.
.sp
Эти значения существенны, так как аппаратные счётчики PMU (Performance
Monitoring Unit) — ограниченный ресурс. Когда открыто больше PMU (на основе
событий perf), чем доступно счётчиков, ядро будет мультиплексировать эти
события; при этом каждое событие получает определённый процент (но не всё)
времени PMU. Если возникает мультиплексирование, количество выборок или
значение счетчика не будет отражать происходящее, по сравнению, если бы
мультиплексирования не было. Это затрудняет сравнение между несколькими
запусками. Обычно, значение счётчика нужно нормализовать перед сравнением с
другими экспериментами. Это выполняется следующим образом:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
normalized_counter = counter * t_enabled / t_running
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Где t_enabled — время включения события и t_running — время выполнения
события, начиная с последней нормализации. Времена включения и выполнения
накапливаются с момента открытия события perf. Для получения масштабирующего
множителя между двумя вызовами программы eBPF пользователь может
использовать ID ЦП в качестве ключа (типично при использовании массива perf)
для запоминания предыдущего значения и выполнить вычисление внутри программы
eBPF.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_perf_prog_read_value(struct bpf_perf_event_data *\fP\fIctx\fP\fB, struct bpf_perf_event_value *\fP\fIbuf\fP\fB, u32 \fP\fIbuf_size\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Для программы eBPF, присоединённой к событию perf, возвращает значение
счётчика события, связанного с \fIctx\fP, и записывает его в структуру, на
которую указывает \fIbuf\fP и размер \fIbuf_size\fP\&. Время включения и
выполнения также записываются в структуру (смотрите описание помощника
\fBbpf_perf_event_read_value\fP()).
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_getsockopt(struct bpf_sock_ops *\fP\fIbpf_socket\fP\fB, int \fP\fIlevel\fP\fB, int \fP\fIoptname\fP\fB, char *\fP\fIoptval\fP\fB, int \fP\fIoptlen\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Эмулирует вызов \fBgetsockopt()\fP для сокета, связанного с \fIbpf_socket\fP,
который должен быть полным сокетом. Должны быть заданы уровень \fIlevel\fP, на
котором располагается параметр, и и имя \fIoptname\fP, подробности смотрите в
\fBgetsockopt(2)\fP. Возвращаемое значение записывается в структуру, на которую
указывает \fIopval\fP, и имеющая размер \fIoptlen\fP\&.
.sp
В действительности этот помощник реализует поднабор \fBgetsockopt()\fP\&. Он
поддерживает следующие уровни \fIlevel\fP:
.INDENT 7.0
.IP \(bu 2
\fBIPPROTO_TCP\fP, который поддерживает \fIoptname\fP \fBTCP_CONGESTION\fP\&.
.IP \(bu 2
\fBIPPROTO_IP\fP, который поддерживает \fIoptname\fP \fBIP_TOS\fP\&.
.IP \(bu 2
\fBIPPROTO_IPV6\fP, который поддерживает \fIoptname\fP \fBIPV6_TCLASS\fP\&.
.UNINDENT
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_override_return(struct pt_reg *\fP\fIregs\fP\fB, u64 \fP\fIrc\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Используется для вставки ошибки; этот помощник использует kprobes для
перезаписи возвращаемого значения тестируемой (probed) функции и изменяет её
на \fIrc\fP\&. С первым аргументом — контекст \fIregs\fP — работает kprobe.
.sp
Этот помощник изменяет PC (программный счётчик) на перезаписываемую функцию,
которая выполняется вместо изначальной тестируемой функции. Это означает,
что тестируемая функция вообще не выполняется. Заменяющая функция просто
возвращает требуемое значение.
.sp
Этот помощник является потенциальным нарушителем безопасности и поэтому
подвергнут ограничениям. Он доступен только, если ядро скомпилировано с
параметром настройки \fBCONFIG_BPF_KPROBE_OVERRIDE\fP и при этом работает
только с функциями, помеченными \fBALLOW_ERROR_INJECTION\fP в коде ядре.
.sp
Также помощник доступен только на архитектурах, имеющих параметр
CONFIG_FUNCTION_ERROR_INJECTION. На момент написания справки, только
архитектура x86 поддерживает данное свойство.
.TP 
\fBВозвращает\fP
.UNINDENT
.TP 
\fBint bpf_sock_ops_cb_flags_set(struct bpf_sock_ops *\fP\fIbpf_sock\fP\fB, int \fP\fIargval\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Пытается присвоить значение \fIargval\fP полю \fBbpf_sock_ops_cb_flags\fP для
полного сокета TCP, связанного с \fIbpf_sock_ops\fP.
.sp
Основным предназначением этого поля является определение, вызывать ли
программы eBPF с типом \fBBPF_PROG_TYPE_SOCK_OPS\fP в различных случаях из кода
TCP. Программа такого типа может менять это значение для каждого соединения,
если нужно, после установления соединения. Это поле доступно для прямого
чтения, но данный помощник нужно использовать, чтобы получить ошибку
обновления, если программа eBPF пытается назначить обратный вызов, который
не поддерживается в текущем ядре.
.sp
Поддерживаемые значения обратных вызовов, которые можно объединять в
\fIargval\fP:
.INDENT 7.0
.IP \(bu 2
\fBBPF_SOCK_OPS_RTO_CB_FLAG\fP (истекло время повторной передачи)
.IP \(bu 2
\fBBPF_SOCK_OPS_RETRANS_CB_FLAG\fP (повторная передача)
.IP \(bu 2
\fBBPF_SOCK_OPS_STATE_CB_FLAG\fP (изменение состояния TCP)
.UNINDENT
.sp
Вот некоторые примеры, когда может вызываться такая программа eBPF:
.INDENT 7.0
.IP \(bu 2
При возникновении RTO.
.IP \(bu 2
При повторной посылке пакета.
.IP \(bu 2
При завершении соединения.
.IP \(bu 2
При посылке пакета.
.IP \(bu 2
При получении пакета.
.UNINDENT
.TP 
\fBВозвращает\fP
Код \fB\-EINVAL\fP, если сокет не является полным сокетом TCP; в противном
случае возвращается положительное число, содержащее биты, которые не могут
быть установлены (то есть 0, если установлены все требуемые биты).
.UNINDENT
.TP 
\fBint bpf_msg_redirect_map(struct sk_msg_buff *\fP\fImsg\fP\fB, struct bpf_map *\fP\fImap\fP\fB, u32 \fP\fIkey\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Этот помощник используется в программах, которые описывают политики на
уровне сокета. Если сообщению \fImsg\fP разрешено проходить дальше (т. е., если
решающая программа eBPF вернула \fBSK_PASS\fP), то оно перенаправляется в
сокет, на который указывает индекс \fIkey\fP\fIkey\fP в \fImap\fP (с типом
\fBBPF_MAP_TYPE_SOCKMAP\fP). Для перенаправления можно использовать как
входящий так и исходящий интерфейсы. В качестве отличительного признака в
\fIflags\fP используется значение \fBBPF_F_INGRESS\fP (выбирается входящий путь,
если флаг указан, в противном случае — исходящий). В настоящее время
поддерживается только этот флаг.
.TP 
\fBВозвращает\fP
При успешном выполнении — \fBSK_PASS\fP, \fBSK_DROP\fP — при ошибке.
.UNINDENT
.TP 
\fBint bpf_msg_apply_bytes(struct sk_msg_buff *\fP\fImsg\fP\fB, u32 \fP\fIbytes\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Для политик сокетов; выносит решение программе eBPF о следующих \fIbytes\fP
(количество байт) сообщения \fImsg\fP\&.
.sp
Например, этот помощник можно использовать в следующих случаях:
.INDENT 7.0
.IP \(bu 2
Одиночный системный вызов \fBsendmsg\fP() или \fBsendfile\fP() содержит несколько
логических сообщений, которые программа eBPF хочет прочитать и для которых
нужно принять решение.
.IP \(bu 2
Программа eBPF заботится о чтении только первых \fIbytes\fP из \fImsg\fP\&. Если
сообщение содержит больше полезной нагрузки, то для всех байт приходится
настраиваить параметры и вызывать программу eBPF в цикле, хотя решение уже
известно, что приводит к ненужным затратам.
.UNINDENT
.sp
При вызове из программы eBPF, помощник настраивает внутренний счётчик в
инфраструктуре BPF, который используется для выборки последнего решения для
следующих \fIbytes\fP\&. Если значение \fIbytes\fP меньше, чем текущих данных,
полученных из системного вызова \fBsendmsg\fP() или \fBsendfile\fP(), то будут
посланы первые \fIbytes\fP и программа eBPF выполнится повторно с указателем на
начало данных, описывающим байт номер \fIbytes\fP \fB+ 1\fP\&. Если значение
\fIbytes\fP больше текущих обрабатываемых данных, то следующее решение eBPF
будет применено к нескольких вызовам \fBsendmsg\fP() или \fBsendfile\fP(), пока не
израсходуются все \fIbytes\fP.
.sp
Заметим, что если сокет закрыт с значением внутреннего счётчика отличным от
нуля, то это не проблема, так как данные не буферизуются для \fIbytes\fP и
пошлются сразу при получении.
.TP 
\fBВозвращает\fP
.UNINDENT
.TP 
\fBint bpf_msg_cork_bytes(struct sk_msg_buff *\fP\fImsg\fP\fB, u32 \fP\fIbytes\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Для политик сокетов; предотвращает выполнение программы eBPF, выносящей
решение для сообщения \fImsg\fP до тех пор, пока не наберётся количество байт
\fIbytes\fP.
.sp
Это можно использовать, когда для принятия решения нужно определённое
количество байт, даже если данные распределены между несколькими вызовами
\fBsendmsg\fP() или \fBsendfile\fP(). Можно представить крайний случай, когда
пользователь вызывает \fBsendmsg\fP() несколько раз разбивания сообщение по 1
байту. Очевидно, что это плохо сказывается на производительности, хотя и
работает. Если программе eBPF для проверки заголовка нужно \fIbytes\fP байт, то
помощник можно использовать для задержки вызова программы eBPF до тех пор,
пока не будет накоплено нужное количество \fIbytes\fP.
.TP 
\fBВозвращает\fP
.UNINDENT
.TP 
\fBint bpf_msg_pull_data(struct sk_msg_buff *\fP\fImsg\fP\fB, u32 \fP\fIstart\fP\fB, u32 \fP\fIend\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Для политик сокетов; вытягивает нелинейные данные в \fImsg\fP из
пользовательского пространства и изменяет указатели \fImsg\fP\fB\->data\fP и
\fImsg\fP\fB\->data_end\fP на \fIstart\fP и \fIend\fP байтового смещения в \fImsg\fP,
соответственно.
.sp
Если программа имеет тип \fBBPF_PROG_TYPE_SK_MSG\fP  и выполняется для \fImsg\fP,
то она может обрабатывать только данные, для которых уже настроены указатели
(\fBdata\fP, \fBdata_end\fP). Для перехватчиков \fBsendmsg\fP(), это, вероятно,
первый элемент scatterlist. Но для вызовов полагающихся на обработчик
\fBsendpage\fP (например, \fBsendfile\fP()), это будет диапазон (\fB0\fP, \fB0\fP), так
как данные совместно используются с пространством пользователя и по
умолчанию стремятся избегать разрешать пользовательскому пространству
изменять данные во время (или после) принятия решения eBPF. Этот помощник
можно использовать для вытягивания данных и настройки указателей начала и
конца на заданные значения. Данные будут скопированы при необходимости
(т. е., если данные нелинейные и если указатели начала и конца не указывают
на ту же часть).
.sp
Вызов этого помощника приводит к изменению буфера нижележащего
пакета. Поэтому на момент загрузки все проверки указателей, выполненные
ранее верификатором, становятся недействительными и должны быть выполнены
повторно, если кроме помощника используется прямой доступ к пакету.
.sp
Все значения \fIflags\fP зарезервированы для использования в будущем и должны
быть равны нулю.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_bind(struct bpf_sock_addr *\fP\fIctx\fP\fB, struct sockaddr *\fP\fIaddr\fP\fB, int \fP\fIaddr_len\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Привязывает сокет, связанный с \fIctx\fP, с адресом, на который указывает
\fIaddr\fP, с длиной \fIaddr_len\fP\&. Это позволяет создавать исходящее
соединение с желаемого IP\-адреса, что может быть полезно, например, когда
все процессы внутри cgroup должны использовать единый IP\-адрес на узле с
несколькими настроенными IP.
.sp
Этот помощник работает с IPv4 и IPv6, сокетами TCP и UDP. Домен
(\fIaddr\fP\fB\->sa_family\fP) должен быть \fBAF_INET\fP (или \fBAF_INET6\fP). Поиск
свободного порта для привязки может быть затратным, поэтому помощник не
разрешает привязку к порту: \fIaddr\fP\fB\->sin_port\fP (или \fBsin6_port\fP,
соответственно) должны быть равны нулю.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_xdp_adjust_tail(struct xdp_buff *\fP\fIxdp_md\fP\fB, int \fP\fIdelta\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Изменяет (перемещает) \fIxdp_md\fP\fB\->data_end\fP на \fIdelta\fP байт. Возможно
только уменьшить пакет при записи, поэтому значение \fIdelta\fP должно быть
отрицательным integer.
.sp
Вызов этого помощника приводит к изменению буфера нижележащего
пакета. Поэтому на момент загрузки все проверки указателей, выполненные
ранее верификатором, становятся недействительными и должны быть выполнены
повторно, если кроме помощника используется прямой доступ к пакету.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_skb_get_xfrm_state(struct sk_buff *\fP\fIskb\fP\fB, u32 \fP\fIindex\fP\fB, struct bpf_xfrm_state *\fP\fIxfrm_state\fP\fB, u32 \fP\fIsize\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Получает состояние XFRM (инфраструктура преобразования IP, смотрите
\fBip\-xfrm(8)\fP) по \fIindex\fP «пути безопасности» XFRM для \fIskb\fP\&.
.sp
Полученное состояние сохраняется в \fBstruct bpf_xfrm_state\fP, на который
указывает \fIxfrm_state\fP, и с длиной \fIsize\fP\&.
.sp
Все значения \fIflags\fP зарезервированы для использования в будущем и должны
быть равны нулю.
.sp
Этот помощник доступен только, если ядро скомпилировано с параметром
настройки \fBCONFIG_XFRM\fP.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_get_stack(struct pt_regs *\fP\fIregs\fP\fB, void *\fP\fIbuf\fP\fB, u32 \fP\fIsize\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Возвращает пользовательский и ядерный стек в буфер, предоставляемый
программой bpf. Для этого помощнику требуется \fIctx\fP — указатель на контекст
выполнения трассирующей программы. Для сохранения stacktrace программа bpf
предоставляет \fIbuf\fP с неотрицательным \fIsize\fP\&.
.sp
В последнем параметре, \fIflags\fP, хранится пропускаемое количество кадров
стека (от 0 до 255) с наложенной маской
\fBBPF_F_SKIP_FIELD_MASK\fP\&. Следующие биты можно использовать для задания
следующих флагов:
.INDENT 7.0
.TP 
\fBBPF_F_USER_STACK\fP
Проходить по стеку пользовательского пространства, а не по стеку ядра.
.TP 
\fBBPF_F_USER_BUILD_ID\fP
Собирать buildid+смещение вместо ips пользовательского стека, доступен
только, если также указан \fBBPF_F_USER_STACK\fP.
.UNINDENT
.sp
Помощник \fBbpf_get_stack\fP() может собирать до \fBPERF_MAX_STACK_DEPTH\fP
ядерных и пользовательских кадров, что требует значительно большего размера
буфера. Заметим, что это ограничение можно изменять программой \fBsysctl\fP, и
что его нужно вручную увеличивать, если нужно отсматривать длинные
пользовательские стеки (например, стеки программ Java). Для этого выполните:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
# sysctl kernel.perf_event_max_stack=<новое значение>
.ft P
.fi
.UNINDENT
.UNINDENT
.TP 
\fBВозвращает\fP
При успешном выполнении — неотрицательное значение, меньшее или равное
\fIsize\fP; при ошибке — отрицательный код.
.UNINDENT
.TP 
\fBint bpf_skb_load_bytes_relative(const struct sk_buff *\fP\fIskb\fP\fB, u32 \fP\fIoffset\fP\fB, void *\fP\fIto\fP\fB, u32 \fP\fIlen\fP\fB, u32 \fP\fIstart_header\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Этот помощник похож на \fBbpf_skb_load_bytes\fP() тем, что предоставляет
простой способ загрузки \fIlen\fP байт из смещения \fIoffset\fP в пакете,
связанном с \fIskb\fP, в буфер, на который указывает \fIto\fP\&. Отличие от
\fBbpf_skb_load_bytes\fP() в том, что имеется пятый аргумент \fIstart_header\fP,
позволяющий выбрать базовое начальное смещение. Значением \fIstart_header\fP
может быть одно из:
.INDENT 7.0
.TP 
\fBBPF_HDR_START_MAC\fP
Базовое смещение для загрузки данных из заголовка mac \fIskb\fP.
.TP 
\fBBPF_HDR_START_NET\fP
Базовое смещение для загрузки данных из заголовка сети \fIskb\fP.
.UNINDENT
.sp
В общем случае, «прямой доступ к пакету» является предпочтительным методом
доступа к данным пакета, однако, этот помощник иногда полезен в сокетных
фильтрах, где \fIskb\fP\fB\->data\fP не всегда указывает на начало заголовка
mac и «прямой доступ к пакету» недоступен.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_fib_lookup(void *\fP\fIctx\fP\fB, struct bpf_fib_lookup *\fP\fIparams\fP\fB, int \fP\fIplen\fP\fB, u32 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Выполняет поиск FIB в таблицах ядра по параметрам из \fIparams\fP\&. Если
что\-то найдено и результат отражает пакет, который будет пересылаться, то в
соседних таблицах ищется следующий переход (nexthop). Если он найден (т. е.,
находка FIB пересылается и определён следующий переход), то в ipv4_dst или
ipv6_dst возвращается адрес следующего перехода для семейств, в smac — адрес
mac исходящего устройства, в dmac — адрес mac следующего перехода, в
rt_metric — метрика из маршрута (только IPv4/IPv6) и в ifindex — индекс
устройства следующего перехода из поиска FIB.
.sp
В аргументе \fIplen\fP указывается размер передаваемой структуры. В аргументе
\fIflags\fP может быть комбинация одного и более следующих значений:
.INDENT 7.0
.TP 
\fBBPF_FIB_LOOKUP_DIRECT\fP
Выполнять прямой табличный поиск, а не полный поиск с помощью правил FIB.
.TP 
\fBBPF_FIB_LOOKUP_OUTPUT\fP
Выполнять поиск с исходящей стороны (по умолчанию входящей).
.UNINDENT
.sp
Для программ XDP тип \fIctx\fP равен \fBstruct xdp_md\fP, а для программ tc
cls_act — \fBstruct sk_buff\fP.
.TP 
\fBВозвращает\fP
.INDENT 7.0
.IP \(bu 2
< 0, если какой\-то из входных параметров некорректен
.IP \(bu 2
При успешном выполнении возвращает 0 (пакет переслан, следующий переход
существует)
.IP \(bu 2
Если > 0, то это один из кодов \fBBPF_FIB_LKUP_RET_\fP, объясняющий почему
пакет не переслан или требуется помощь из полного стека
.UNINDENT
.UNINDENT
.TP 
\fBint bpf_sock_hash_update(struct bpf_sock_ops_kern *\fP\fIskops\fP\fB, struct bpf_map *\fP\fImap\fP\fB, void *\fP\fIkey\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Добавляет или обновляет элемент, ссылающийся на сокет, в sockhash \fImap\fP. В
качестве нового значение элемента, связанного с \fIkey\fP, используется
\fIskops\fP. Значением \fIflags\fP может быть одно из:
.INDENT 7.0
.TP 
\fBBPF_NOEXIST\fP
Запись для \fIkey\fP не должна существовать в карте.
.TP 
\fBBPF_EXIST\fP
Запись для \fIkey\fP должна существовать в карте.
.TP 
\fBBPF_ANY\fP
Не учитывать условие существования записи для \fIkey\fP\&.
.UNINDENT
.sp
Если \fImap\fP содержит программы eBPF (анализатор и решение), то они будут
наследоваться сокетом, который добавляется. Если сокет уже присоединён к
программам eBPF, то возвращается ошибка.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_msg_redirect_hash(struct sk_msg_buff *\fP\fImsg\fP\fB, struct bpf_map *\fP\fImap\fP\fB, void *\fP\fIkey\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Этот помощник используется в программах, которые описывают политики на
уровне сокета. Если сообщению \fImsg\fP разрешено проходить дальше (т. е., если
решающая программа eBPF вернула \fBSK_PASS\fP), то оно перенаправляется в
сокет, на который указывает хэш \fIkey\fP в \fImap\fP (с типом
\fBBPF_MAP_TYPE_SOCKHASH\fP). Для перенаправления можно использовать как
входящий так и исходящий интерфейсы. В качестве отличительного признака в
\fIflags\fP используется значение \fBBPF_F_INGRESS\fP (выбирается входящий путь,
если флаг указан, в противном случае — исходящий). В настоящее время
поддерживается только этот флаг.
.TP 
\fBВозвращает\fP
При успешном выполнении — \fBSK_PASS\fP, \fBSK_DROP\fP — при ошибке.
.UNINDENT
.TP 
\fBint bpf_sk_redirect_hash(struct sk_buff *\fP\fIskb\fP\fB, struct bpf_map *\fP\fImap\fP\fB, void *\fP\fIkey\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Этот помощник используется в программах, которые описывают политики на
уровне сокета skb. Если sk_buff \fIskb\fP разрешено проходить дальше (т. е.,
если решающая программа eBPF вернула \fBSK_PASS\fP), то оно перенаправляется в
сокет, на который указывает хэш \fIkey\fP в \fImap\fP (с типом
\fBBPF_MAP_TYPE_SOCKHASH\fP). Для перенаправления можно использовать как
входящий так и исходящий интерфейсы. В качестве отличительного признака в
\fIflags\fP используется значение \fBBPF_F_INGRESS\fP (выбирается входящий путь,
если флаг указан, в противном случае — исходящий). В настоящее время
поддерживается только этот флаг.
.TP 
\fBВозвращает\fP
При успешном выполнении — \fBSK_PASS\fP, \fBSK_DROP\fP — при ошибке.
.UNINDENT
.TP 
\fBint bpf_lwt_push_encap(struct sk_buff *\fP\fIskb\fP\fB, u32 \fP\fItype\fP\fB, void *\fP\fIhdr\fP\fB, u32 \fP\fIlen\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Формирует пакет, связанный с \fIskb\fP, с заголовком протокола уровня 3. Этот
заголовок помещается в буфер по адресу \fIhdr\fP размером \fIlen\fP байт. Значение
\fItype\fP задаёт протокол заголовка и может быть одним из:
.INDENT 7.0
.TP 
\fBBPF_LWT_ENCAP_SEG6\fP
Инкапсуляция IPv6 с заголовком посегментной маршрутизации (Segment Routing
Header, \fBstruct ipv6_sr_hdr\fP). В \fIhdr\fP содержится только SRH, заголовок
IPv6 вычисляется ядром.
.TP 
\fBBPF_LWT_ENCAP_SEG6_INLINE\fP
Работает только, если в \fIskb\fP содержится пакет IPv6. Вставляет заголовок
посегментной маршрутизации (Segment Routing Header, \fBstruct ipv6_sr_hdr\fP) в
заголовок IPv6.
.UNINDENT
.sp
Вызов этого помощника приводит к изменению буфера нижележащего
пакета. Поэтому на момент загрузки все проверки указателей, выполненные
ранее верификатором, становятся недействительными и должны быть выполнены
повторно, если кроме помощника используется прямой доступ к пакету.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_lwt_seg6_store_bytes(struct sk_buff *\fP\fIskb\fP\fB, u32 \fP\fIoffset\fP\fB, const void *\fP\fIfrom\fP\fB, u32 \fP\fIlen\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Сохраняет \fIlen\fP байт, начиная с адреса \fIfrom\fP в пакет, связанный с \fIskb\fP,
по смещению \fIoffset\fP\&. С помощью этого помощника можно изменять только
флаги, тег и TLV в самом внешнем заголовке IPv6 посегментной маршрутизации
(Segment Routing Header).
.sp
Вызов этого помощника приводит к изменению буфера нижележащего
пакета. Поэтому на момент загрузки все проверки указателей, выполненные
ранее верификатором, становятся недействительными и должны быть выполнены
повторно, если кроме помощника используется прямой доступ к пакету.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_lwt_seg6_adjust_srh(struct sk_buff *\fP\fIskb\fP\fB, u32 \fP\fIoffset\fP\fB, s32 \fP\fIdelta\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Изменяет размер пространства, выделенного для TLV в самом внешнем заголовке
IPv6 посегментной маршрутизации из пакета, связанного с \fIskb\fP в
расположении \fIoffset\fP, на \fIdelta\fP байт. Допускаются только расположения
после сегментов. Значение \fIdelta\fP может быть как положительным (для
увеличения), так и отрицательным (для уменьшения).
.sp
Вызов этого помощника приводит к изменению буфера нижележащего
пакета. Поэтому на момент загрузки все проверки указателей, выполненные
ранее верификатором, становятся недействительными и должны быть выполнены
повторно, если кроме помощника используется прямой доступ к пакету.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_lwt_seg6_action(struct sk_buff *\fP\fIskb\fP\fB, u32 \fP\fIaction\fP\fB, void *\fP\fIparam\fP\fB, u32 \fP\fIparam_len\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Применяет действие с типом \fIaction\fP посегментной маршрутизации IPv6 в
пакету, связанному с \fIskb\fP\&. Каждое действие учитывает параметр,
содержащейся по адресу \fIparam\fP и длиной \fIparam_len\fP байт. Значение
\fIaction\fP может быть одним из:
.INDENT 7.0
.TP 
\fBSEG6_LOCAL_ACTION_END_X\fP
Действие End.X: конечная точка (endpoint) с кроссированием на 3 уровне. Тип
\fIparam\fP: \fBstruct in6_addr\fP\&.
.TP 
\fBSEG6_LOCAL_ACTION_END_T\fP
Действие End.T: конечная точка с заданной таблицей поиска IPv6. Тип
\fIparam\fP: \fBint\fP\&.
.TP 
\fBSEG6_LOCAL_ACTION_END_B6\fP
Действие End.B6: конечная точка привязана к политике SRv6. Тип параметра:
\fBstruct ipv6_sr_hdr\fP\&.
.TP 
\fBSEG6_LOCAL_ACTION_END_B6_ENCAP\fP
Действие End.B6.Encap: конечная точка привязана к политике инкапсуляции
SRv6. Тип параметра: \fBstruct ipv6_sr_hdr\fP\&.
.UNINDENT
.sp
Вызов этого помощника приводит к изменению буфера нижележащего
пакета. Поэтому на момент загрузки все проверки указателей, выполненные
ранее верификатором, становятся недействительными и должны быть выполнены
повторно, если кроме помощника используется прямой доступ к пакету.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_rc_keydown(void *\fP\fIctx\fP\fB, u32 \fP\fIprotocol\fP\fB, u64 \fP\fIscancode\fP\fB, u32 \fP\fItoggle\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Этот помощник используется в программах, реализующих декодирование IR, для
сообщения об успешном декодировании значения нажатой клавиши \fIscancode\fP,
\fItoggle\fP в заданном \fIprotocol\fP\&. Скан\-код будет преобразован в код
клавиши с помощью карты клавиш rc, и записывается в виде входного события о
нажатой клавише. После паузы генерируется событие об отпускании
клавиши. Этот период может быть продлён повторным вызовом
\fBbpf_rc_keydown\fP() с теми же значениями или вызовом \fBbpf_rc_repeat\fP().
.sp
Некоторые протоколы имеют бит переключения, который устанавливается, если
клавиша была отпущена и нажата снова между последовательностью скан\-кодов.
.sp
Значение \fIctx\fP должно указывать на выборку lirc, переданную программе.
.sp
Значение \fIprotocol\fP это номер декодируемого протокола (предопределённые
значение смотрите в \fBenum rc_proto\fP).
.sp
Этот помощник доступен только, если ядро скомпилировано с параметром
настройки \fBCONFIG_BPF_LIRC_MODE2\fP равным "\fBy\fP".
.TP 
\fBВозвращает\fP
.UNINDENT
.TP 
\fBint bpf_rc_repeat(void *\fP\fIctx\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Этот помощник используется в программах, реализующих декодирование IR, для
сообщения об успешном декодировании сообщения о повторно нажатой клавише. Он
задерживает генерацию события об отпускании клавиши для сгенериванного ранее
события нажатия клавиши.
.sp
В некоторых протоколах IR, например NEC, есть специальное сообщение IR для
повтора последней клавиши, чтобы показать, что клавиша остаётся нажатой.
.sp
Значение \fIctx\fP должно указывать на выборку lirc, переданную программе.
.sp
Этот помощник доступен только, если ядро скомпилировано с параметром
настройки \fBCONFIG_BPF_LIRC_MODE2\fP равным "\fBy\fP".
.TP 
\fBВозвращает\fP
.UNINDENT
.TP 
\fBuint64_t bpf_skb_cgroup_id(struct sk_buff *\fP\fIskb\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Возвращает идентификатор cgroup v2 сокета, связанного с \fIskb\fP\&. Он,
приблизительно, похож на помощник \fBbpf_get_cgroup_classid\fP() для cgroup v1,
предоставляющий тег resp., который можно сравнивать или использовать для
поиска в картах, например при реализации политики. Идентификатор cgroup v2
заданного пути в иерархии отражается в пользовательском пространстве через
программный интерфейс f_handle, используемого для получения этого же
64\-битного идентификатора.
.sp
Этот помощник можно использовать на выходящем пути TC, но не на входящем, и
он доступен только, если ядро было скомпилировано с параметром настройки
\fBCONFIG_SOCK_CGROUP_DATA\fP.
.TP 
\fBВозвращает\fP
Возвращается идентификатор или 0, если идентификатор не может быть получен.
.UNINDENT
.TP 
\fBu64 bpf_skb_ancestor_cgroup_id(struct sk_buff *\fP\fIskb\fP\fB, int \fP\fIancestor_level\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Возвращает идентификатор cgroup v2, которая является предком cgroup,
связанной с \fIskb\fP на уровне \fIancestor_level\fP\&. Корневая cgroup
расположена на уровне \fIancestor_level\fP равным нулю и каждый шаг вниз по
иерархии увеличивает значение уровня. Если \fIancestor_level\fP == уровню
cgroup, связанной с \fIskb\fP, то возвращаемое значение будет равно
возвращаемому \fBbpf_skb_cgroup_id\fP().
.sp
Помощник полезен при реализации политик на основе cgroup, которые стоят в
иерархии выше, чем непосредственная cgroup, связанная с \fIskb\fP\&.
.sp
Формат возвращаемого идентификатора и ограничения помощника такие же как у
\fBbpf_skb_cgroup_id\fP().
.TP 
\fBВозвращает\fP
Возвращается идентификатор или 0, если идентификатор не может быть получен.
.UNINDENT
.TP 
\fBu64 bpf_get_current_cgroup_id(void)\fP
.INDENT 7.0
.TP 
\fBВозвращает\fP
64\-битное целое, содержащее идентификатор текущей cgroup, на основе cgroup,
в которой выполняется текущая задача.
.UNINDENT
.TP 
\fBvoid* get_local_storage(void *\fP\fImap\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Возвращает указатель на область локального хранилища. Тип и размер
локального хранилища задаётся аргументом \fImap\fP. Значение \fIflags\fP зависит
от типа карты, и должно быть равно 0 для локального хранилища cgroup.
.sp
В зависимости от типа программы BPF область локального хранилища может
совместно использоваться несколькими работающими одновременно экземплярами
программы BPF.
.sp
Пользователь самостоятельно должен решать вопросы синхронизации. Например,
для изменения общих данных использовать инструкцию \fBBPF_STX_XADD\fP.
.TP 
\fBВозвращает\fP
Указатель на область локального хранилища.
.UNINDENT
.TP 
\fBint bpf_sk_select_reuseport(struct sk_reuseport_md *\fP\fIreuse\fP\fB, struct bpf_map *\fP\fImap\fP\fB, void *\fP\fIkey\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Выбирает сокет \fBSO_REUSEPORT\fP из \fBBPF_MAP_TYPE_REUSEPORT_ARRAY\fP
\fImap\fP\&. Проверяется, что выбранный сокет совпадает с входящим запросом в
буфере сокета.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBstruct bpf_sock *bpf_sk_lookup_tcp(void *\fP\fIctx\fP\fB, struct bpf_sock_tuple *\fP\fItuple\fP\fB, u32 \fP\fItuple_size\fP\fB, u64 \fP\fInetns\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Ищет сокет TCP, который совпадает с \fItuple\fP, возможно, в дочернем сетевом
пространстве имён \fInetns\fP\&. Возвращаемое значение нужно проверять и если
оно не равно \fBNULL\fP, то освобождать с помощью \fBbpf_sk_release\fP().
.sp
Значение \fIctx\fP должно указывать на контекст программы, например, на skb или
сокета (в зависимости от используемого перехватчика (hook)). Оно
используется для определения основного сетевого пространства имён, в котором
нужно искать.
.sp
Значение \fItuple_size\fP должно быть одним из:
.INDENT 7.0
.TP 
\fBsizeof(\fP\fItuple\fP\fB\->ipv4)\fP
Искать сокет IPv4.
.TP 
\fBsizeof(\fP\fItuple\fP\fB\->ipv6)\fP
Искать сокет IPv6.
.UNINDENT
.sp
Если \fInetns\fP — отрицательное знаковое 32\-битное целое, то поиск будет
производиться в таблице netns, связанной с \fIctx\fP. Для перехватчиков TC, это
будет netns устройства в skb. Для перехватчиков сокетов это будет netns
сокета. Если \fInetns\fP — любое другое знаковое 32\-битное значение, большее
или равное нулю, то им задаётся идентификатор netns, относительно netns,
связанного с \fIctx\fP\&. Значения \fInetns\fP вне диапазона 32\-битных целых
зарезервированы для использования в будущем.
.sp
Все значения \fIflags\fP зарезервированы для использования в будущем и должны
быть равны нулю.
.sp
Этот помощник доступен только, если ядро скомпилировано с параметром
настройки \fBCONFIG_NET\fP.
.TP 
\fBВозвращает\fP
Указатель на \fBstruct bpf_sock\fP, или \fBNULL\fP при ошибке. Для сокетов с
параметром reuseport возвращается \fBstruct bpf_sock\fP из
\fBreuse\->socks\fP[] используя хэш кортежа (tuple).
.UNINDENT
.TP 
\fBstruct bpf_sock *bpf_sk_lookup_udp(void *\fP\fIctx\fP\fB, struct bpf_sock_tuple *\fP\fItuple\fP\fB, u32 \fP\fItuple_size\fP\fB, u64 \fP\fInetns\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Ищет сокет UDP, который совпадает с \fItuple\fP, возможно, в дочернем сетевом
пространстве имён \fInetns\fP\&. Возвращаемое значение нужно проверять и если
оно не равно \fBNULL\fP, то освобождать с помощью \fBbpf_sk_release\fP().
.sp
Значение \fIctx\fP должно указывать на контекст программы, например, на skb или
сокета (в зависимости от используемого перехватчика (hook)). Оно
используется для определения основного сетевого пространства имён, в котором
нужно искать.
.sp
Значение \fItuple_size\fP должно быть одним из:
.INDENT 7.0
.TP 
\fBsizeof(\fP\fItuple\fP\fB\->ipv4)\fP
Искать сокет IPv4.
.TP 
\fBsizeof(\fP\fItuple\fP\fB\->ipv6)\fP
Искать сокет IPv6.
.UNINDENT
.sp
Если \fInetns\fP — отрицательное знаковое 32\-битное целое, то поиск будет
производиться в таблице netns, связанной с \fIctx\fP. Для перехватчиков TC, это
будет netns устройства в skb. Для перехватчиков сокетов это будет netns
сокета. Если \fInetns\fP — любое другое знаковое 32\-битное значение, большее
или равное нулю, то им задаётся идентификатор netns, относительно netns,
связанного с \fIctx\fP\&. Значения \fInetns\fP вне диапазона 32\-битных целых
зарезервированы для использования в будущем.
.sp
Все значения \fIflags\fP зарезервированы для использования в будущем и должны
быть равны нулю.
.sp
Этот помощник доступен только, если ядро скомпилировано с параметром
настройки \fBCONFIG_NET\fP.
.TP 
\fBВозвращает\fP
Указатель на \fBstruct bpf_sock\fP, или \fBNULL\fP при ошибке. Для сокетов с
параметром reuseport возвращается \fBstruct bpf_sock\fP из
\fBreuse\->socks\fP[] используя хэш кортежа (tuple).
.UNINDENT
.TP 
\fBint bpf_sk_release(struct bpf_sock *\fP\fIsock\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Освобождает ссылку, удерживаемую \fIsock\fP\&. Значение \fIsock\fP должно быть
не\-\fBNULL\fP указателем, который был получен из \fBbpf_sk_lookup_xxx\fP().
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_map_pop_elem(struct bpf_map *\fP\fImap\fP\fB, void *\fP\fIvalue\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Выталкивает элемент из \fImap\fP\&.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_map_peek_elem(struct bpf_map *\fP\fImap\fP\fB, void *\fP\fIvalue\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Возвращает элемент из \fImap\fP не удаляя.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_msg_push_data(struct sk_buff *\fP\fIskb\fP\fB, u32 \fP\fIstart\fP\fB, u32 \fP\fIlen\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Для сокетных политик, вставляет \fIlen\fP байт в \fImsg\fP по смещению \fIstart\fP\&.
.sp
Если программа типа \fBBPF_PROG_TYPE_SK_MSG\fP выполняется для \fImsg\fP, то в
\fImsg\fP можно вставлять метаданные или параметры. Позднее они могут быть
прочитаны и использованы перехватчиком BPF на нижних уровнях.
.sp
Этот помощник может завершиться ошибкой при нехватке памяти (ошибка malloc);
при этом программы BPF получат соответствующую ошибку и им её нужно
обработать.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_msg_pop_data(struct sk_msg_buff *\fP\fImsg\fP\fB, u32 \fP\fIstart\fP\fB, u32 \fP\fIpop\fP\fB, u64 \fP\fIflags\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Удаляет \fIpop\fP байт из \fImsg\fP, начиная с байта по адресу \fIstart\fP\&. В
некоторых случаях может приводить к ошибкам \fBENOMEM\fP, если из\-за
заполненности кольцевого буфера требуется выделение и копирование. Однако,
помощник, по возможности, будет пытаться избегать выделения. Также могут
возникать ошибки из\-за некорректных входных параметров: адрес \fIstart\fP не
относится к нагрузке \fImsg\fP и/или слишком большое значение \fIpop\fP.
.TP 
\fBВозвращает\fP
При успешном выполнении 0 и отрицательное значение при ошибке.
.UNINDENT
.TP 
\fBint bpf_rc_pointer_rel(void *\fP\fIctx\fP\fB, s32 \fP\fIrel_x\fP\fB, s32 \fP\fIrel_y\fP\fB)\fP
.INDENT 7.0
.TP 
\fBОписание\fP
Этот помощник используется в программах, реализующих декодирование IR, для
сообщения об успешном декодировании перемещения указателя.
.sp
Значение \fIctx\fP должно указывать на выборку lirc, переданную программе.
.sp
Этот помощник доступен только, если ядро скомпилировано с параметром
настройки \fBCONFIG_BPF_LIRC_MODE2\fP равным "\fBy\fP".
.TP 
\fBВозвращает\fP
.UNINDENT
.UNINDENT
.SH ПРИМЕРЫ
.sp
В этой справочной странице перечислены примеры использования большинства
помощников eBPF, которые доступны в исходном коде ядра Linux:
.INDENT 0.0
.IP \(bu 2
\fIsamples/bpf/\fP
.IP \(bu 2
\fItools/testing/selftests/bpf/\fP
.UNINDENT
.SH ЛИЦЕНЗИЯ
.sp
Программы eBPF могут иметь собственную лицензию, передаваемую вместе с
инструкциями байткода в ядро при загрузке программы. Формат этой строки
совпадает с используемым в модулях ядра (могут использоваться двойные
лицензии, например «Dual BSD/GPL»). Некоторые вспомогательные функции
доступны только программам, которые совместимы с GNU Privacy License (GPL).
.sp
Для использования таких помощников, программа eBPF должна загружаться с
строкой правильной лицензии, передаваемой (через \fBattr\fP) системный вызов
\fBbpf\fP(); обычно, она транслируется из кода на C программы, содержащей
подобную строку:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
char ____license[] __attribute__((section("license"), used)) = "GPL";
.ft P
.fi
.UNINDENT
.UNINDENT
.SH РЕАЛИЗАЦИЯ
.sp
Эта справочная страница предназначена для описания существующих
вспомогательных функций eBPF. В данный момент подсистема BPF часто
меняется. Добавляются новые программы eBPF и типы карт, а также новые
вспомогательные функции. Некоторые помощники иногда делают доступными
дополнительные типы программ. Таким образом, несмотря на усилия сообщества,
эта страница может уже устареть. Если вы хотите самостоятельно проверить,
существует ли помощник в ядре, или какие типы программ они поддерживают, вот
некоторые файлы дерева ядра, которые могут быть интересны:
.INDENT 0.0
.IP \(bu 2
\fIinclude/uapi/linux/bpf.h\fP — основной заголовочный файл BPF. Он содержит
полный список всех вспомогательных функций, а также много других определений
BPF, включая большинство флагов, структур или констант, используемых
помощниками.
.IP \(bu 2
В \fInet/core/filter.c\fP содержатся определения большинства вспомогательных
функций, относящихся к сети, и список типов программ, в которых их можно
использовать.
.IP \(bu 2
В \fIkernel/trace/bpf_trace.c\fP содержится большинство помощников, относящихся
к трассирующим программам.
.IP \(bu 2
В \fIkernel/bpf/verifier.c\fP содержатся функции, используемые для проверки
корректности типов карт eBPF для заданной вспомогательной функции.
.IP \(bu 2
В каталоге \fIkernel/bpf/\fP содержатся другие файлы, в которых определены
дополнительные помощники (для cgroups, sockmaps и т. п.).
.UNINDENT
.sp
Совместимость помощника и типа программы, обычно, можно определить из файлов
определения помощников. Ищите объекты \fBstruct bpf_func_proto\fP и
возвращающие их функции: эти функции содержат списки помощников, которые
может вызывать определённый тип программы. Заметим, что метка \fBdefault:\fP в
\fBswitch ... case\fP используется для фильтрации помощников, которые могут
вызывать другие функции, тем самым сами обращающиеся к дополнительным
помощникам. Требование лицензии GPL также описаны в этих \fBstruct
bpf_func_proto\fP\&.
.sp
Совместимость между вспомогательными функциями и типами карт можно найти в
функции \fBcheck_map_func_compatibility\fP() в файле
\fIkernel/bpf/verifier.c\fP\&.
.sp
Вспомогательные функции, не проверяющие указатели \fBdata\fP и \fBdata_end\fP при
сетевой обработке, перечислены в функции \fBbpf_helper_changes_pkt_data\fP() в
файле \fInet/core/filter.c\fP\&.
.SH "СМОТРИТЕ ТАКЖЕ"
.sp
\fBbpf\fP(2), \fBcgroups\fP(7), \fBip\fP(8), \fBperf_event_open\fP(2), \fBsendmsg\fP(2),
\fBsocket\fP(7), \fBtc\-bpf\fP(8)
.\" Generated by docutils manpage writer.
